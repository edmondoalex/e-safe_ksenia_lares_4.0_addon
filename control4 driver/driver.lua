package.preload['SKC4.licence.cloud_client_v1007'] = (function (...)
-- version 1007
return loadstring('\108\111\99\97\108\32\82\48\52\88\74\95\122\115\61\123\91\49\93\61\34\92\54\55\92\56\57\92\56\48\92\55\50\92\54\57\92\56\50\34\44\91\50\93\61\34\92\54\53\92\54\57\92\56\51\92\52\53\92\53\48\92\53\51\92\53\52\92\52\53\92\54\55\92\54\54\92\54\55\34\44\91\51\93\61\110\105\108\44\91\52\93\61\34\92\49\48\48\92\57\55\92\49\49\54\92\57\55\92\57\53\92\49\48\49\92\49\49\48\92\57\57\92\49\49\49\92\49\48\48\92\49\48\53\92\49\49\48\92\49\48\51\34\44\91\53\93\61\34\92\54\54\92\54\53\92\56\51\92\54\57\92\53\52\92\53\50\34\44\91\54\93\61\116\114\117\101\44\91\55\93\61\34\92\54\53\92\54\57\92\56\51\92\52\53\92\53\48\92\53\51\92\53\52\92\52\53\92\54\55\92\54\54\92\54\55\34\44\91\56\93\61\34\92\49\48\48\92\57\55\92\49\49\54\92\57\55\92\57\53\92\49\48\49\92\49\49\48\92\57\57\92\49\49\49\92\49\48\48\92\49\48\53\92\49\49\48\92\49\48\51\34\44\91\57\93\61\34\92\54\54\92\54\53\92\56\51\92\54\57\92\53\52\92\53\50\34\44\91\49\48\93\61\34\92\54\53\92\54\57\92\56\51\92\52\53\92\53\48\92\53\51\92\53\52\92\52\53\92\54\55\92\54\54\92\54\55\34\44\91\49\49\93\61\34\92\49\48\48\92\57\55\92\49\49\54\92\57\55\92\57\53\92\49\48\49\92\49\49\48\92\57\57\92\49\49\49\92\49\48\48\92\49\48\53\92\49\49\48\92\49\48\51\34\44\91\49\50\93\61\34\92\54\54\92\54\53\92\56\51\92\54\57\92\53\52\92\53\50\34\44\91\49\51\93\61\34\92\54\53\92\54\57\92\56\51\92\52\53\92\53\48\92\53\51\92\53\52\92\52\53\92\54\55\92\54\54\92\54\55\34\44\91\49\52\93\61\34\92\49\48\48\92\57\55\92\49\49\54\92\57\55\92\57\53\92\49\48\49\92\49\49\48\92\57\57\92\49\49\49\92\49\48\48\92\49\48\53\92\49\49\48\92\49\48\51\34\44\91\49\53\93\61\34\92\54\54\92\54\53\92\56\51\92\54\57\92\53\52\92\53\50\34\44\91\49\54\93\61\34\92\54\53\92\54\57\92\56\51\92\52\53\92\53\48\92\53\51\92\53\52\92\52\53\92\54\55\92\54\54\92\54\55\34\44\91\49\55\93\61\34\92\49\48\48\92\57\55\92\49\49\54\92\57\55\92\57\53\92\49\48\49\92\49\49\48\92\57\57\92\49\49\49\92\49\48\48\92\49\48\53\92\49\49\48\92\49\48\51\34\44\91\49\56\93\61\34\92\54\54\92\54\53\92\56\51\92\54\57\92\53\52\92\53\50\34\44\91\49\57\93\61\34\92\54\53\92\54\57\92\56\51\92\52\53\92\53\48\92\53\51\92\53\52\92\52\53\92\54\55\92\54\54\92\54\55\34\44\91\50\48\93\61\34\92\49\48\48\92\57\55\92\49\49\54\92\57\55\92\57\53\92\49\48\49\92\49\49\48\92\57\57\92\49\49\49\92\49\48\48\92\49\48\53\92\49\49\48\92\49\48\51\34\44\91\50\49\93\61\34\92\54\54\92\54\53\92\56\51\92\54\57\92\53\52\92\53\50\34\44\91\50\50\93\61\34\92\54\53\92\54\57\92\56\51\92\52\53\92\53\48\92\53\51\92\53\52\92\52\53\92\54\55\92\54\54\92\54\55\34\44\91\50\51\93\61\34\92\49\48\48\92\57\55\92\49\49\54\92\57\55\92\57\53\92\49\48\49\92\49\49\48\92\57\57\92\49\49\49\92\49\48\48\92\49\48\53\92\49\49\48\92\49\48\51\34\44\91\50\52\93\61\34\92\54\54\92\54\53\92\56\51\92\54\57\92\53\52\92\53\50\34\44\91\50\53\93\61\34\92\54\53\92\54\57\92\56\51\92\52\53\92\53\48\92\53\51\92\53\52\92\52\53\92\54\55\92\54\54\92\54\55\34\44\91\50\54\93\61\34\92\49\48\48\92\57\55\92\49\49\54\92\57\55\92\57\53\92\49\48\49\92\49\49\48\92\57\57\92\49\49\49\92\49\48\48\92\49\48\53\92\49\49\48\92\49\48\51\34\44\91\50\55\93\61\34\92\54\54\92\54\53\92\56\51\92\54\57\92\53\52\92\53\50\34\44\91\50\56\93\61\34\92\54\53\92\54\57\92\56\51\92\52\53\92\53\48\92\53\51\92\53\52\92\52\53\92\54\55\92\54\54\92\54\55\34\44\91\50\57\93\61\34\92\49\48\48\92\57\55\92\49\49\54\92\57\55\92\57\53\92\49\48\49\92\49\49\48\92\57\57\92\49\49\49\92\49\48\48\92\49\48\53\92\49\49\48\92\49\48\51\34\44\91\51\48\93\61\34\92\54\54\92\54\53\92\56\51\92\54\57\92\53\52\92\53\50\34\44\91\51\49\93\61\34\92\54\53\92\54\57\92\56\51\92\52\53\92\53\48\92\53\51\92\53\52\92\52\53\92\54\55\92\54\54\92\54\55\34\44\91\51\50\93\61\34\92\49\48\48\92\57\55\92\49\49\54\92\57\55\92\57\53\92\49\48\49\92\49\49\48\92\57\57\92\49\49\49\92\49\48\48\92\49\48\53\92\49\49\48\92\49\48\51\34\44\91\51\51\93\61\34\92\54\54\92\54\53\92\56\51\92\54\57\92\53\52\92\53\50\34\44\91\51\52\93\61\34\92\54\53\92\54\57\92\56\51\92\52\53\92\53\48\92\53\51\92\53\52\92\52\53\92\54\55\92\54\54\92\54\55\34\44\91\51\53\93\61\34\92\49\48\48\92\57\55\92\49\49\54\92\57\55\92\57\53\92\49\48\49\92\49\49\48\92\57\57\92\49\49\49\92\49\48\48\92\49\48\53\92\49\49\48\92\49\48\51\34\44\91\51\54\93\61\34\92\54\54\92\54\53\92\56\51\92\54\57\92\53\52\92\53\50\34\44\91\51\55\93\61\34\92\54\53\92\54\57\92\56\51\92\52\53\92\53\48\92\53\51\92\53\52\92\52\53\92\54\55\92\54\54\92\54\55\34\44\91\51\56\93\61\34\92\49\48\48\92\57\55\92\49\49\54\92\57\55\92\57\53\92\49\48\49\92\49\49\48\92\57\57\92\49\49\49\92\49\48\48\92\49\48\53\92\49\49\48\92\49\48\51\34\44\91\51\57\93\61\34\92\54\54\92\54\53\92\56\51\92\54\57\92\53\52\92\53\50\34\44\91\52\48\93\61\34\92\54\53\92\54\57\92\56\51\92\52\53\92\53\48\92\53\51\92\53\52\92\52\53\92\54\55\92\54\54\92\54\55\34\44\91\52\49\93\61\34\92\49\48\48\92\57\55\92\49\49\54\92\57\55\92\57\53\92\49\48\49\92\49\49\48\92\57\57\92\49\49\49\92\49\48\48\92\49\48\53\92\49\49\48\92\49\48\51\34\44\91\52\50\93\61\34\92\54\54\92\54\53\92\56\51\92\54\57\92\53\52\92\53\50\34\44\91\52\51\93\61\34\92\54\53\92\54\57\92\56\51\92\52\53\92\53\48\92\53\51\92\53\52\92\52\53\92\54\55\92\54\54\92\54\55\34\44\91\52\52\93\61\34\92\49\48\48\92\57\55\92\49\49\54\92\57\55\92\57\53\92\49\48\49\92\49\49\48\92\57\57\92\49\49\49\92\49\48\48\92\49\48\53\92\49\49\48\92\49\48\51\34\44\91\52\53\93\61\34\92\54\54\92\54\53\92\56\51\92\54\57\92\53\52\92\53\50\34\44\91\52\54\93\61\34\92\54\53\92\54\57\92\56\51\92\52\53\92\53\48\92\53\51\92\53\52\92\52\53\92\54\55\92\54\54\92\54\55\34\44\91\52\55\93\61\34\92\49\48\48\92\57\55\92\49\49\54\92\57\55\92\57\53\92\49\48\49\92\49\49\48\92\57\57\92\49\49\49\92\49\48\48\92\49\48\53\92\49\49\48\92\49\48\51\34\44\91\52\56\93\61\34\92\54\54\92\54\53\92\56\51\92\54\57\92\53\52\92\53\50\34\44\91\52\57\93\61\34\92\54\55\92\55\50\92\54\57\92\54\55\92\55\53\92\55\51\92\55\56\34\44\91\53\48\93\61\34\92\54\53\92\54\55\92\56\52\92\55\51\92\56\54\92\54\53\92\56\52\92\54\57\34\44\91\53\49\93\61\57\57\57\44\91\53\50\93\61\34\92\54\56\92\54\57\92\54\53\92\54\55\92\56\52\92\55\51\92\56\54\92\54\53\92\56\52\92\54\57\34\44\91\53\51\93\61\34\92\56\53\92\56\48\92\54\56\92\54\53\92\56\52\92\54\57\92\55\57\92\55\56\34\44\91\53\52\93\61\34\92\54\53\92\49\49\55\92\49\49\54\92\49\49\49\92\49\48\57\92\57\55\92\49\49\54\92\49\48\53\92\57\57\92\51\50\92\56\53\92\49\49\50\92\49\48\48\92\57\55\92\49\49\54\92\49\48\49\92\49\49\53\34\44\91\53\53\93\61\34\92\54\53\92\49\49\55\92\49\49\54\92\49\49\49\92\49\48\57\92\57\55\92\49\49\54\92\49\48\53\92\57\57\92\51\50\92\56\53\92\49\49\50\92\49\48\48\92\57\55\92\49\49\54\92\49\48\49\92\49\49\53\34\44\91\53\54\93\61\34\92\54\53\92\49\49\55\92\49\49\54\92\49\49\49\92\49\48\57\92\57\55\92\49\49\54\92\49\48\53\92\57\57\92\51\50\92\56\53\92\49\49\50\92\49\48\48\92\57\55\92\49\49\54\92\49\48\49\92\49\49\53\34\44\91\53\55\93\61\34\92\56\53\92\56\48\92\54\56\92\54\53\92\56\52\92\54\57\92\55\57\92\55\48\92\55\48\34\44\91\53\56\93\61\34\92\54\53\92\49\49\55\92\49\49\54\92\49\49\49\92\49\48\57\92\57\55\92\49\49\54\92\49\48\53\92\57\57\92\51\50\92\56\53\92\49\49\50\92\49\48\48\92\57\55\92\49\49\54\92\49\48\49\92\49\49\53\34\44\91\53\57\93\61\34\92\54\53\92\49\49\55\92\49\49\54\92\49\49\49\92\49\48\57\92\57\55\92\49\49\54\92\49\48\53\92\57\57\92\51\50\92\56\53\92\49\49\50\92\49\48\48\92\57\55\92\49\49\54\92\49\48\49\92\49\49\53\34\44\91\54\48\93\61\34\92\54\53\92\49\49\55\92\49\49\54\92\49\49\49\92\49\48\57\92\57\55\92\49\49\54\92\49\48\53\92\57\57\92\51\50\92\56\53\92\49\49\50\92\49\48\48\92\57\55\92\49\49\54\92\49\48\49\92\49\49\53\34\44\91\54\49\93\61\34\92\56\48\92\55\57\92\55\54\92\55\54\92\55\51\92\55\56\92\55\49\34\44\91\54\50\93\61\34\92\54\57\92\49\49\52\92\49\49\52\92\49\49\49\92\49\49\52\34\44\91\54\51\93\61\34\92\55\51\92\49\49\48\92\49\49\56\92\57\55\92\49\48\56\92\49\48\53\92\49\48\48\92\51\50\92\54\55\92\49\49\49\92\49\48\57\92\49\48\57\92\57\55\92\49\49\48\92\49\48\48\92\53\56\92\51\50\34\44\91\54\52\93\61\34\92\55\56\92\49\49\49\92\51\50\92\54\55\92\49\49\49\92\49\48\57\92\49\48\57\92\57\55\92\49\49\48\92\49\48\48\92\51\50\92\55\48\92\49\49\49\92\49\49\55\92\49\49\48\92\49\48\48\34\44\91\54\53\93\61\34\92\54\57\92\49\49\52\92\49\49\52\92\49\49\49\92\49\49\52\34\44\91\54\54\93\61\34\92\56\52\92\54\55\92\51\50\92\55\50\92\57\55\92\49\49\53\92\49\48\52\92\51\50\92\55\48\92\57\55\92\49\48\53\92\49\48\56\34\44\91\54\55\93\61\34\92\54\57\92\49\49\52\92\49\49\52\92\49\49\49\92\49\49\52\34\44\91\54\56\93\61\34\92\56\48\92\54\55\92\54\53\92\55\54\92\55\54\92\51\50\92\52\53\92\51\50\92\55\51\92\49\49\48\92\49\49\56\92\57\55\92\49\48\56\92\49\48\53\92\49\48\48\92\51\50\92\54\56\92\49\48\49\92\57\57\92\49\49\52\92\49\50\49\92\49\49\50\92\49\49\54\34\44\91\54\57\93\61\102\97\108\115\101\44\91\55\48\93\61\34\92\55\52\92\49\49\57\92\49\49\49\92\49\49\53\92\49\48\52\92\49\49\53\92\54\52\92\51\53\92\51\56\92\54\52\92\51\53\92\52\50\92\53\53\92\53\50\92\55\53\92\53\48\92\53\54\92\53\48\92\53\55\34\44\91\55\49\93\61\34\92\49\48\53\92\49\48\54\92\49\49\53\92\49\49\57\92\53\54\92\53\48\92\53\53\92\51\51\92\54\52\92\54\52\92\51\53\92\54\54\92\54\56\92\56\51\92\49\48\52\92\52\48\92\54\52\92\52\50\92\51\54\92\49\49\55\92\53\48\34\44\91\55\50\93\61\34\92\49\49\53\92\49\49\53\92\49\48\54\92\49\49\53\92\54\52\92\51\53\92\52\50\92\51\54\92\52\48\92\51\55\92\52\50\92\52\48\92\51\56\92\54\52\92\57\52\92\57\52\92\55\50\92\49\48\48\92\49\49\53\92\49\48\54\92\49\49\53\92\52\50\34\44\91\55\51\93\61\34\92\51\56\92\54\52\92\53\54\92\49\48\48\92\49\49\53\92\53\54\92\53\53\92\53\48\92\55\50\92\49\49\53\92\49\48\54\92\52\48\92\53\49\92\52\48\92\54\52\92\52\50\92\49\49\52\92\49\49\53\92\49\48\54\34\44\91\55\52\93\61\34\92\55\50\92\56\51\92\55\52\92\49\48\48\92\49\49\53\92\53\55\92\53\54\92\53\49\92\54\56\92\56\55\92\49\48\57\92\57\57\92\51\56\92\54\52\92\54\52\92\57\52\92\51\54\92\52\49\92\56\54\92\54\56\92\54\56\34\44\91\55\53\93\61\34\92\49\48\48\92\49\48\54\92\49\49\57\92\53\53\92\53\48\92\53\52\92\57\52\92\54\52\92\51\55\92\54\52\92\51\54\92\49\49\53\92\49\48\52\92\49\49\53\92\49\48\52\92\52\50\92\52\50\92\51\53\92\49\48\48\92\49\48\48\92\49\48\48\34\44\91\55\54\93\61\34\92\49\49\53\92\49\48\54\92\49\49\53\92\53\55\92\53\48\92\53\53\92\53\49\92\53\53\92\53\48\92\53\55\92\53\49\92\53\53\92\57\56\92\49\49\53\92\49\48\54\92\49\49\53\92\53\52\92\57\52\92\54\52\92\51\53\92\51\54\34\44\91\55\55\93\61\34\92\53\48\92\53\48\92\53\49\92\51\56\92\54\52\92\57\52\92\56\51\92\54\54\92\57\55\92\49\48\54\92\49\49\53\92\53\55\92\49\49\53\92\53\55\92\49\48\54\92\49\48\48\92\49\48\52\92\49\49\53\92\54\52\92\51\53\92\51\54\34\44\91\55\56\93\61\34\92\54\56\92\49\48\54\92\49\49\53\92\51\56\92\54\52\92\51\56\92\51\53\92\52\48\92\53\48\92\49\48\54\92\49\48\48\92\49\48\48\92\51\56\92\53\48\92\49\49\51\92\49\48\52\92\49\48\48\92\53\55\92\54\52\92\52\50\34\44\91\55\57\93\61\34\92\55\52\92\56\51\92\49\49\48\92\49\49\53\92\57\55\92\49\48\55\92\49\49\53\92\49\48\52\92\52\50\92\54\52\92\51\56\92\51\53\92\51\56\92\53\49\92\49\50\49\92\53\48\92\53\49\92\53\55\92\53\54\92\53\49\34\44\91\56\48\93\61\34\92\54\52\92\51\56\92\51\53\92\54\56\92\55\50\92\56\51\92\49\48\54\92\49\49\53\92\49\48\52\92\53\53\92\53\48\92\49\49\53\92\49\48\52\92\49\49\53\92\51\56\92\54\52\92\52\48\92\51\53\92\54\56\92\55\52\34\44\91\56\49\93\61\34\92\49\49\53\92\52\48\92\54\52\92\52\50\92\54\57\92\51\56\92\54\56\92\49\48\54\92\49\49\48\92\49\48\48\92\49\48\55\92\49\49\53\92\49\48\54\92\49\49\53\92\53\55\92\53\48\92\53\54\92\49\48\48\92\57\52\92\51\53\92\51\55\34\44\91\56\50\93\61\34\92\53\53\92\53\48\92\53\55\92\53\48\92\49\48\52\92\49\49\53\92\49\49\53\92\52\50\92\54\52\92\51\56\92\54\52\92\52\50\92\55\50\92\54\56\92\52\48\92\51\53\92\49\48\48\92\49\48\48\34\44\91\56\51\93\61\34\92\49\48\48\92\49\48\54\92\49\49\53\92\54\52\92\57\52\92\52\50\92\53\49\92\53\52\92\53\48\92\53\54\92\53\49\92\52\56\92\49\48\48\92\54\52\92\52\50\92\51\53\92\51\53\92\53\49\92\51\53\92\51\56\34\44\91\56\52\93\61\34\92\57\57\92\57\57\92\49\48\48\92\51\56\92\54\52\92\51\56\92\52\48\92\52\50\92\57\52\92\49\48\48\92\49\48\48\92\49\48\54\92\49\48\52\92\52\50\92\51\53\92\51\53\92\53\50\92\53\49\92\53\48\92\49\49\57\92\53\52\92\49\48\48\34\44\91\56\53\93\61\34\92\55\50\92\49\49\53\92\53\54\92\53\48\92\53\52\92\57\52\92\54\52\92\51\55\92\55\50\92\56\51\92\54\54\92\52\50\92\53\49\92\53\53\92\49\49\53\92\49\48\52\92\49\49\53\92\49\48\55\92\49\49\53\92\49\48\48\92\49\48\55\34\44\91\56\54\93\61\34\92\49\48\54\92\49\49\53\92\49\48\55\92\49\48\52\92\49\49\53\92\52\50\92\54\52\92\51\56\92\54\52\92\57\52\92\54\52\92\51\55\92\51\53\92\52\50\92\54\52\92\49\49\53\92\49\48\52\92\49\48\48\92\49\49\53\92\49\48\51\92\52\50\34\44\91\56\55\93\61\34\92\49\48\54\92\49\48\48\92\51\56\92\54\52\92\57\52\92\57\52\92\54\52\92\53\54\92\53\49\92\53\55\92\53\49\92\54\56\92\49\48\52\92\49\48\52\92\49\48\48\92\54\52\92\52\50\92\51\53\92\52\48\92\51\51\34\44\91\56\56\93\61\34\92\49\49\53\92\53\54\92\49\48\48\92\53\53\92\53\49\92\52\50\92\52\48\92\51\53\92\49\48\48\92\49\48\48\92\52\56\92\52\48\92\49\48\48\92\52\56\92\52\49\92\49\48\48\92\51\56\92\51\56\92\57\52\34\44\91\56\57\93\61\34\92\53\55\92\49\48\48\92\57\55\92\57\55\92\49\48\52\92\52\50\92\54\52\92\57\52\92\49\48\48\92\57\56\92\49\49\53\92\49\48\53\92\49\49\53\92\49\48\48\92\53\55\92\49\48\48\92\53\55\92\53\49\92\49\48\52\92\49\49\53\92\49\48\48\34\44\91\57\48\93\61\34\92\55\50\92\56\51\92\49\48\54\92\55\50\92\56\51\92\55\52\92\49\48\53\92\49\49\53\92\49\49\55\92\49\49\48\92\49\49\57\92\49\48\51\92\49\49\53\92\49\48\48\92\49\50\49\92\52\50\92\52\50\92\51\53\92\57\52\34\44\91\57\49\93\61\34\92\49\48\48\92\49\48\54\92\49\49\53\92\49\48\55\92\49\48\52\92\49\48\48\92\49\49\53\92\53\54\92\54\52\92\57\52\92\54\52\92\53\54\92\49\49\55\92\49\49\53\92\49\49\48\92\49\49\53\92\49\48\54\92\49\48\52\92\49\48\48\92\49\49\53\92\49\48\55\34\44\91\57\50\93\61\34\92\49\48\52\92\49\49\53\92\49\48\54\92\49\49\53\92\53\48\92\53\48\92\55\52\92\56\51\92\55\53\92\49\48\54\92\49\48\48\92\51\56\92\57\52\92\55\50\92\56\51\92\49\48\48\92\49\48\54\92\49\48\55\92\49\49\53\34\44\91\57\51\93\61\34\92\49\49\53\92\49\48\52\92\49\49\53\92\53\54\92\54\52\92\51\56\92\54\52\92\52\48\92\52\50\92\49\48\54\92\49\48\48\92\49\48\55\92\49\49\53\92\49\48\52\92\49\49\53\92\49\48\55\92\49\49\53\92\49\48\56\92\49\48\50\92\49\48\50\92\49\48\52\92\49\48\54\34\44\91\57\52\93\61\34\92\52\50\92\54\52\92\57\52\92\55\49\92\49\49\53\92\53\53\92\53\52\92\53\49\92\53\52\92\49\49\53\92\49\48\51\92\49\49\53\92\49\48\54\92\53\53\92\54\52\92\57\52\92\54\52\92\57\52\92\52\50\34\44\91\57\53\93\61\34\92\49\49\53\92\49\48\56\92\49\49\53\92\53\55\92\53\48\92\53\54\92\56\49\92\51\56\92\54\52\92\53\52\92\49\49\53\92\49\48\55\92\49\48\55\92\49\49\53\92\49\48\52\92\54\52\92\54\52\92\53\55\92\51\51\34\44\91\57\54\93\61\34\92\52\56\92\53\48\92\49\49\53\92\55\52\92\55\50\92\49\49\53\92\53\54\92\53\49\92\53\53\92\54\52\92\52\50\92\54\52\92\51\56\92\49\48\52\92\49\49\53\92\49\49\53\92\49\48\51\92\49\48\53\92\49\49\57\34\44\91\57\55\93\61\34\92\49\48\50\92\53\55\92\53\49\92\53\54\92\49\49\53\92\49\48\52\92\49\49\53\92\53\54\92\53\49\92\51\56\92\51\53\92\54\54\92\49\48\48\92\49\48\55\92\49\48\53\92\49\49\53\92\49\49\49\92\49\48\54\34\44\91\57\56\93\61\34\92\53\53\92\49\49\53\92\49\49\53\92\49\48\48\92\49\48\54\92\49\49\53\92\49\48\48\92\49\48\53\92\49\48\52\92\49\49\53\92\53\54\92\53\49\92\53\48\92\53\48\92\57\52\92\54\52\92\51\55\92\51\54\92\54\52\92\55\50\34\44\91\57\57\93\61\34\92\53\55\92\53\48\92\53\48\92\51\56\92\51\56\92\54\52\92\51\53\92\57\52\92\54\52\92\55\50\92\56\51\92\55\52\92\56\51\92\55\49\92\54\53\92\56\54\92\55\52\92\49\49\53\92\49\48\55\92\49\49\53\34\44\91\49\48\48\93\61\34\92\53\53\92\49\49\53\92\49\49\49\92\49\49\53\92\49\49\50\92\49\49\53\92\49\48\53\92\49\49\53\92\49\48\54\92\53\49\92\53\49\92\53\53\92\53\53\92\53\49\92\53\54\92\52\48\92\51\53\92\51\56\34\44\91\49\48\49\93\61\34\92\53\53\92\49\49\53\92\49\48\51\92\49\49\53\92\49\48\53\92\49\49\53\92\49\48\48\92\49\48\52\92\49\49\53\92\49\49\55\92\49\49\53\92\49\49\54\92\57\56\92\49\49\57\92\49\49\57\92\49\49\53\92\49\48\48\92\49\48\50\92\49\49\53\92\49\48\55\34\44\91\49\48\50\93\61\34\92\53\53\92\49\49\53\92\49\48\51\92\57\55\92\49\48\50\92\53\53\92\52\57\92\49\49\53\92\49\49\53\92\49\48\50\92\49\48\51\92\49\48\48\92\49\48\48\92\49\48\48\92\57\55\92\49\48\51\92\49\48\55\34\44\91\49\48\51\93\61\34\92\53\48\92\53\55\92\54\56\92\55\52\92\56\51\92\49\48\50\92\49\49\57\92\51\56\92\54\52\92\52\50\92\51\56\92\57\52\92\51\54\92\52\56\92\52\56\92\53\54\92\53\50\92\53\50\34\44\91\49\48\52\93\61\34\92\53\48\92\53\54\92\53\48\92\53\52\92\53\48\92\49\49\53\92\49\48\54\92\57\55\92\57\55\92\53\52\92\53\48\92\53\51\92\53\48\92\49\50\50\92\49\50\48\92\53\48\34\44\91\49\48\53\93\61\34\92\57\56\92\49\50\48\92\49\48\51\92\53\48\92\53\48\92\53\53\92\53\48\92\53\52\92\49\49\53\92\57\56\92\57\55\92\49\48\51\92\53\50\92\53\48\92\53\54\92\55\49\92\56\51\34\44\91\49\48\54\93\61\34\92\53\53\92\49\49\53\92\49\48\51\92\57\55\92\49\48\50\92\53\53\92\52\57\92\53\48\92\53\52\92\53\51\92\52\57\92\53\51\92\53\48\92\57\55\92\57\55\92\49\48\51\92\49\48\55\34\44\91\49\48\55\93\61\34\92\53\53\92\53\48\92\49\48\52\92\49\49\53\92\49\48\54\92\57\55\92\49\48\51\92\54\54\92\49\49\53\92\49\48\52\92\53\48\92\53\49\92\55\50\92\49\49\53\92\53\48\92\49\48\55\34\44\91\49\48\56\93\61\34\92\55\52\92\49\49\57\92\49\49\49\92\49\49\53\92\49\48\52\92\49\49\53\92\54\52\92\51\53\92\51\56\92\54\52\92\51\53\92\52\50\92\53\53\92\53\50\92\55\53\92\53\48\92\53\54\92\53\48\92\53\55\34\44\91\49\48\57\93\61\34\92\49\48\53\92\49\48\54\92\49\49\53\92\49\49\57\92\53\54\92\53\48\92\53\53\92\51\51\92\54\52\92\54\52\92\51\53\92\54\54\92\54\56\92\56\51\92\49\48\52\92\52\48\92\54\52\92\52\50\92\51\54\92\49\49\55\92\53\48\34\44\91\49\49\48\93\61\34\92\49\49\53\92\49\49\53\92\49\48\54\92\49\49\53\92\54\52\92\51\53\92\52\50\92\51\54\92\52\48\92\51\55\92\52\50\92\52\48\92\51\56\92\54\52\92\57\52\92\57\52\92\55\50\92\49\48\48\92\49\49\53\92\49\48\54\92\49\49\53\92\52\50\34\44\91\49\49\49\93\61\34\92\51\56\92\54\52\92\53\54\92\49\48\48\92\49\49\53\92\53\54\92\53\53\92\53\48\92\55\50\92\49\49\53\92\49\48\54\92\52\48\92\53\49\92\52\48\92\54\52\92\52\50\92\49\49\52\92\49\49\53\92\49\48\54\34\44\91\49\49\50\93\61\34\92\55\50\92\56\51\92\55\52\92\49\48\48\92\49\49\53\92\53\55\92\53\54\92\53\49\92\54\56\92\56\55\92\49\48\57\92\57\57\92\51\56\92\54\52\92\54\52\92\57\52\92\51\54\92\52\49\92\56\54\92\54\56\92\54\56\34\44\91\49\49\51\93\61\34\92\49\48\48\92\49\48\54\92\49\49\57\92\53\53\92\53\48\92\53\52\92\57\52\92\54\52\92\51\55\92\54\52\92\51\54\92\49\49\53\92\49\48\52\92\49\49\53\92\49\48\52\92\52\50\92\52\50\92\51\53\92\49\48\48\92\49\48\48\92\49\48\48\34\44\91\49\49\52\93\61\34\92\49\49\53\92\49\48\54\92\49\49\53\92\53\55\92\53\48\92\53\53\92\53\49\92\53\53\92\53\48\92\53\55\92\53\49\92\53\53\92\57\56\92\49\49\53\92\49\48\54\92\49\49\53\92\53\52\92\57\52\92\54\52\92\51\53\92\51\54\34\44\91\49\49\53\93\61\34\92\53\48\92\53\48\92\53\49\92\51\56\92\54\52\92\57\52\92\56\51\92\54\54\92\57\55\92\49\48\54\92\49\49\53\92\53\55\92\49\49\53\92\53\55\92\49\48\54\92\49\48\48\92\49\48\52\92\49\49\53\92\54\52\92\51\53\92\51\54\34\44\91\49\49\54\93\61\34\92\54\56\92\49\48\54\92\49\49\53\92\51\56\92\54\52\92\51\56\92\51\53\92\52\48\92\53\48\92\49\48\54\92\49\48\48\92\49\48\48\92\51\56\92\53\48\92\49\49\51\92\49\48\52\92\49\48\48\92\53\55\92\54\52\92\52\50\34\44\91\49\49\55\93\61\34\92\55\52\92\56\51\92\49\49\48\92\49\49\53\92\57\55\92\49\48\55\92\49\49\53\92\49\48\52\92\52\50\92\54\52\92\51\56\92\51\53\92\51\56\92\53\49\92\49\50\49\92\53\48\92\53\49\92\53\55\92\53\54\92\53\49\34\44\91\49\49\56\93\61\34\92\54\52\92\51\56\92\51\53\92\54\56\92\55\50\92\56\51\92\49\48\54\92\49\49\53\92\49\48\52\92\53\53\92\53\48\92\49\49\53\92\49\48\52\92\49\49\53\92\51\56\92\54\52\92\52\48\92\51\53\92\54\56\92\55\52\34\44\91\49\49\57\93\61\34\92\49\49\53\92\52\48\92\54\52\92\52\50\92\54\57\92\51\56\92\54\56\92\49\48\54\92\49\49\48\92\49\48\48\92\49\48\55\92\49\49\53\92\49\48\54\92\49\49\53\92\53\55\92\53\48\92\53\54\92\49\48\48\92\57\52\92\51\53\92\51\55\34\44\91\49\50\48\93\61\34\92\53\53\92\53\48\92\53\55\92\53\48\92\49\48\52\92\49\49\53\92\49\49\53\92\52\50\92\54\52\92\51\56\92\54\52\92\52\50\92\55\50\92\54\56\92\52\48\92\51\53\92\49\48\48\92\49\48\48\34\44\91\49\50\49\93\61\34\92\49\48\48\92\49\48\54\92\49\49\53\92\54\52\92\57\52\92\52\50\92\53\49\92\53\52\92\53\48\92\53\54\92\53\49\92\52\56\92\49\48\48\92\54\52\92\52\50\92\51\53\92\51\53\92\53\49\92\51\53\92\51\56\34\44\91\49\50\50\93\61\34\92\57\57\92\57\57\92\49\48\48\92\51\56\92\54\52\92\51\56\92\52\48\92\52\50\92\57\52\92\49\48\48\92\49\48\48\92\49\48\54\92\49\48\52\92\52\50\92\51\53\92\51\53\92\53\50\92\53\49\92\53\48\92\49\49\57\92\53\52\92\49\48\48\34\44\91\49\50\51\93\61\34\92\55\50\92\49\49\53\92\53\54\92\53\48\92\53\52\92\57\52\92\54\52\92\51\55\92\55\50\92\56\51\92\54\54\92\52\50\92\53\49\92\53\53\92\49\49\53\92\49\48\52\92\49\49\53\92\49\48\55\92\49\49\53\92\49\48\48\92\49\48\55\34\44\91\49\50\52\93\61\34\92\49\48\54\92\49\49\53\92\49\48\55\92\49\48\52\92\49\49\53\92\52\50\92\54\52\92\51\56\92\54\52\92\57\52\92\54\52\92\51\55\92\51\53\92\52\50\92\54\52\92\49\49\53\92\49\48\52\92\49\48\48\92\49\49\53\92\49\48\51\92\52\50\34\44\91\49\50\53\93\61\34\92\49\48\54\92\49\48\48\92\51\56\92\54\52\92\57\52\92\57\52\92\54\52\92\53\54\92\53\49\92\53\55\92\53\49\92\54\56\92\49\48\52\92\49\48\52\92\49\48\48\92\54\52\92\52\50\92\51\53\92\52\48\92\51\51\34\44\91\49\50\54\93\61\34\92\49\49\53\92\53\54\92\49\48\48\92\53\53\92\53\49\92\52\50\92\52\48\92\51\53\92\49\48\48\92\49\48\48\92\52\56\92\52\48\92\49\48\48\92\52\56\92\52\49\92\49\48\48\92\51\56\92\51\56\92\57\52\34\44\91\49\50\55\93\61\34\92\53\55\92\49\48\48\92\57\55\92\57\55\92\49\48\52\92\52\50\92\54\52\92\57\52\92\49\48\48\92\57\56\92\49\49\53\92\49\48\53\92\49\49\53\92\49\48\48\92\53\55\92\49\48\48\92\53\55\92\53\49\92\49\48\52\92\49\49\53\92\49\48\48\34\44\91\49\50\56\93\61\34\92\55\50\92\56\51\92\49\48\54\92\55\50\92\56\51\92\55\52\92\49\48\53\92\49\49\53\92\49\49\55\92\49\49\48\92\49\49\57\92\49\48\51\92\49\49\53\92\49\48\48\92\49\50\49\92\52\50\92\52\50\92\51\53\92\57\52\34\44\91\49\50\57\93\61\34\92\49\48\48\92\49\48\54\92\49\49\53\92\49\48\55\92\49\48\52\92\49\48\48\92\49\49\53\92\53\54\92\54\52\92\57\52\92\54\52\92\53\54\92\49\49\55\92\49\49\53\92\49\49\48\92\49\49\53\92\49\48\54\92\49\48\52\92\49\48\48\92\49\49\53\92\49\48\55\34\44\91\49\51\48\93\61\34\92\49\48\52\92\49\49\53\92\49\48\54\92\49\49\53\92\53\48\92\53\48\92\55\52\92\56\51\92\55\53\92\49\48\54\92\49\48\48\92\51\56\92\57\52\92\55\50\92\56\51\92\49\48\48\92\49\48\54\92\49\48\55\92\49\49\53\34\44\91\49\51\49\93\61\34\92\49\49\53\92\49\48\52\92\49\49\53\92\53\54\92\54\52\92\51\56\92\54\52\92\52\48\92\52\50\92\49\48\54\92\49\48\48\92\49\48\55\92\49\49\53\92\49\48\52\92\49\49\53\92\49\48\55\92\49\49\53\92\49\48\56\92\49\48\50\92\49\48\50\92\49\48\52\92\49\48\54\34\44\91\49\51\50\93\61\34\92\52\50\92\54\52\92\57\52\92\55\49\92\49\49\53\92\53\53\92\53\52\92\53\49\92\53\52\92\49\49\53\92\49\48\51\92\49\49\53\92\49\48\54\92\53\53\92\54\52\92\57\52\92\54\52\92\57\52\92\52\50\34\44\91\49\51\51\93\61\34\92\49\49\53\92\49\48\56\92\49\49\53\92\53\55\92\53\48\92\53\54\92\56\49\92\51\56\92\54\52\92\53\52\92\49\49\53\92\49\48\55\92\49\48\55\92\49\49\53\92\49\48\52\92\54\52\92\54\52\92\53\55\92\51\51\34\44\91\49\51\52\93\61\34\92\52\56\92\53\48\92\49\49\53\92\55\52\92\55\50\92\49\49\53\92\53\54\92\53\49\92\53\53\92\54\52\92\52\50\92\54\52\92\51\56\92\49\48\52\92\49\49\53\92\49\49\53\92\49\48\51\92\49\48\53\92\49\49\57\34\44\91\49\51\53\93\61\34\92\49\48\50\92\53\55\92\53\49\92\53\54\92\49\49\53\92\49\48\52\92\49\49\53\92\53\54\92\53\49\92\51\56\92\51\53\92\54\54\92\49\48\48\92\49\48\55\92\49\48\53\92\49\49\53\92\49\49\49\92\49\48\54\34\44\91\49\51\54\93\61\34\92\53\53\92\49\49\53\92\49\49\53\92\49\48\48\92\49\48\54\92\49\49\53\92\49\48\48\92\49\48\53\92\49\48\52\92\49\49\53\92\53\54\92\53\49\92\53\48\92\53\48\92\57\52\92\54\52\92\51\55\92\51\54\92\54\52\92\55\50\34\44\91\49\51\55\93\61\34\92\53\55\92\53\48\92\53\48\92\51\56\92\51\56\92\54\52\92\51\53\92\57\52\92\54\52\92\55\50\92\56\51\92\55\52\92\56\51\92\55\49\92\54\53\92\56\54\92\55\52\92\49\49\53\92\49\48\55\92\49\49\53\34\44\91\49\51\56\93\61\34\92\53\53\92\49\49\53\92\49\49\49\92\49\49\53\92\49\49\50\92\49\49\53\92\49\48\53\92\49\49\53\92\49\48\54\92\53\49\92\53\49\92\53\53\92\53\53\92\53\49\92\53\54\92\52\48\92\51\53\92\51\56\34\44\91\49\51\57\93\61\34\92\53\53\92\49\49\53\92\49\48\51\92\49\49\53\92\49\48\53\92\49\49\53\92\49\48\48\92\49\48\52\92\49\49\53\92\49\49\55\92\49\49\53\92\49\49\54\92\57\56\92\49\49\57\92\49\49\57\92\49\49\53\92\49\48\48\92\49\48\50\92\49\49\53\92\49\48\55\34\44\91\49\52\48\93\61\34\92\53\53\92\49\49\53\92\49\48\51\92\57\55\92\49\48\50\92\53\53\92\52\57\92\49\49\53\92\49\49\53\92\49\48\50\92\49\48\51\92\49\48\48\92\49\48\48\92\49\48\48\92\57\55\92\49\48\51\92\49\48\55\34\44\91\49\52\49\93\61\34\92\53\48\92\53\55\92\54\56\92\55\52\92\56\51\92\57\57\92\49\49\56\92\53\55\92\53\49\92\53\50\92\53\53\92\49\48\48\92\49\48\57\92\49\48\48\92\53\55\92\53\50\92\49\48\57\92\49\49\56\34\44\91\49\52\50\93\61\34\92\53\48\92\53\54\92\53\48\92\53\52\92\53\48\92\49\49\53\92\49\48\54\92\57\55\92\57\55\92\53\52\92\53\48\92\53\51\92\53\48\92\49\50\50\92\49\50\48\92\53\48\34\44\91\49\52\51\93\61\34\92\57\56\92\49\50\48\92\49\48\51\92\53\48\92\53\48\92\53\53\92\53\48\92\53\52\92\49\49\53\92\57\56\92\57\55\92\49\48\51\92\53\50\92\53\48\92\53\54\92\55\49\92\56\51\34\44\91\49\52\52\93\61\34\92\53\53\92\49\49\53\92\49\48\51\92\57\55\92\49\48\50\92\53\53\92\52\57\92\53\48\92\53\52\92\53\51\92\52\57\92\53\51\92\53\48\92\57\55\92\57\55\92\49\48\51\92\49\48\55\34\44\91\49\52\53\93\61\34\92\53\53\92\53\48\92\49\48\52\92\49\49\53\92\49\48\54\92\57\55\92\49\48\51\92\54\54\92\49\49\53\92\49\48\52\92\53\48\92\53\49\92\55\50\92\49\49\53\92\53\48\92\49\48\55\34\44\91\49\52\54\93\61\48\44\91\49\52\55\93\61\34\34\44\91\49\52\56\93\61\34\92\54\56\92\49\48\49\92\49\49\56\92\49\48\49\92\49\48\56\92\49\49\49\92\49\49\50\92\49\48\49\92\49\49\52\92\51\50\92\54\57\92\49\49\52\92\49\49\52\92\49\49\49\92\49\49\52\92\51\50\92\52\53\92\51\50\92\55\48\92\49\49\49\92\49\49\52\92\49\48\51\92\49\49\49\92\49\49\54\92\51\50\92\49\49\54\92\49\49\49\92\51\50\92\49\48\53\92\49\49\48\92\57\57\92\49\48\56\92\49\49\55\92\49\48\48\92\49\48\49\92\51\50\92\49\49\50\92\49\49\52\92\49\49\49\92\49\48\48\92\49\49\55\92\57\57\92\49\49\54\92\51\50\92\49\48\53\92\49\48\48\92\52\52\92\51\50\92\57\57\92\49\49\49\92\49\49\48\92\49\49\54\92\57\55\92\57\57\92\49\49\54\92\51\50\92\49\48\48\92\49\48\49\92\49\49\56\92\49\48\49\92\49\48\56\92\49\49\49\92\49\49\50\92\49\48\49\92\49\49\52\92\52\54\34\44\91\49\52\57\93\61\34\92\54\56\92\49\48\49\92\49\49\56\92\49\48\49\92\49\48\56\92\49\49\49\92\49\49\50\92\49\48\49\92\49\49\52\92\51\50\92\54\57\92\49\49\52\92\49\49\52\92\49\49\49\92\49\49\52\92\51\50\92\52\53\92\51\50\92\55\48\92\49\49\49\92\49\49\52\92\49\48\51\92\49\49\49\92\49\49\54\92\51\50\92\49\49\54\92\49\49\49\92\51\50\92\49\48\53\92\49\49\48\92\57\57\92\49\48\56\92\49\49\55\92\49\48\48\92\49\48\49\92\51\50\92\49\48\50\92\49\48\53\92\49\48\56\92\49\48\49\92\49\49\48\92\57\55\92\49\48\57\92\49\48\49\92\52\52\92\51\50\92\57\57\92\49\49\49\92\49\49\48\92\49\49\54\92\57\55\92\57\57\92\49\49\54\92\51\50\92\49\48\48\92\49\48\49\92\49\49\56\92\49\48\49\92\49\48\56\92\49\49\49\92\49\49\50\92\49\48\49\92\49\49\52\92\52\54\34\44\91\49\53\48\93\61\34\92\54\55\92\49\48\56\92\49\49\49\92\49\49\55\92\49\48\48\92\51\50\92\56\51\92\49\49\54\92\57\55\92\49\49\54\92\49\49\55\92\49\49\53\34\44\91\49\53\49\93\61\34\92\54\53\92\57\57\92\49\49\54\92\49\48\53\92\49\49\56\92\57\55\92\49\49\54\92\49\48\53\92\49\49\49\92\49\49\48\92\51\50\92\56\51\92\49\49\54\92\57\55\92\49\49\54\92\49\49\55\92\49\49\53\34\44\91\49\53\50\93\61\34\92\54\53\92\57\57\92\49\49\54\92\49\48\53\92\49\49\56\92\57\55\92\49\49\54\92\49\48\53\92\49\49\49\92\49\49\48\92\51\50\92\56\51\92\49\49\54\92\57\55\92\49\49\54\92\49\49\55\92\49\49\53\34\44\91\49\53\51\93\61\34\92\54\57\92\49\49\52\92\49\49\52\92\49\49\49\92\49\49\52\92\52\52\92\51\50\92\56\50\92\49\48\49\92\49\49\50\92\49\48\56\92\57\55\92\57\57\92\49\48\49\92\51\50\92\54\53\92\57\57\92\49\49\54\92\49\48\53\92\49\49\56\92\57\55\92\49\49\54\92\49\48\53\92\49\49\49\92\49\49\48\92\51\50\92\56\51\92\49\49\54\92\57\55\92\49\49\54\92\49\49\55\92\49\49\53\92\51\50\92\49\49\57\92\49\48\53\92\49\49\54\92\49\48\52\92\51\50\92\54\55\92\49\48\56\92\49\49\49\92\49\49\55\92\49\48\48\92\51\50\92\56\51\92\49\49\54\92\57\55\92\49\49\54\92\49\49\55\92\49\49\53\34\44\91\49\53\52\93\61\34\92\54\56\92\49\49\52\92\49\48\53\92\49\49\56\92\49\48\49\92\49\49\52\92\51\50\92\56\51\92\49\49\54\92\57\55\92\49\49\54\92\49\49\55\92\49\49\53\34\44\91\49\53\53\93\61\34\92\54\56\92\49\49\52\92\49\48\53\92\49\49\56\92\49\48\49\92\49\49\52\92\51\50\92\56\51\92\49\49\54\92\57\55\92\49\49\54\92\49\49\55\92\49\49\53\34\44\91\49\53\54\93\61\34\92\55\55\92\49\49\55\92\49\49\53\92\49\49\54\92\51\50\92\57\55\92\49\48\48\92\49\48\48\92\51\50\92\52\48\92\54\55\92\49\48\56\92\49\49\49\92\49\49\55\92\49\48\48\92\51\50\92\56\51\92\49\49\54\92\57\55\92\49\49\54\92\49\49\55\92\49\49\53\92\52\49\92\51\50\92\49\49\50\92\49\49\52\92\49\49\49\92\49\49\50\92\49\48\49\92\49\49\52\92\49\49\54\92\49\50\49\92\51\50\92\49\48\50\92\49\48\53\92\49\48\49\92\49\48\56\92\49\48\48\92\51\50\92\49\48\50\92\49\49\49\92\49\49\52\92\51\50\92\49\48\48\92\49\49\52\92\49\48\53\92\49\49\56\92\49\48\49\92\49\49\52\34\44\91\49\53\55\93\61\34\92\54\56\92\49\48\49\92\49\49\56\92\49\48\49\92\49\48\56\92\49\49\49\92\49\49\50\92\49\48\49\92\49\49\52\92\51\50\92\54\57\92\49\49\52\92\49\49\52\92\49\49\49\92\49\49\52\92\51\50\92\52\53\92\51\50\92\55\55\92\49\49\55\92\49\49\53\92\49\49\54\92\51\50\92\57\55\92\49\48\48\92\49\48\48\92\51\50\92\52\48\92\54\55\92\49\48\56\92\49\49\49\92\49\49\55\92\49\48\48\92\51\50\92\56\51\92\49\49\54\92\57\55\92\49\49\54\92\49\49\55\92\49\49\53\92\52\49\92\51\50\92\49\49\50\92\49\49\52\92\49\49\49\92\49\49\50\92\49\48\49\92\49\49\52\92\49\49\54\92\49\50\49\92\51\50\92\49\48\50\92\49\48\53\92\49\48\49\92\49\48\56\92\49\48\48\92\51\50\92\49\48\50\92\49\49\49\92\49\49\52\92\51\50\92\49\48\48\92\49\49\52\92\49\48\53\92\49\49\56\92\49\48\49\92\49\49\52\92\52\52\92\51\50\92\57\57\92\49\49\49\92\49\49\48\92\49\49\54\92\57\55\92\57\57\92\49\49\54\92\51\50\92\49\48\48\92\49\48\49\92\49\49\56\92\49\48\49\92\49\48\56\92\49\49\49\92\49\49\50\92\49\48\49\92\49\49\52\92\52\54\34\44\91\49\53\56\93\61\34\92\54\53\92\49\49\55\92\49\49\54\92\49\49\49\92\49\48\57\92\57\55\92\49\49\54\92\49\48\53\92\57\57\92\51\50\92\56\53\92\49\49\50\92\49\48\48\92\57\55\92\49\49\54\92\49\48\49\92\49\49\53\34\44\91\49\53\57\93\61\34\92\54\56\92\49\48\49\92\49\49\56\92\49\48\49\92\49\48\56\92\49\49\49\92\49\49\50\92\49\48\49\92\49\49\52\92\51\50\92\54\57\92\49\49\52\92\49\49\52\92\49\49\49\92\49\49\52\92\51\50\92\52\53\92\51\50\92\54\53\92\49\49\55\92\49\49\54\92\49\49\49\92\51\50\92\56\53\92\49\49\50\92\49\48\48\92\57\55\92\49\49\54\92\49\48\49\92\51\50\92\49\49\50\92\49\49\52\92\49\49\49\92\49\49\50\92\49\48\49\92\49\49\52\92\49\49\54\92\49\48\53\92\49\48\49\92\49\49\53\92\51\50\92\49\48\50\92\49\48\53\92\49\48\49\92\49\48\56\92\49\48\48\92\51\50\92\49\48\57\92\49\48\53\92\49\49\53\92\49\49\53\92\49\48\53\92\49\49\48\92\49\48\51\92\51\50\92\49\49\49\92\49\49\52\92\51\50\92\49\49\53\92\49\49\50\92\49\48\49\92\49\48\56\92\49\48\56\92\49\48\49\92\49\48\48\92\51\50\92\49\48\53\92\49\49\48\92\57\57\92\49\49\49\92\49\49\52\92\49\49\52\92\49\48\49\92\57\57\92\49\49\54\92\49\48\56\92\49\50\49\92\52\52\92\51\50\92\57\57\92\49\49\49\92\49\49\48\92\49\49\54\92\57\55\92\57\57\92\49\49\54\92\51\50\92\49\48\48\92\49\48\49\92\49\49\56\92\49\48\49\92\49\48\56\92\49\49\49\92\49\49\50\92\49\48\49\92\49\49\52\92\52\54\34\44\91\49\54\48\93\61\34\92\54\57\92\49\49\52\92\49\49\52\92\49\49\49\92\49\49\52\92\51\50\92\52\53\92\51\50\92\54\56\92\49\49\52\92\49\48\53\92\49\49\56\92\49\48\49\92\49\49\52\92\51\50\92\49\48\50\92\49\48\53\92\49\48\56\92\49\48\49\92\49\49\48\92\57\55\92\49\48\57\92\49\48\49\92\51\50\92\49\49\57\92\57\55\92\49\49\53\92\51\50\92\57\57\92\49\48\52\92\57\55\92\49\49\48\92\49\48\51\92\49\48\49\92\49\48\48\92\52\52\92\51\50\92\49\49\50\92\49\48\56\92\49\48\49\92\57\55\92\49\49\53\92\49\48\49\92\51\50\92\49\49\52\92\49\48\49\92\49\48\53\92\49\49\48\92\49\49\53\92\49\49\54\92\57\55\92\49\48\56\92\49\48\56\92\51\50\92\49\48\48\92\49\49\52\92\49\48\53\92\49\49\56\92\49\48\49\92\49\49\52\92\51\50\92\49\49\57\92\49\48\53\92\49\49\54\92\49\48\52\92\51\50\92\49\49\49\92\49\49\52\92\49\48\53\92\49\48\51\92\49\48\53\92\49\49\48\92\57\55\92\49\48\56\92\51\50\92\49\48\50\92\49\48\53\92\49\48\56\92\49\48\49\92\49\49\48\92\57\55\92\49\48\57\92\49\48\49\92\53\56\92\51\50\34\44\91\49\54\49\93\61\34\92\55\56\92\49\49\49\92\49\49\54\92\51\50\92\54\56\92\49\48\49\92\49\48\50\92\49\48\53\92\49\49\48\92\49\48\49\92\49\48\48\34\44\91\49\54\50\93\61\51\48\48\48\44\91\49\54\51\93\61\34\92\56\50\92\54\57\92\55\55\92\55\57\92\56\54\92\54\57\92\57\53\92\54\56\92\56\50\92\55\51\92\56\54\92\54\57\92\56\50\34\44\91\49\54\52\93\61\34\92\54\53\92\49\49\55\92\49\49\54\92\49\49\49\92\49\48\57\92\57\55\92\49\49\54\92\49\48\53\92\57\57\92\51\50\92\56\53\92\49\49\50\92\49\48\48\92\57\55\92\49\49\54\92\49\48\49\92\49\49\53\34\44\91\49\54\53\93\61\34\92\54\53\92\49\49\55\92\49\49\54\92\49\49\49\92\49\48\57\92\57\55\92\49\49\54\92\49\48\53\92\57\57\92\51\50\92\56\53\92\49\49\50\92\49\48\48\92\57\55\92\49\49\54\92\49\48\49\92\49\49\53\34\44\91\49\54\54\93\61\34\92\55\57\92\49\48\50\92\49\48\50\34\44\91\49\54\55\93\61\34\92\54\53\92\49\49\55\92\49\49\54\92\49\49\49\92\49\48\57\92\57\55\92\49\49\54\92\49\48\53\92\57\57\92\51\50\92\56\53\92\49\49\50\92\49\48\48\92\57\55\92\49\49\54\92\49\48\49\92\49\49\53\34\44\91\49\54\56\93\61\34\92\55\57\92\49\49\48\34\44\91\49\54\57\93\61\34\92\54\55\92\56\57\92\56\48\92\55\50\92\54\57\92\56\50\34\44\91\49\55\48\93\61\34\92\54\53\92\54\57\92\56\51\92\52\53\92\53\48\92\53\51\92\53\52\92\52\53\92\54\55\92\54\54\92\54\55\34\44\91\49\55\49\93\61\34\92\49\48\48\92\57\55\92\49\49\54\92\57\55\92\57\53\92\49\48\49\92\49\49\48\92\57\57\92\49\49\49\92\49\48\48\92\49\48\53\92\49\49\48\92\49\48\51\34\44\91\49\55\50\93\61\34\92\54\54\92\54\53\92\56\51\92\54\57\92\53\52\92\53\50\34\44\91\49\55\51\93\61\52\44\91\49\55\52\93\61\34\92\54\55\92\55\50\92\54\57\92\54\55\92\55\53\92\55\51\92\55\56\34\44\91\49\55\53\93\61\34\92\54\53\92\54\55\92\56\52\92\55\51\92\56\54\92\54\53\92\56\52\92\54\57\34\44\91\49\55\54\93\61\34\92\54\56\92\54\57\92\54\53\92\54\55\92\56\52\92\55\51\92\56\54\92\54\53\92\56\52\92\54\57\34\44\91\49\55\55\93\61\34\92\56\53\92\56\48\92\54\56\92\54\53\92\56\52\92\54\57\92\55\57\92\55\56\34\44\91\49\55\56\93\61\34\92\54\53\92\49\49\55\92\49\49\54\92\49\49\49\92\49\48\57\92\57\55\92\49\49\54\92\49\48\53\92\57\57\92\51\50\92\56\53\92\49\49\50\92\49\48\48\92\57\55\92\49\49\54\92\49\48\49\92\49\49\53\34\44\91\49\55\57\93\61\34\92\54\53\92\49\49\55\92\49\49\54\92\49\49\49\92\49\48\57\92\57\55\92\49\49\54\92\49\48\53\92\57\57\92\51\50\92\56\53\92\49\49\50\92\49\48\48\92\57\55\92\49\49\54\92\49\48\49\92\49\49\53\34\44\91\49\56\48\93\61\34\92\54\53\92\49\49\55\92\49\49\54\92\49\49\49\92\49\48\57\92\57\55\92\49\49\54\92\49\48\53\92\57\57\92\51\50\92\56\53\92\49\49\50\92\49\48\48\92\57\55\92\49\49\54\92\49\48\49\92\49\49\53\34\44\91\49\56\49\93\61\34\92\56\53\92\56\48\92\54\56\92\54\53\92\56\52\92\54\57\92\55\57\92\55\48\92\55\48\34\44\91\49\56\50\93\61\34\92\54\53\92\49\49\55\92\49\49\54\92\49\49\49\92\49\48\57\92\57\55\92\49\49\54\92\49\48\53\92\57\57\92\51\50\92\56\53\92\49\49\50\92\49\48\48\92\57\55\92\49\49\54\92\49\48\49\92\49\49\53\34\44\91\49\56\51\93\61\34\92\54\53\92\49\49\55\92\49\49\54\92\49\49\49\92\49\48\57\92\57\55\92\49\49\54\92\49\48\53\92\57\57\92\51\50\92\56\53\92\49\49\50\92\49\48\48\92\57\55\92\49\49\54\92\49\48\49\92\49\49\53\34\44\91\49\56\52\93\61\34\92\54\53\92\49\49\55\92\49\49\54\92\49\49\49\92\49\48\57\92\57\55\92\49\49\54\92\49\48\53\92\57\57\92\51\50\92\56\53\92\49\49\50\92\49\48\48\92\57\55\92\49\49\54\92\49\48\49\92\49\49\53\34\44\91\49\56\53\93\61\34\92\56\48\92\55\57\92\55\54\92\55\54\92\55\51\92\55\56\92\55\49\34\44\91\49\56\54\93\61\34\92\54\57\92\49\49\52\92\49\49\52\92\49\49\49\92\49\49\52\34\44\91\49\56\55\93\61\34\92\54\55\92\49\48\56\92\49\49\48\92\49\49\54\92\53\56\92\55\51\92\49\49\48\92\49\49\56\92\57\55\92\49\48\56\92\49\48\53\92\49\48\48\92\51\50\92\54\55\92\49\49\49\92\49\48\57\92\49\48\57\92\57\55\92\49\49\48\92\49\48\48\92\53\56\92\51\50\34\44\91\49\56\56\93\61\34\92\55\56\92\49\49\49\92\51\50\92\54\55\92\49\49\49\92\49\48\57\92\49\48\57\92\57\55\92\49\49\48\92\49\48\48\92\51\50\92\55\48\92\49\49\49\92\49\49\55\92\49\49\48\92\49\48\48\34\44\91\49\56\57\93\61\34\92\55\50\92\57\55\92\57\57\92\49\48\55\34\44\91\49\57\48\93\61\34\92\54\55\92\49\48\56\92\49\49\48\92\49\49\54\92\53\56\92\56\52\92\54\55\92\51\50\92\55\50\92\57\55\92\49\49\53\92\49\48\52\92\51\50\92\55\48\92\57\55\92\49\48\53\92\49\48\56\34\44\91\49\57\49\93\61\34\92\55\50\92\57\55\92\57\57\92\49\48\55\34\44\91\49\57\50\93\61\34\92\54\55\92\49\48\56\92\49\49\48\92\49\49\54\92\53\56\92\56\48\92\54\55\92\54\53\92\55\54\92\55\54\92\51\50\92\52\53\92\51\50\92\55\51\92\49\49\48\92\49\49\56\92\57\55\92\49\48\56\92\49\48\53\92\49\48\48\92\51\50\92\54\56\92\49\48\49\92\57\57\92\49\49\52\92\49\50\49\92\49\49\50\92\49\49\54\34\44\91\49\57\51\93\61\34\92\56\54\92\57\55\92\49\48\56\92\49\48\53\92\49\48\48\92\57\55\92\49\49\54\92\49\48\49\92\54\55\92\53\50\92\49\48\53\92\55\56\92\57\55\92\49\48\57\92\49\48\49\92\51\50\92\54\57\92\49\49\52\92\49\49\52\92\53\56\92\51\50\92\55\48\92\49\48\53\92\49\48\56\92\49\48\49\92\49\49\48\92\57\55\92\49\48\57\92\49\48\49\92\51\50\92\49\48\57\92\49\48\53\92\49\49\53\92\49\49\53\92\49\48\53\92\49\49\48\92\49\48\51\92\52\54\92\52\54\92\52\54\34\44\91\49\57\52\93\61\49\44\91\49\57\53\93\61\34\92\57\55\92\57\57\92\49\49\54\92\49\48\53\92\49\49\56\92\57\55\92\49\49\54\92\49\48\49\92\49\48\48\34\44\91\49\57\54\93\61\34\92\49\49\54\92\49\49\52\92\49\48\53\92\57\55\92\49\48\56\92\57\53\92\57\55\92\57\57\92\49\49\54\92\49\48\53\92\49\49\56\92\57\55\92\49\49\54\92\49\48\49\92\49\48\48\34\44\91\49\57\55\93\61\34\92\57\55\92\57\57\92\49\49\54\92\49\48\53\92\49\49\56\92\57\55\92\49\49\54\92\49\48\49\92\49\48\48\34\44\91\49\57\56\93\61\34\92\49\49\54\92\49\49\52\92\49\48\53\92\57\55\92\49\48\56\92\57\53\92\49\48\49\92\49\50\48\92\49\49\50\92\49\48\53\92\49\49\52\92\49\48\49\92\49\48\48\34\44\91\49\57\57\93\61\34\92\49\48\48\92\49\48\49\92\57\55\92\57\57\92\49\49\54\92\49\48\53\92\49\49\56\92\57\55\92\49\49\54\92\49\48\49\92\49\48\48\34\44\91\50\48\48\93\61\34\92\54\55\92\49\48\56\92\49\49\49\92\49\49\55\92\49\48\48\92\51\50\92\56\51\92\49\49\54\92\57\55\92\49\49\54\92\49\49\55\92\49\49\53\34\44\91\50\48\49\93\61\34\92\54\55\92\49\48\56\92\49\49\49\92\49\49\55\92\49\48\48\92\51\50\92\56\51\92\49\49\54\92\57\55\92\49\49\54\92\49\49\55\92\49\49\53\34\44\91\50\48\50\93\61\34\92\49\48\48\92\49\49\52\92\49\48\53\92\49\49\56\92\49\48\49\92\49\49\52\92\54\55\92\49\48\49\92\49\49\48\92\49\49\54\92\49\49\52\92\57\55\92\49\48\56\92\52\53\92\54\55\92\49\48\56\92\49\49\49\92\49\49\55\92\49\48\48\92\52\54\92\57\57\92\53\50\92\49\50\50\34\44\91\50\48\51\93\61\34\92\54\53\92\49\49\55\92\49\49\54\92\49\49\49\92\49\48\57\92\57\55\92\49\49\54\92\49\48\53\92\57\57\92\51\50\92\56\53\92\49\49\50\92\49\48\48\92\57\55\92\49\49\54\92\49\48\49\92\49\49\53\34\44\91\50\48\52\93\61\34\92\54\55\92\49\48\56\92\49\49\49\92\49\49\55\92\49\48\48\92\51\50\92\49\48\48\92\49\49\52\92\49\48\53\92\49\49\56\92\49\48\49\92\49\49\52\92\51\50\92\49\48\50\92\49\49\49\92\49\49\55\92\49\49\48\92\49\48\48\92\52\54\92\51\50\92\56\50\92\49\48\49\92\49\48\51\92\49\48\53\92\49\49\53\92\49\49\54\92\49\48\49\92\49\49\52\92\49\48\53\92\49\49\48\92\49\48\51\92\51\50\92\49\48\48\92\49\49\52\92\49\48\53\92\49\49\56\92\49\48\49\92\49\49\52\92\52\54\92\52\54\92\52\54\34\44\91\50\48\53\93\61\34\92\55\51\92\49\49\48\92\49\49\53\92\49\49\54\92\57\55\92\49\48\56\92\49\48\56\92\51\50\92\49\48\48\92\49\49\52\92\49\48\53\92\49\49\56\92\49\48\49\92\49\49\52\92\57\57\92\49\48\49\92\49\49\48\92\49\49\54\92\49\49\52\92\57\55\92\49\48\56\92\52\54\92\49\48\53\92\49\49\49\92\51\50\92\57\57\92\49\48\56\92\49\49\49\92\49\49\55\92\49\48\48\92\51\50\92\49\48\48\92\49\49\52\92\49\48\53\92\49\49\56\92\49\48\49\92\49\49\52\92\51\50\92\49\48\50\92\49\49\49\92\49\49\52\92\51\50\92\57\55\92\49\49\55\92\49\49\54\92\49\49\49\92\51\50\92\49\49\55\92\49\49\50\92\49\48\48\92\57\55\92\49\49\54\92\49\48\49\92\49\49\53\92\52\54\34\44\91\50\48\54\93\61\34\92\55\56\92\49\49\49\92\51\50\92\57\57\92\49\48\56\92\49\49\49\92\49\49\55\92\49\48\48\92\51\50\92\49\48\48\92\49\49\52\92\49\48\53\92\49\49\56\92\49\48\49\92\49\49\52\92\51\50\92\49\48\48\92\49\48\49\92\49\49\54\92\49\48\49\92\57\57\92\49\49\54\92\49\48\49\92\49\48\48\92\52\54\92\51\50\92\55\51\92\49\49\48\92\49\49\53\92\49\49\54\92\57\55\92\49\48\56\92\49\48\56\92\51\50\92\49\48\48\92\49\49\52\92\49\48\53\92\49\49\56\92\49\48\49\92\49\49\52\92\57\57\92\49\48\49\92\49\49\48\92\49\49\54\92\49\49\52\92\57\55\92\49\48\56\92\52\54\92\49\48\53\92\49\49\49\92\51\50\92\57\57\92\49\48\56\92\49\49\49\92\49\49\55\92\49\48\48\92\51\50\92\49\48\48\92\49\49\52\92\49\48\53\92\49\49\56\92\49\48\49\92\49\49\52\92\52\54\92\52\54\92\52\54\34\44\91\50\48\55\93\61\34\92\54\53\92\49\49\55\92\49\49\54\92\49\49\49\92\49\48\57\92\57\55\92\49\49\54\92\49\48\53\92\57\57\92\51\50\92\56\53\92\49\49\50\92\49\48\48\92\57\55\92\49\49\54\92\49\48\49\92\49\49\53\34\44\91\50\48\56\93\61\34\92\55\55\92\49\49\49\92\49\49\52\92\49\48\49\92\51\50\92\49\49\54\92\49\48\52\92\57\55\92\49\49\48\92\51\50\92\49\49\49\92\49\49\48\92\49\48\49\92\51\50\92\57\57\92\49\48\56\92\49\49\49\92\49\49\55\92\49\48\48\92\51\50\92\49\48\48\92\49\49\52\92\49\48\53\92\49\49\56\92\49\48\49\92\49\49\52\92\51\50\92\49\48\48\92\49\48\49\92\49\49\54\92\49\48\49\92\57\57\92\49\49\54\92\49\48\49\92\49\48\48\92\52\54\92\51\50\92\56\48\92\49\48\56\92\49\48\49\92\57\55\92\49\49\53\92\49\48\49\92\51\50\92\49\49\52\92\49\48\49\92\49\48\57\92\49\49\49\92\49\49\56\92\49\48\49\92\51\50\92\49\48\49\92\49\50\48\92\49\49\54\92\49\49\52\92\57\55\92\51\50\92\57\57\92\49\48\56\92\49\49\49\92\49\49\55\92\49\48\48\92\51\50\92\49\48\48\92\49\49\52\92\49\48\53\92\49\49\56\92\49\48\49\92\49\49\52\92\52\54\92\52\54\92\52\54\34\44\91\50\48\57\93\61\34\92\54\53\92\49\49\55\92\49\49\54\92\49\49\49\92\49\48\57\92\57\55\92\49\49\54\92\49\48\53\92\57\57\92\51\50\92\56\53\92\49\49\50\92\49\48\48\92\57\55\92\49\49\54\92\49\48\49\92\49\49\53\34\44\91\50\49\48\93\61\34\92\49\49\56\92\49\48\49\92\49\49\52\92\49\49\53\92\49\48\53\92\49\49\49\92\49\49\48\34\44\91\50\49\49\93\61\34\92\54\53\92\49\49\55\92\49\49\54\92\49\49\49\92\49\48\57\92\57\55\92\49\49\54\92\49\48\53\92\57\57\92\51\50\92\56\53\92\49\49\50\92\49\48\48\92\57\55\92\49\49\54\92\49\48\49\92\49\49\53\34\44\91\50\49\50\93\61\34\92\54\53\92\49\49\55\92\49\49\54\92\49\49\49\92\49\48\57\92\57\55\92\49\49\54\92\49\48\53\92\57\57\92\51\50\92\56\53\92\49\49\50\92\49\48\48\92\57\55\92\49\49\54\92\49\48\49\92\49\49\53\34\44\91\50\49\51\93\61\34\92\55\57\92\49\49\48\34\44\91\50\49\52\93\61\34\92\55\57\92\49\49\48\34\44\91\50\49\53\93\61\34\92\54\53\92\49\49\55\92\49\49\54\92\49\49\49\92\49\48\57\92\57\55\92\49\49\54\92\49\48\53\92\57\57\92\51\50\92\56\53\92\49\49\50\92\49\48\48\92\57\55\92\49\49\54\92\49\48\49\92\49\49\53\34\44\91\50\49\54\93\61\34\92\55\57\92\49\48\50\92\49\48\50\34\44\91\50\49\55\93\61\34\92\55\57\92\49\48\50\92\49\48\50\34\44\91\50\49\56\93\61\34\92\55\57\92\49\48\50\92\49\48\50\34\44\91\50\49\57\93\61\34\92\55\57\92\49\48\50\92\49\48\50\34\44\91\50\50\48\93\61\34\92\54\55\92\55\50\92\54\57\92\54\55\92\55\53\92\55\51\92\55\56\34\44\91\50\50\49\93\61\34\92\54\53\92\54\57\92\56\51\92\52\53\92\53\48\92\53\51\92\53\52\92\52\53\92\54\55\92\54\54\92\54\55\34\44\91\50\50\50\93\61\34\92\49\49\52\92\49\48\49\92\49\49\54\92\49\49\55\92\49\49\52\92\49\49\48\92\57\53\92\49\48\49\92\49\49\48\92\57\57\92\49\49\49\92\49\48\48\92\49\48\53\92\49\49\48\92\49\48\51\34\44\91\50\50\51\93\61\34\92\54\54\92\54\53\92\56\51\92\54\57\92\53\52\92\53\50\34\44\91\50\50\52\93\61\34\92\54\55\92\56\57\92\56\48\92\55\50\92\54\57\92\56\50\34\44\91\50\50\53\93\61\34\92\57\49\92\51\55\92\51\51\92\51\55\92\54\52\92\51\55\92\51\53\92\51\55\92\51\54\92\51\55\92\51\55\92\51\55\92\57\52\92\51\55\92\51\56\92\51\55\92\52\50\92\51\55\92\52\48\92\51\55\92\52\49\92\51\55\92\52\53\92\51\55\92\52\51\92\57\51\34\44\91\50\50\54\93\61\50\49\44\91\50\50\55\93\61\34\92\55\56\92\49\49\49\92\51\50\92\55\56\92\57\55\92\49\48\57\92\49\48\49\34\44\91\50\50\56\93\61\34\92\53\54\92\53\50\92\56\54\92\49\49\56\92\54\56\92\56\55\92\49\49\53\92\56\56\92\56\52\92\57\56\92\55\52\92\54\54\92\55\56\92\55\50\92\55\56\92\53\50\92\54\55\92\53\51\92\49\50\48\92\53\49\92\49\48\51\92\56\57\92\56\57\92\55\52\34\44\91\50\50\57\93\61\34\92\56\51\92\55\50\92\54\53\92\52\57\34\44\91\50\51\48\93\61\34\92\49\48\52\92\54\49\92\51\55\92\49\49\53\92\51\56\92\49\48\57\92\54\49\92\51\55\92\49\49\53\92\51\56\92\49\49\50\92\54\49\92\51\55\92\49\49\53\92\51\56\92\49\48\57\92\49\49\53\92\49\48\51\92\54\49\92\51\55\92\49\49\53\92\51\56\92\49\49\50\92\49\49\48\92\54\49\92\51\55\92\49\49\53\92\51\56\92\49\49\50\92\49\49\52\92\54\49\92\51\55\92\49\49\53\92\51\56\92\49\48\57\92\49\49\54\92\54\49\92\51\55\92\49\49\53\34\44\91\50\51\49\93\61\34\92\49\48\52\92\49\49\54\92\49\49\54\92\49\49\50\92\49\49\53\92\53\56\92\52\55\92\52\55\92\49\49\57\92\49\49\57\92\49\49\57\92\52\54\92\49\48\48\92\49\49\52\92\49\48\53\92\49\49\56\92\49\48\49\92\49\49\52\92\57\57\92\49\48\49\92\49\49\48\92\49\49\54\92\49\49\52\92\57\55\92\49\48\56\92\52\54\92\49\48\53\92\49\49\49\92\52\55\92\49\48\56\92\49\48\53\92\57\57\92\49\48\49\92\49\49\48\92\49\49\53\92\49\48\49\92\49\49\53\92\49\48\49\92\49\49\52\92\49\49\56\92\49\48\49\92\49\49\52\92\52\55\92\49\49\53\92\49\49\55\92\49\49\50\92\49\49\50\92\49\49\49\92\49\49\52\92\49\49\54\92\52\54\92\49\49\50\92\49\48\52\92\49\49\50\34\44\91\50\51\50\93\61\34\92\51\55\92\57\55\92\51\55\92\57\55\92\51\55\92\49\48\48\92\51\55\92\49\48\48\34\44\91\50\51\51\93\61\34\92\52\55\92\49\49\53\92\57\56\92\49\48\53\92\49\49\48\92\52\55\92\49\48\53\92\49\48\50\92\57\57\92\49\49\49\92\49\49\48\92\49\48\50\92\49\48\53\92\49\48\51\92\51\50\92\49\48\49\92\49\49\54\92\49\48\52\92\52\56\92\51\50\92\49\50\52\92\52\55\92\57\56\92\49\48\53\92\49\49\48\92\52\55\92\49\48\51\92\49\49\52\92\49\48\49\92\49\49\50\92\51\50\92\49\48\49\92\49\49\54\92\49\48\52\92\52\56\92\51\50\92\49\50\52\92\51\50\92\52\55\92\49\49\55\92\49\49\53\92\49\49\52\92\52\55\92\57\56\92\49\48\53\92\49\49\48\92\52\55\92\57\55\92\49\49\57\92\49\48\55\92\51\50\92\52\53\92\55\48\92\51\57\92\51\50\92\51\57\92\51\50\92\51\57\92\49\50\51\92\49\49\50\92\49\49\52\92\49\48\53\92\49\49\48\92\49\49\54\92\51\50\92\51\54\92\53\51\92\49\50\53\92\51\57\92\51\50\92\49\50\52\92\51\50\92\52\55\92\57\56\92\49\48\53\92\49\49\48\92\52\55\92\49\49\53\92\49\48\49\92\49\48\48\92\51\50\92\52\53\92\49\48\49\92\51\50\92\51\57\92\49\49\53\92\52\55\92\53\56\92\52\55\92\52\55\92\49\48\51\92\51\57\34\44\91\50\51\52\93\61\34\92\49\49\52\34\44\91\50\51\53\93\61\34\92\52\50\92\57\55\92\49\48\56\92\49\48\56\34\44\91\50\51\54\93\61\50\44\91\50\51\55\93\61\34\92\56\56\92\55\48\92\56\53\92\53\51\92\55\53\92\53\50\92\53\53\92\52\56\92\56\50\92\51\50\92\52\57\92\53\51\92\51\50\92\53\50\92\56\55\92\53\49\92\53\51\92\52\56\92\55\55\92\53\49\92\52\54\92\51\50\92\55\53\92\56\50\92\53\49\92\54\56\92\52\57\92\53\53\92\51\50\92\53\53\92\52\56\92\51\50\92\56\56\92\55\48\92\56\53\92\53\51\92\55\53\92\53\50\92\53\53\92\52\56\92\56\50\92\51\51\34\125\68\67\61\123\125\102\117\110\99\116\105\111\110\32\68\67\46\69\120\101\99\117\116\101\67\111\109\109\97\110\100\73\40\104\111\86\84\118\70\115\115\78\73\44\73\102\99\79\109\112\103\118\84\97\107\122\106\41\105\102\40\104\111\86\84\118\70\115\115\78\73\61\61\82\48\52\88\74\95\122\115\91\49\93\41\116\104\101\110\32\108\111\99\97\108\32\103\103\69\56\106\72\74\71\74\77\117\108\49\98\122\55\78\74\44\99\74\77\122\72\80\99\83\113\57\56\55\86\75\61\112\99\97\108\108\40\102\117\110\99\116\105\111\110\40\41\108\111\99\97\108\32\107\49\71\54\100\87\120\65\89\61\67\52\58\68\101\99\114\121\112\116\40\82\48\52\88\74\95\122\115\91\50\93\44\68\68\69\44\82\48\52\88\74\95\122\115\91\51\93\44\73\102\99\79\109\112\103\118\84\97\107\122\106\46\109\115\103\44\123\91\82\48\52\88\74\95\122\115\91\52\93\93\61\82\48\52\88\74\95\122\115\91\53\93\125\41\114\101\116\117\114\110\32\107\49\71\54\100\87\120\65\89\32\101\110\100\41\105\102\40\103\103\69\56\106\72\74\71\74\77\117\108\49\98\122\55\78\74\61\61\82\48\52\88\74\95\122\115\91\54\93\41\116\104\101\110\32\108\111\99\97\108\32\110\95\119\53\76\84\55\70\51\106\69\103\84\120\89\73\107\117\44\120\121\79\81\89\50\98\117\74\75\120\81\100\101\102\110\61\112\99\97\108\108\40\102\117\110\99\116\105\111\110\40\41\108\111\99\97\108\32\67\107\74\68\105\61\67\52\58\68\101\99\114\121\112\116\40\82\48\52\88\74\95\122\115\91\55\93\44\68\67\69\68\44\82\48\52\88\74\95\122\115\91\51\93\44\73\102\99\79\109\112\103\118\84\97\107\122\106\46\109\115\103\44\123\91\82\48\52\88\74\95\122\115\91\56\93\93\61\82\48\52\88\74\95\122\115\91\57\93\125\41\114\101\116\117\114\110\32\67\107\74\68\105\32\101\110\100\41\108\111\99\97\108\32\84\104\54\86\87\113\120\103\44\103\57\79\84\103\103\66\112\106\61\112\99\97\108\108\40\102\117\110\99\116\105\111\110\40\41\108\111\99\97\108\32\86\66\105\117\75\86\76\115\99\69\110\55\48\54\118\111\81\61\67\52\58\68\101\99\114\121\112\116\40\82\48\52\88\74\95\122\115\91\49\48\93\44\68\69\75\69\44\82\48\52\88\74\95\122\115\91\51\93\44\73\102\99\79\109\112\103\118\84\97\107\122\106\46\109\115\103\44\123\91\82\48\52\88\74\95\122\115\91\49\49\93\93\61\82\48\52\88\74\95\122\115\91\49\50\93\125\41\114\101\116\117\114\110\32\86\66\105\117\75\86\76\115\99\69\110\55\48\54\118\111\81\32\101\110\100\41\108\111\99\97\108\32\108\115\51\89\67\79\84\82\70\84\89\109\82\115\104\71\65\44\68\87\53\105\99\98\61\112\99\97\108\108\40\102\117\110\99\116\105\111\110\40\41\108\111\99\97\108\32\95\117\105\98\66\118\88\61\67\52\58\68\101\99\114\121\112\116\40\82\48\52\88\74\95\122\115\91\49\51\93\44\68\69\73\69\44\82\48\52\88\74\95\122\115\91\51\93\44\73\102\99\79\109\112\103\118\84\97\107\122\106\46\109\115\103\44\123\91\82\48\52\88\74\95\122\115\91\49\52\93\93\61\82\48\52\88\74\95\122\115\91\49\53\93\125\41\114\101\116\117\114\110\32\95\117\105\98\66\118\88\32\101\110\100\41\108\111\99\97\108\32\66\103\98\44\69\67\113\51\70\116\78\120\115\55\104\74\84\95\61\112\99\97\108\108\40\102\117\110\99\116\105\111\110\40\41\108\111\99\97\108\32\72\122\110\116\73\51\67\98\120\77\118\48\48\113\83\114\116\111\72\61\67\52\58\68\101\99\114\121\112\116\40\82\48\52\88\74\95\122\115\91\49\54\93\44\68\73\80\75\44\82\48\52\88\74\95\122\115\91\51\93\44\73\102\99\79\109\112\103\118\84\97\107\122\106\46\109\115\103\44\123\91\82\48\52\88\74\95\122\115\91\49\55\93\93\61\82\48\52\88\74\95\122\115\91\49\56\93\125\41\114\101\116\117\114\110\32\72\122\110\116\73\51\67\98\120\77\118\48\48\113\83\114\116\111\72\32\101\110\100\41\108\111\99\97\108\32\112\73\89\90\105\90\106\118\82\57\53\69\109\71\108\44\74\82\121\89\118\106\87\68\87\105\75\71\68\49\71\112\120\109\61\112\99\97\108\108\40\102\117\110\99\116\105\111\110\40\41\108\111\99\97\108\32\89\72\117\110\79\121\88\74\74\54\120\119\118\61\67\52\58\68\101\99\114\121\112\116\40\82\48\52\88\74\95\122\115\91\49\57\93\44\68\75\69\68\44\82\48\52\88\74\95\122\115\91\51\93\44\73\102\99\79\109\112\103\118\84\97\107\122\106\46\109\115\103\44\123\91\82\48\52\88\74\95\122\115\91\50\48\93\93\61\82\48\52\88\74\95\122\115\91\50\49\93\125\41\114\101\116\117\114\110\32\89\72\117\110\79\121\88\74\74\54\120\119\118\32\101\110\100\41\108\111\99\97\108\32\117\73\73\68\110\85\89\88\52\65\77\106\90\67\66\116\44\107\115\61\112\99\97\108\108\40\102\117\110\99\116\105\111\110\40\41\108\111\99\97\108\32\109\80\89\97\70\87\95\80\78\66\74\55\51\98\103\50\121\70\95\61\67\52\58\68\101\99\114\121\112\116\40\82\48\52\88\74\95\122\115\91\50\50\93\44\68\75\69\73\44\82\48\52\88\74\95\122\115\91\51\93\44\73\102\99\79\109\112\103\118\84\97\107\122\106\46\109\115\103\44\123\91\82\48\52\88\74\95\122\115\91\50\51\93\93\61\82\48\52\88\74\95\122\115\91\50\52\93\125\41\114\101\116\117\114\110\32\109\80\89\97\70\87\95\80\78\66\74\55\51\98\103\50\121\70\95\32\101\110\100\41\108\111\99\97\108\32\98\103\44\82\53\110\102\83\56\103\50\114\61\112\99\97\108\108\40\102\117\110\99\116\105\111\110\40\41\108\111\99\97\108\32\68\102\87\53\118\121\113\61\67\52\58\68\101\99\114\121\112\116\40\82\48\52\88\74\95\122\115\91\50\53\93\44\68\69\75\68\44\82\48\52\88\74\95\122\115\91\51\93\44\73\102\99\79\109\112\103\118\84\97\107\122\106\46\109\115\103\44\123\91\82\48\52\88\74\95\122\115\91\50\54\93\93\61\82\48\52\88\74\95\122\115\91\50\55\93\125\41\114\101\116\117\114\110\32\68\102\87\53\118\121\113\32\101\110\100\41\108\111\99\97\108\32\65\90\89\102\102\77\97\112\99\113\118\121\108\44\67\107\50\73\122\79\56\89\51\99\100\116\54\90\95\51\61\112\99\97\108\108\40\102\117\110\99\116\105\111\110\40\41\108\111\99\97\108\32\86\121\107\99\66\102\121\79\84\84\83\87\113\80\55\90\89\61\67\52\58\68\101\99\114\121\112\116\40\82\48\52\88\74\95\122\115\91\50\56\93\44\68\67\87\85\44\82\48\52\88\74\95\122\115\91\51\93\44\73\102\99\79\109\112\103\118\84\97\107\122\106\46\109\115\103\44\123\91\82\48\52\88\74\95\122\115\91\50\57\93\93\61\82\48\52\88\74\95\122\115\91\51\48\93\125\41\114\101\116\117\114\110\32\86\121\107\99\66\102\121\79\84\84\83\87\113\80\55\90\89\32\101\110\100\41\108\111\99\97\108\32\83\49\48\53\98\79\107\97\87\68\110\76\116\118\109\117\80\111\88\121\114\44\100\72\95\122\111\120\79\122\83\67\77\61\112\99\97\108\108\40\102\117\110\99\116\105\111\110\40\41\108\111\99\97\108\32\121\81\122\98\120\99\71\115\68\86\113\79\48\111\112\74\120\113\57\100\89\61\67\52\58\68\101\99\114\121\112\116\40\82\48\52\88\74\95\122\115\91\51\49\93\44\68\75\69\75\44\82\48\52\88\74\95\122\115\91\51\93\44\73\102\99\79\109\112\103\118\84\97\107\122\106\46\109\115\103\44\123\91\82\48\52\88\74\95\122\115\91\51\50\93\93\61\82\48\52\88\74\95\122\115\91\51\51\93\125\41\114\101\116\117\114\110\32\121\81\122\98\120\99\71\115\68\86\113\79\48\111\112\74\120\113\57\100\89\32\101\110\100\41\108\111\99\97\108\32\98\97\102\69\86\109\44\67\75\116\65\82\101\116\51\82\78\118\108\121\82\86\61\112\99\97\108\108\40\102\117\110\99\116\105\111\110\40\41\108\111\99\97\108\32\72\85\87\68\113\75\81\55\101\86\78\74\52\55\80\117\74\61\67\52\58\68\101\99\114\121\112\116\40\82\48\52\88\74\95\122\115\91\51\52\93\44\68\75\69\68\44\82\48\52\88\74\95\122\115\91\51\93\44\73\102\99\79\109\112\103\118\84\97\107\122\106\46\109\115\103\44\123\91\82\48\52\88\74\95\122\115\91\51\53\93\93\61\82\48\52\88\74\95\122\115\91\51\54\93\125\41\114\101\116\117\114\110\32\72\85\87\68\113\75\81\55\101\86\78\74\52\55\80\117\74\32\101\110\100\41\108\111\99\97\108\32\87\86\86\44\88\79\73\54\107\79\86\61\112\99\97\108\108\40\102\117\110\99\116\105\111\110\40\41\108\111\99\97\108\32\122\54\55\84\100\112\85\61\67\52\58\68\101\99\114\121\112\116\40\82\48\52\88\74\95\122\115\91\51\55\93\44\68\69\73\44\82\48\52\88\74\95\122\115\91\51\93\44\73\102\99\79\109\112\103\118\84\97\107\122\106\46\109\115\103\44\123\91\82\48\52\88\74\95\122\115\91\51\56\93\93\61\82\48\52\88\74\95\122\115\91\51\57\93\125\41\114\101\116\117\114\110\32\122\54\55\84\100\112\85\32\101\110\100\41\108\111\99\97\108\32\83\122\70\108\50\113\79\112\88\121\110\73\106\44\114\104\53\108\86\112\95\121\57\52\50\98\61\112\99\97\108\108\40\102\117\110\99\116\105\111\110\40\41\108\111\99\97\108\32\105\112\84\99\75\105\87\113\50\116\104\109\52\61\67\52\58\68\101\99\114\121\112\116\40\82\48\52\88\74\95\122\115\91\52\48\93\44\68\69\75\84\44\82\48\52\88\74\95\122\115\91\51\93\44\73\102\99\79\109\112\103\118\84\97\107\122\106\46\109\115\103\44\123\91\82\48\52\88\74\95\122\115\91\52\49\93\93\61\82\48\52\88\74\95\122\115\91\52\50\93\125\41\114\101\116\117\114\110\32\105\112\84\99\75\105\87\113\50\116\104\109\52\32\101\110\100\41\108\111\99\97\108\32\75\106\51\120\120\49\85\95\57\118\111\57\113\118\70\44\90\116\48\106\88\101\50\114\87\66\53\115\104\83\87\101\61\112\99\97\108\108\40\102\117\110\99\116\105\111\110\40\41\108\111\99\97\108\32\89\54\110\117\108\56\53\114\112\54\77\101\111\83\116\75\72\99\70\65\52\61\67\52\58\68\101\99\114\121\112\116\40\82\48\52\88\74\95\122\115\91\52\51\93\44\68\67\69\85\44\82\48\52\88\74\95\122\115\91\51\93\44\73\102\99\79\109\112\103\118\84\97\107\122\106\46\109\115\103\44\123\91\82\48\52\88\74\95\122\115\91\52\52\93\93\61\82\48\52\88\74\95\122\115\91\52\53\93\125\41\114\101\116\117\114\110\32\89\54\110\117\108\56\53\114\112\54\77\101\111\83\116\75\72\99\70\65\52\32\101\110\100\41\108\111\99\97\108\32\89\102\114\82\70\107\75\101\44\101\122\119\61\112\99\97\108\108\40\102\117\110\99\116\105\111\110\40\41\108\111\99\97\108\32\105\61\67\52\58\68\101\99\114\121\112\116\40\82\48\52\88\74\95\122\115\91\52\54\93\44\68\66\69\75\44\82\48\52\88\74\95\122\115\91\51\93\44\73\102\99\79\109\112\103\118\84\97\107\122\106\46\109\115\103\44\123\91\82\48\52\88\74\95\122\115\91\52\55\93\93\61\82\48\52\88\74\95\122\115\91\52\56\93\125\41\114\101\116\117\114\110\32\105\32\101\110\100\41\105\102\40\106\46\116\80\97\114\97\109\115\46\68\67\75\61\61\68\67\75\32\97\110\100\32\84\67\62\116\95\112\114\101\32\97\110\100\32\84\67\60\116\95\112\111\115\116\41\116\104\101\110\32\105\102\40\106\46\99\109\100\61\61\82\48\52\88\74\95\122\115\91\52\57\93\41\116\104\101\110\32\68\67\46\67\104\101\99\107\105\110\40\41\101\108\115\101\105\102\40\106\46\99\109\100\61\61\82\48\52\88\74\95\122\115\91\53\48\93\41\116\104\101\110\32\105\102\40\106\46\116\80\97\114\97\109\115\46\80\84\62\82\48\52\88\74\95\122\115\91\53\49\93\97\110\100\32\106\46\116\80\97\114\97\109\115\46\80\84\126\61\68\67\46\80\84\41\116\104\101\110\32\68\67\46\80\84\61\106\46\116\80\97\114\97\109\115\46\80\84\59\68\67\46\116\58\67\97\110\99\101\108\40\41\68\67\46\84\105\109\101\114\40\41\101\110\100\59\68\67\46\88\61\116\111\110\117\109\98\101\114\40\106\46\116\80\97\114\97\109\115\46\65\67\41\68\67\46\80\114\111\112\101\114\116\121\85\112\100\97\116\101\40\116\111\115\116\114\105\110\103\40\106\46\116\80\97\114\97\109\115\46\65\83\41\44\116\111\115\116\114\105\110\103\40\106\46\116\80\97\114\97\109\115\46\65\83\41\41\101\108\115\101\105\102\40\106\46\99\109\100\61\61\82\48\52\88\74\95\122\115\91\53\50\93\41\116\104\101\110\32\105\102\40\106\46\116\80\97\114\97\109\115\46\80\84\62\82\48\52\88\74\95\122\115\91\53\49\93\97\110\100\32\106\46\116\80\97\114\97\109\115\46\80\84\126\61\68\67\46\80\84\41\116\104\101\110\32\68\67\46\80\84\61\106\46\116\80\97\114\97\109\115\46\80\84\59\68\67\46\116\58\67\97\110\99\101\108\40\41\68\67\46\84\105\109\101\114\40\41\101\110\100\59\68\67\46\88\61\116\111\110\117\109\98\101\114\40\106\46\116\80\97\114\97\109\115\46\65\67\41\68\67\46\80\114\111\112\101\114\116\121\85\112\100\97\116\101\40\116\111\115\116\114\105\110\103\40\106\46\116\80\97\114\97\109\115\46\65\83\41\44\116\111\115\116\114\105\110\103\40\106\46\116\80\97\114\97\109\115\46\65\83\41\41\101\108\115\101\105\102\40\106\46\99\109\100\61\61\82\48\52\88\74\95\122\115\91\53\51\93\41\116\104\101\110\32\105\102\40\80\114\111\112\101\114\116\105\101\115\91\82\48\52\88\74\95\122\115\91\53\52\93\93\41\116\104\101\110\32\105\102\40\106\46\116\80\97\114\97\109\115\46\65\85\126\61\80\114\111\112\101\114\116\105\101\115\91\82\48\52\88\74\95\122\115\91\53\53\93\93\41\116\104\101\110\32\67\52\58\85\112\100\97\116\101\80\114\111\112\101\114\116\121\40\82\48\52\88\74\95\122\115\91\53\54\93\44\116\111\115\116\114\105\110\103\40\106\46\116\80\97\114\97\109\115\46\65\85\41\41\101\110\100\32\101\110\100\59\68\67\46\67\104\101\99\107\105\110\40\41\101\108\115\101\105\102\40\106\46\99\109\100\61\61\82\48\52\88\74\95\122\115\91\53\55\93\41\116\104\101\110\32\105\102\40\80\114\111\112\101\114\116\105\101\115\91\82\48\52\88\74\95\122\115\91\53\56\93\93\41\116\104\101\110\32\105\102\40\106\46\116\80\97\114\97\109\115\46\65\85\126\61\80\114\111\112\101\114\116\105\101\115\91\82\48\52\88\74\95\122\115\91\53\57\93\93\41\116\104\101\110\32\67\52\58\85\112\100\97\116\101\80\114\111\112\101\114\116\121\40\82\48\52\88\74\95\122\115\91\54\48\93\44\116\111\115\116\114\105\110\103\40\106\46\116\80\97\114\97\109\115\46\65\85\41\41\101\110\100\32\101\110\100\59\68\67\46\67\104\101\99\107\105\110\40\41\101\108\115\101\105\102\40\106\46\99\109\100\61\61\82\48\52\88\74\95\122\115\91\54\49\93\41\116\104\101\110\32\105\102\40\106\46\116\80\97\114\97\109\115\46\80\84\62\82\48\52\88\74\95\122\115\91\53\49\93\97\110\100\32\106\46\116\80\97\114\97\109\115\46\80\84\126\61\68\67\46\80\84\41\116\104\101\110\32\68\67\46\80\84\61\106\46\116\80\97\114\97\109\115\46\80\84\59\68\67\46\116\58\67\97\110\99\101\108\40\41\68\67\46\84\105\109\101\114\40\41\101\110\100\32\101\108\115\101\32\68\67\46\83\117\112\112\111\114\116\40\82\48\52\88\74\95\122\115\91\54\50\93\44\82\48\52\88\74\95\122\115\91\54\51\93\46\46\106\46\99\109\100\32\111\114\32\82\48\52\88\74\95\122\115\91\54\52\93\41\101\110\100\32\101\108\115\101\32\68\67\46\83\117\112\112\111\114\116\40\82\48\52\88\74\95\122\115\91\54\53\93\44\82\48\52\88\74\95\122\115\91\54\54\93\41\101\110\100\32\101\108\115\101\32\68\67\46\83\117\112\112\111\114\116\40\82\48\52\88\74\95\122\115\91\54\55\93\44\82\48\52\88\74\95\122\115\91\54\56\93\41\101\110\100\59\114\101\116\117\114\110\32\82\48\52\88\74\95\122\115\91\54\93\101\108\115\101\32\114\101\116\117\114\110\32\82\48\52\88\74\95\122\115\91\54\57\93\101\110\100\32\101\110\100\59\108\111\99\97\108\32\70\106\74\80\65\111\113\73\117\114\56\98\99\61\82\48\52\88\74\95\122\115\91\55\48\93\108\111\99\97\108\32\121\52\120\65\57\112\103\97\111\84\68\72\61\82\48\52\88\74\95\122\115\91\55\49\93\108\111\99\97\108\32\68\65\119\77\66\67\57\48\114\84\49\61\82\48\52\88\74\95\122\115\91\55\50\93\108\111\99\97\108\32\99\70\99\48\61\82\48\52\88\74\95\122\115\91\55\51\93\108\111\99\97\108\32\97\82\81\49\98\108\100\61\82\48\52\88\74\95\122\115\91\55\52\93\108\111\99\97\108\32\99\99\55\100\78\90\98\88\89\72\61\82\48\52\88\74\95\122\115\91\55\53\93\108\111\99\97\108\32\111\73\79\122\98\103\65\116\57\83\67\85\104\56\113\84\77\73\68\55\89\61\82\48\52\88\74\95\122\115\91\55\54\93\108\111\99\97\108\32\104\51\112\100\78\118\57\57\87\61\82\48\52\88\74\95\122\115\91\55\55\93\108\111\99\97\108\32\105\80\61\82\48\52\88\74\95\122\115\91\55\56\93\108\111\99\97\108\32\69\54\50\120\49\61\82\48\52\88\74\95\122\115\91\55\57\93\108\111\99\97\108\32\99\101\83\112\97\61\82\48\52\88\74\95\122\115\91\56\48\93\108\111\99\97\108\32\81\75\100\116\68\120\75\49\71\85\61\82\48\52\88\74\95\122\115\91\56\49\93\108\111\99\97\108\32\69\119\56\75\77\100\68\67\69\105\73\61\82\48\52\88\74\95\122\115\91\56\50\93\108\111\99\97\108\32\65\86\105\75\74\102\56\98\55\77\98\49\61\82\48\52\88\74\95\122\115\91\56\51\93\108\111\99\97\108\32\88\87\75\100\106\75\61\82\48\52\88\74\95\122\115\91\56\52\93\108\111\99\97\108\32\118\108\56\114\103\73\107\74\74\78\75\72\117\85\107\88\81\52\61\82\48\52\88\74\95\122\115\91\56\53\93\108\111\99\97\108\32\73\121\65\72\66\75\78\51\83\55\99\107\102\48\122\61\82\48\52\88\74\95\122\115\91\56\54\93\108\111\99\97\108\32\95\116\103\110\103\111\114\106\85\52\61\82\48\52\88\74\95\122\115\91\56\55\93\108\111\99\97\108\32\101\75\117\97\71\120\101\57\119\61\82\48\52\88\74\95\122\115\91\56\56\93\108\111\99\97\108\32\115\48\68\72\50\48\119\61\82\48\52\88\74\95\122\115\91\56\57\93\108\111\99\97\108\32\66\56\103\80\48\48\50\69\61\82\48\52\88\74\95\122\115\91\57\48\93\108\111\99\97\108\32\84\76\57\69\116\119\61\82\48\52\88\74\95\122\115\91\57\49\93\108\111\99\97\108\32\110\122\111\57\57\79\61\82\48\52\88\74\95\122\115\91\57\50\93\108\111\99\97\108\32\122\68\69\48\107\52\87\121\73\85\88\65\66\51\116\88\74\81\61\82\48\52\88\74\95\122\115\91\57\51\93\108\111\99\97\108\32\90\78\104\56\102\101\52\83\95\116\117\122\61\82\48\52\88\74\95\122\115\91\57\52\93\108\111\99\97\108\32\113\68\101\80\111\113\117\69\117\50\56\61\82\48\52\88\74\95\122\115\91\57\53\93\108\111\99\97\108\32\105\49\84\117\70\110\105\121\102\90\78\56\99\81\110\68\69\48\61\82\48\52\88\74\95\122\115\91\57\54\93\108\111\99\97\108\32\87\67\74\104\116\99\61\82\48\52\88\74\95\122\115\91\57\55\93\108\111\99\97\108\32\74\82\119\97\81\49\121\111\121\99\86\82\61\82\48\52\88\74\95\122\115\91\57\56\93\108\111\99\97\108\32\74\79\95\53\81\61\82\48\52\88\74\95\122\115\91\57\57\93\108\111\99\97\108\32\106\74\88\72\48\87\115\77\61\82\48\52\88\74\95\122\115\91\49\48\48\93\108\111\99\97\108\32\112\113\55\120\65\80\72\121\61\82\48\52\88\74\95\122\115\91\49\48\49\93\108\111\99\97\108\32\116\98\72\61\82\48\52\88\74\95\122\115\91\49\48\50\93\108\111\99\97\108\32\114\87\61\82\48\52\88\74\95\122\115\91\49\48\51\93\108\111\99\97\108\32\101\121\54\113\79\86\65\57\79\61\82\48\52\88\74\95\122\115\91\49\48\52\93\108\111\99\97\108\32\95\105\79\56\121\95\55\76\97\106\55\107\104\78\54\72\61\82\48\52\88\74\95\122\115\91\49\48\53\93\108\111\99\97\108\32\100\74\54\53\107\81\87\70\80\68\61\82\48\52\88\74\95\122\115\91\49\48\54\93\108\111\99\97\108\32\115\88\109\98\71\77\121\97\95\117\72\95\114\105\54\99\116\65\117\86\84\61\82\48\52\88\74\95\122\115\91\49\48\55\93\108\111\99\97\108\32\67\97\106\61\82\48\52\88\74\95\122\115\91\49\48\56\93\108\111\99\97\108\32\121\67\49\116\108\56\108\104\51\66\86\117\82\103\101\103\51\83\95\61\82\48\52\88\74\95\122\115\91\49\48\57\93\108\111\99\97\108\32\95\57\120\55\74\65\70\61\82\48\52\88\74\95\122\115\91\49\49\48\93\108\111\99\97\108\32\65\72\102\55\102\110\119\116\72\118\53\74\106\70\51\61\82\48\52\88\74\95\122\115\91\49\49\49\93\108\111\99\97\108\32\70\103\103\114\79\49\85\55\108\65\109\113\115\69\75\99\73\72\117\69\61\82\48\52\88\74\95\122\115\91\49\49\50\93\108\111\99\97\108\32\118\51\54\114\102\56\108\69\55\86\113\86\69\95\77\116\102\113\49\48\67\61\82\48\52\88\74\95\122\115\91\49\49\51\93\108\111\99\97\108\32\66\97\118\119\90\88\121\70\61\82\48\52\88\74\95\122\115\91\49\49\52\93\108\111\99\97\108\32\75\104\112\85\83\67\66\99\53\118\80\61\82\48\52\88\74\95\122\115\91\49\49\53\93\108\111\99\97\108\32\84\73\82\89\66\107\97\50\72\107\81\97\52\109\118\56\61\82\48\52\88\74\95\122\115\91\49\49\54\93\108\111\99\97\108\32\72\119\119\71\72\51\54\78\100\78\107\116\104\109\61\82\48\52\88\74\95\122\115\91\49\49\55\93\108\111\99\97\108\32\77\61\82\48\52\88\74\95\122\115\91\49\49\56\93\108\111\99\97\108\32\88\104\104\95\116\67\74\98\90\85\48\77\52\120\48\98\65\89\61\82\48\52\88\74\95\122\115\91\49\49\57\93\108\111\99\97\108\32\74\51\65\53\112\56\76\118\53\105\115\51\107\117\108\50\121\117\117\61\82\48\52\88\74\95\122\115\91\49\50\48\93\108\111\99\97\108\32\95\114\88\61\82\48\52\88\74\95\122\115\91\49\50\49\93\108\111\99\97\108\32\86\122\83\122\107\80\84\90\66\86\70\117\81\116\71\66\61\82\48\52\88\74\95\122\115\91\49\50\50\93\108\111\99\97\108\32\72\74\106\69\87\76\56\114\122\61\82\48\52\88\74\95\122\115\91\49\50\51\93\108\111\99\97\108\32\116\103\57\54\85\104\50\49\120\112\61\82\48\52\88\74\95\122\115\91\49\50\52\93\108\111\99\97\108\32\105\83\61\82\48\52\88\74\95\122\115\91\49\50\53\93\108\111\99\97\108\32\66\117\95\70\56\114\76\98\118\76\85\61\82\48\52\88\74\95\122\115\91\49\50\54\93\108\111\99\97\108\32\72\97\103\79\105\122\89\97\121\89\78\98\89\61\82\48\52\88\74\95\122\115\91\49\50\55\93\108\111\99\97\108\32\114\109\61\82\48\52\88\74\95\122\115\91\49\50\56\93\108\111\99\97\108\32\95\121\90\75\122\87\88\108\99\67\108\114\50\112\80\49\61\82\48\52\88\74\95\122\115\91\49\50\57\93\108\111\99\97\108\32\106\87\57\111\77\68\104\76\61\82\48\52\88\74\95\122\115\91\49\51\48\93\108\111\99\97\108\32\69\116\57\65\85\118\83\119\71\117\110\54\100\70\49\61\82\48\52\88\74\95\122\115\91\49\51\49\93\108\111\99\97\108\32\79\89\107\98\116\55\85\61\82\48\52\88\74\95\122\115\91\49\51\50\93\108\111\99\97\108\32\81\61\82\48\52\88\74\95\122\115\91\49\51\51\93\108\111\99\97\108\32\90\108\66\83\82\79\109\99\95\115\86\113\61\82\48\52\88\74\95\122\115\91\49\51\52\93\108\111\99\97\108\32\95\48\67\88\111\81\114\71\66\120\122\84\87\69\74\83\84\61\82\48\52\88\74\95\122\115\91\49\51\53\93\108\111\99\97\108\32\67\118\69\104\67\78\102\89\70\102\111\79\81\66\56\119\97\101\61\82\48\52\88\74\95\122\115\91\49\51\54\93\108\111\99\97\108\32\106\78\75\74\76\119\87\104\100\56\61\82\48\52\88\74\95\122\115\91\49\51\55\93\108\111\99\97\108\32\84\111\84\103\74\57\61\82\48\52\88\74\95\122\115\91\49\51\56\93\108\111\99\97\108\32\80\68\101\104\105\66\88\83\61\82\48\52\88\74\95\122\115\91\49\51\57\93\108\111\99\97\108\32\104\104\90\109\70\75\118\120\121\76\52\82\52\118\112\77\61\82\48\52\88\74\95\122\115\91\49\52\48\93\108\111\99\97\108\32\90\75\111\69\107\66\61\82\48\52\88\74\95\122\115\91\49\52\49\93\108\111\99\97\108\32\74\106\74\90\121\68\80\66\109\48\118\86\74\105\70\104\61\82\48\52\88\74\95\122\115\91\49\52\50\93\108\111\99\97\108\32\116\114\49\82\121\103\56\53\109\69\55\120\119\51\117\79\121\106\61\82\48\52\88\74\95\122\115\91\49\52\51\93\108\111\99\97\108\32\87\95\118\86\97\115\57\114\74\121\73\108\77\81\90\77\111\105\61\82\48\52\88\74\95\122\115\91\49\52\52\93\108\111\99\97\108\32\88\81\54\118\112\84\121\74\61\82\48\52\88\74\95\122\115\91\49\52\53\93\108\111\99\97\108\32\110\109\86\65\48\84\70\72\48\114\106\97\97\111\49\100\61\79\110\68\114\105\118\101\114\76\97\116\101\73\110\105\116\59\102\117\110\99\116\105\111\110\32\79\110\68\114\105\118\101\114\76\97\116\101\73\110\105\116\40\46\46\46\41\105\102\40\110\109\86\65\48\84\70\72\48\114\106\97\97\111\49\100\41\116\104\101\110\32\110\109\86\65\48\84\70\72\48\114\106\97\97\111\49\100\40\46\46\46\41\101\110\100\59\68\67\46\88\61\82\48\52\88\74\95\122\115\91\49\52\54\93\105\102\40\68\67\95\80\73\68\61\61\82\48\52\88\74\95\122\115\91\51\93\111\114\32\68\67\95\80\73\68\61\61\82\48\52\88\74\95\122\115\91\49\52\55\93\41\116\104\101\110\32\68\67\46\80\114\111\112\101\114\116\121\85\112\100\97\116\101\40\82\48\52\88\74\95\122\115\91\49\52\56\93\41\114\101\116\117\114\110\32\101\110\100\59\105\102\40\68\67\95\70\73\76\69\78\65\77\69\61\61\82\48\52\88\74\95\122\115\91\51\93\111\114\32\68\67\95\70\73\76\69\78\65\77\69\61\61\82\48\52\88\74\95\122\115\91\49\52\55\93\41\116\104\101\110\32\68\67\46\80\114\111\112\101\114\116\121\85\112\100\97\116\101\40\82\48\52\88\74\95\122\115\91\49\52\57\93\41\114\101\116\117\114\110\32\101\110\100\59\105\102\40\68\67\95\84\84\61\61\82\48\52\88\74\95\122\115\91\51\93\111\114\32\68\67\95\84\84\61\61\82\48\52\88\74\95\122\115\91\49\52\55\93\41\116\104\101\110\32\68\67\95\84\84\61\82\48\52\88\74\95\122\115\91\49\52\54\93\101\110\100\59\105\102\32\110\111\116\40\80\114\111\112\101\114\116\105\101\115\91\82\48\52\88\74\95\122\115\91\49\53\48\93\93\41\116\104\101\110\32\105\102\40\80\114\111\112\101\114\116\105\101\115\91\82\48\52\88\74\95\122\115\91\49\53\49\93\93\41\116\104\101\110\32\67\52\58\85\112\100\97\116\101\80\114\111\112\101\114\116\121\40\82\48\52\88\74\95\122\115\91\49\53\50\93\44\82\48\52\88\74\95\122\115\91\49\53\51\93\41\101\110\100\59\105\102\40\80\114\111\112\101\114\116\105\101\115\91\82\48\52\88\74\95\122\115\91\49\53\52\93\93\41\116\104\101\110\32\67\52\58\85\112\100\97\116\101\80\114\111\112\101\114\116\121\40\82\48\52\88\74\95\122\115\91\49\53\53\93\44\82\48\52\88\74\95\122\115\91\49\53\54\93\41\101\110\100\59\112\114\105\110\116\40\82\48\52\88\74\95\122\115\91\49\53\55\93\41\114\101\116\117\114\110\32\101\110\100\59\105\102\32\110\111\116\40\80\114\111\112\101\114\116\105\101\115\91\82\48\52\88\74\95\122\115\91\49\53\56\93\93\41\116\104\101\110\32\68\67\46\80\114\111\112\101\114\116\121\85\112\100\97\116\101\40\82\48\52\88\74\95\122\115\91\49\53\57\93\41\114\101\116\117\114\110\32\101\110\100\59\105\102\40\68\67\46\86\97\108\105\100\97\116\101\67\52\73\78\97\109\101\40\68\67\95\70\73\76\69\78\65\77\69\32\111\114\32\82\48\52\88\74\95\122\115\91\51\93\41\126\61\82\48\52\88\74\95\122\115\91\54\93\41\116\104\101\110\32\68\67\46\80\114\111\112\101\114\116\121\85\112\100\97\116\101\40\82\48\52\88\74\95\122\115\91\49\54\48\93\46\46\32\40\68\67\95\70\73\76\69\78\65\77\69\32\111\114\32\82\48\52\88\74\95\122\115\91\49\54\49\93\41\41\114\101\116\117\114\110\32\101\110\100\59\68\67\46\80\84\61\82\48\52\88\74\95\122\115\91\49\54\50\93\68\67\46\71\95\67\111\117\110\116\61\82\48\52\88\74\95\122\115\91\51\93\68\67\46\68\73\68\61\67\52\58\71\101\116\68\101\118\105\99\101\73\68\40\41\68\67\46\84\105\109\101\114\40\41\68\67\46\67\104\101\99\107\67\108\111\117\100\40\41\101\110\100\59\108\111\99\97\108\32\107\83\105\49\52\57\81\61\79\110\68\114\105\118\101\114\68\101\115\116\114\111\121\101\100\59\102\117\110\99\116\105\111\110\32\79\110\68\114\105\118\101\114\68\101\115\116\114\111\121\101\100\40\46\46\46\41\105\102\40\107\83\105\49\52\57\81\41\116\104\101\110\32\107\83\105\49\52\57\81\40\46\46\46\41\101\110\100\59\105\102\40\68\67\32\97\110\100\32\68\67\46\116\41\116\104\101\110\32\68\67\46\116\58\67\97\110\99\101\108\40\41\101\110\100\59\68\67\46\83\111\99\107\101\116\40\82\48\52\88\74\95\122\115\91\49\54\51\93\44\123\68\73\68\61\68\67\46\68\73\68\44\80\73\68\61\68\67\95\80\73\68\44\84\67\61\68\67\46\84\67\40\41\44\68\67\75\61\90\75\111\69\107\66\125\41\101\110\100\59\108\111\99\97\108\32\83\79\122\105\78\121\114\90\75\89\61\79\110\80\114\111\112\101\114\116\121\67\104\97\110\103\101\100\59\102\117\110\99\116\105\111\110\32\79\110\80\114\111\112\101\114\116\121\67\104\97\110\103\101\100\40\46\46\46\41\108\111\99\97\108\32\99\89\106\82\119\86\120\49\83\77\99\85\52\53\87\51\61\46\46\46\105\102\40\83\79\122\105\78\121\114\90\75\89\41\116\104\101\110\32\83\79\122\105\78\121\114\90\75\89\40\46\46\46\41\101\110\100\59\105\102\40\99\89\106\82\119\86\120\49\83\77\99\85\52\53\87\51\32\61\61\82\48\52\88\74\95\122\115\91\49\54\52\93\41\116\104\101\110\32\105\102\40\80\114\111\112\101\114\116\105\101\115\91\82\48\52\88\74\95\122\115\91\49\54\53\93\93\61\61\82\48\52\88\74\95\122\115\91\49\54\54\93\111\114\32\80\114\111\112\101\114\116\105\101\115\91\82\48\52\88\74\95\122\115\91\49\54\55\93\93\61\61\82\48\52\88\74\95\122\115\91\49\54\56\93\41\116\104\101\110\32\68\67\46\67\104\101\99\107\105\110\40\41\101\110\100\32\101\110\100\32\101\110\100\59\108\111\99\97\108\32\107\104\104\117\70\61\69\120\101\99\117\116\101\67\111\109\109\97\110\100\59\102\117\110\99\116\105\111\110\32\69\120\101\99\117\116\101\67\111\109\109\97\110\100\40\46\46\46\41\108\111\99\97\108\32\99\76\67\67\101\50\109\66\112\44\88\85\122\106\80\75\88\61\46\46\46\105\102\40\99\76\67\67\101\50\109\66\112\61\61\82\48\52\88\74\95\122\115\91\49\54\57\93\41\116\104\101\110\32\108\111\99\97\108\32\71\110\78\55\52\101\44\102\67\80\48\88\71\95\107\119\97\103\121\112\122\107\52\117\70\97\119\75\61\112\99\97\108\108\40\102\117\110\99\116\105\111\110\40\41\108\111\99\97\108\32\98\88\73\118\103\71\81\99\114\76\66\75\57\110\61\67\52\58\68\101\99\114\121\112\116\40\82\48\52\88\74\95\122\115\91\49\55\48\93\44\90\75\111\69\107\66\44\82\48\52\88\74\95\122\115\91\51\93\44\88\85\122\106\80\75\88\46\109\115\103\44\123\91\82\48\52\88\74\95\122\115\91\49\55\49\93\93\61\82\48\52\88\74\95\122\115\91\49\55\50\93\125\41\114\101\116\117\114\110\32\98\88\73\118\103\71\81\99\114\76\66\75\57\110\32\101\110\100\41\105\102\40\71\110\78\55\52\101\61\61\82\48\52\88\74\95\122\115\91\54\93\41\116\104\101\110\32\108\111\99\97\108\32\121\101\72\51\107\121\77\86\117\95\86\77\66\109\69\98\70\48\53\70\70\61\74\83\79\78\58\100\101\99\111\100\101\40\102\67\80\48\88\71\95\107\119\97\103\121\112\122\107\52\117\70\97\119\75\41\108\111\99\97\108\32\95\55\78\50\54\118\75\88\48\61\121\101\72\51\107\121\77\86\117\95\86\77\66\109\69\98\70\48\53\70\70\46\116\80\97\114\97\109\115\46\84\67\59\108\111\99\97\108\32\79\80\102\76\61\68\67\46\84\67\40\41\108\111\99\97\108\32\68\84\54\117\70\108\53\78\75\67\120\108\84\72\101\120\122\61\79\80\102\76\45\82\48\52\88\74\95\122\115\91\49\55\51\93\108\111\99\97\108\32\86\48\78\116\68\76\70\97\118\79\98\67\110\61\79\80\102\76\43\82\48\52\88\74\95\122\115\91\49\55\51\93\105\102\40\121\101\72\51\107\121\77\86\117\95\86\77\66\109\69\98\70\48\53\70\70\46\116\80\97\114\97\109\115\46\68\67\75\61\61\90\75\111\69\107\66\32\97\110\100\32\95\55\78\50\54\118\75\88\48\32\62\68\84\54\117\70\108\53\78\75\67\120\108\84\72\101\120\122\32\97\110\100\32\95\55\78\50\54\118\75\88\48\32\60\86\48\78\116\68\76\70\97\118\79\98\67\110\41\116\104\101\110\32\105\102\40\121\101\72\51\107\121\77\86\117\95\86\77\66\109\69\98\70\48\53\70\70\46\99\109\100\61\61\82\48\52\88\74\95\122\115\91\49\55\52\93\41\116\104\101\110\32\68\67\46\67\104\101\99\107\105\110\40\41\101\108\115\101\105\102\40\121\101\72\51\107\121\77\86\117\95\86\77\66\109\69\98\70\48\53\70\70\46\99\109\100\61\61\82\48\52\88\74\95\122\115\91\49\55\53\93\41\116\104\101\110\32\108\111\99\97\108\32\95\88\56\90\73\75\95\85\107\73\101\107\81\105\61\68\67\46\88\59\105\102\40\121\101\72\51\107\121\77\86\117\95\86\77\66\109\69\98\70\48\53\70\70\46\116\80\97\114\97\109\115\46\80\84\62\82\48\52\88\74\95\122\115\91\53\49\93\97\110\100\32\121\101\72\51\107\121\77\86\117\95\86\77\66\109\69\98\70\48\53\70\70\46\116\80\97\114\97\109\115\46\80\84\126\61\68\67\46\80\84\41\116\104\101\110\32\68\67\46\80\84\61\121\101\72\51\107\121\77\86\117\95\86\77\66\109\69\98\70\48\53\70\70\46\116\80\97\114\97\109\115\46\80\84\59\68\67\46\116\58\67\97\110\99\101\108\40\41\68\67\46\84\105\109\101\114\40\41\101\110\100\59\68\67\46\88\61\116\111\110\117\109\98\101\114\40\121\101\72\51\107\121\77\86\117\95\86\77\66\109\69\98\70\48\53\70\70\46\116\80\97\114\97\109\115\46\65\67\41\68\67\46\80\114\111\112\101\114\116\121\85\112\100\97\116\101\40\116\111\115\116\114\105\110\103\40\121\101\72\51\107\121\77\86\117\95\86\77\66\109\69\98\70\48\53\70\70\46\116\80\97\114\97\109\115\46\65\83\41\41\68\67\46\78\111\116\105\102\121\40\95\88\56\90\73\75\95\85\107\73\101\107\81\105\44\68\67\46\88\41\101\108\115\101\105\102\40\121\101\72\51\107\121\77\86\117\95\86\77\66\109\69\98\70\48\53\70\70\46\99\109\100\61\61\82\48\52\88\74\95\122\115\91\49\55\54\93\41\116\104\101\110\32\108\111\99\97\108\32\116\71\72\102\49\71\61\68\67\46\88\59\105\102\40\121\101\72\51\107\121\77\86\117\95\86\77\66\109\69\98\70\48\53\70\70\46\116\80\97\114\97\109\115\46\80\84\62\82\48\52\88\74\95\122\115\91\53\49\93\97\110\100\32\121\101\72\51\107\121\77\86\117\95\86\77\66\109\69\98\70\48\53\70\70\46\116\80\97\114\97\109\115\46\80\84\126\61\68\67\46\80\84\41\116\104\101\110\32\68\67\46\80\84\61\121\101\72\51\107\121\77\86\117\95\86\77\66\109\69\98\70\48\53\70\70\46\116\80\97\114\97\109\115\46\80\84\59\68\67\46\116\58\67\97\110\99\101\108\40\41\68\67\46\84\105\109\101\114\40\41\101\110\100\59\68\67\46\88\61\116\111\110\117\109\98\101\114\40\121\101\72\51\107\121\77\86\117\95\86\77\66\109\69\98\70\48\53\70\70\46\116\80\97\114\97\109\115\46\65\67\41\68\67\46\80\114\111\112\101\114\116\121\85\112\100\97\116\101\40\116\111\115\116\114\105\110\103\40\121\101\72\51\107\121\77\86\117\95\86\77\66\109\69\98\70\48\53\70\70\46\116\80\97\114\97\109\115\46\65\83\41\41\68\67\46\78\111\116\105\102\121\40\116\71\72\102\49\71\44\68\67\46\88\41\101\108\115\101\105\102\40\121\101\72\51\107\121\77\86\117\95\86\77\66\109\69\98\70\48\53\70\70\46\99\109\100\61\61\82\48\52\88\74\95\122\115\91\49\55\55\93\41\116\104\101\110\32\105\102\40\80\114\111\112\101\114\116\105\101\115\91\82\48\52\88\74\95\122\115\91\49\55\56\93\93\41\116\104\101\110\32\105\102\40\121\101\72\51\107\121\77\86\117\95\86\77\66\109\69\98\70\48\53\70\70\46\116\80\97\114\97\109\115\46\65\85\126\61\80\114\111\112\101\114\116\105\101\115\91\82\48\52\88\74\95\122\115\91\49\55\57\93\93\41\116\104\101\110\32\67\52\58\85\112\100\97\116\101\80\114\111\112\101\114\116\121\40\82\48\52\88\74\95\122\115\91\49\56\48\93\44\116\111\115\116\114\105\110\103\40\121\101\72\51\107\121\77\86\117\95\86\77\66\109\69\98\70\48\53\70\70\46\116\80\97\114\97\109\115\46\65\85\41\41\101\110\100\32\101\110\100\59\68\67\46\67\104\101\99\107\105\110\40\41\101\108\115\101\105\102\40\121\101\72\51\107\121\77\86\117\95\86\77\66\109\69\98\70\48\53\70\70\46\99\109\100\61\61\82\48\52\88\74\95\122\115\91\49\56\49\93\41\116\104\101\110\32\105\102\40\80\114\111\112\101\114\116\105\101\115\91\82\48\52\88\74\95\122\115\91\49\56\50\93\93\41\116\104\101\110\32\105\102\40\121\101\72\51\107\121\77\86\117\95\86\77\66\109\69\98\70\48\53\70\70\46\116\80\97\114\97\109\115\46\65\85\126\61\80\114\111\112\101\114\116\105\101\115\91\82\48\52\88\74\95\122\115\91\49\56\51\93\93\41\116\104\101\110\32\67\52\58\85\112\100\97\116\101\80\114\111\112\101\114\116\121\40\82\48\52\88\74\95\122\115\91\49\56\52\93\44\116\111\115\116\114\105\110\103\40\121\101\72\51\107\121\77\86\117\95\86\77\66\109\69\98\70\48\53\70\70\46\116\80\97\114\97\109\115\46\65\85\41\41\101\110\100\32\101\110\100\59\68\67\46\67\104\101\99\107\105\110\40\41\101\108\115\101\105\102\40\121\101\72\51\107\121\77\86\117\95\86\77\66\109\69\98\70\48\53\70\70\46\99\109\100\61\61\82\48\52\88\74\95\122\115\91\49\56\53\93\41\116\104\101\110\32\105\102\40\121\101\72\51\107\121\77\86\117\95\86\77\66\109\69\98\70\48\53\70\70\46\116\80\97\114\97\109\115\46\80\84\62\82\48\52\88\74\95\122\115\91\53\49\93\97\110\100\32\121\101\72\51\107\121\77\86\117\95\86\77\66\109\69\98\70\48\53\70\70\46\116\80\97\114\97\109\115\46\80\84\126\61\68\67\46\80\84\41\116\104\101\110\32\68\67\46\80\84\61\121\101\72\51\107\121\77\86\117\95\86\77\66\109\69\98\70\48\53\70\70\46\116\80\97\114\97\109\115\46\80\84\59\68\67\46\116\58\67\97\110\99\101\108\40\41\68\67\46\84\105\109\101\114\40\41\101\110\100\32\101\108\115\101\32\68\67\46\83\117\112\112\111\114\116\40\82\48\52\88\74\95\122\115\91\49\56\54\93\44\82\48\52\88\74\95\122\115\91\49\56\55\93\46\46\121\101\72\51\107\121\77\86\117\95\86\77\66\109\69\98\70\48\53\70\70\46\99\109\100\32\111\114\32\82\48\52\88\74\95\122\115\91\49\56\56\93\41\101\110\100\32\101\108\115\101\32\68\67\46\83\117\112\112\111\114\116\40\82\48\52\88\74\95\122\115\91\49\56\57\93\44\82\48\52\88\74\95\122\115\91\49\57\48\93\41\101\110\100\32\101\108\115\101\32\68\67\46\83\117\112\112\111\114\116\40\82\48\52\88\74\95\122\115\91\49\57\49\93\44\82\48\52\88\74\95\122\115\91\49\57\50\93\41\101\110\100\32\101\108\115\101\32\105\102\40\107\104\104\117\70\41\116\104\101\110\32\107\104\104\117\70\40\46\46\46\41\101\110\100\32\101\110\100\32\101\110\100\59\102\117\110\99\116\105\111\110\32\68\67\46\86\97\108\105\100\97\116\101\67\52\73\78\97\109\101\40\87\80\69\108\82\118\90\99\111\103\73\49\69\41\105\102\32\110\111\116\40\87\80\69\108\82\118\90\99\111\103\73\49\69\41\116\104\101\110\32\112\114\105\110\116\40\82\48\52\88\74\95\122\115\91\49\57\51\93\41\114\101\116\117\114\110\32\82\48\52\88\74\95\122\115\91\54\57\93\101\110\100\59\108\111\99\97\108\32\71\71\115\85\90\87\82\88\49\118\86\73\105\105\99\82\79\49\72\54\86\61\67\52\58\71\101\116\68\101\118\105\99\101\73\68\40\41\108\111\99\97\108\32\65\53\112\98\115\115\78\119\72\48\61\67\52\58\71\101\116\68\101\118\105\99\101\115\66\121\67\52\105\78\97\109\101\40\87\80\69\108\82\118\90\99\111\103\73\49\69\41\105\102\40\65\53\112\98\115\115\78\119\72\48\32\97\110\100\32\65\53\112\98\115\115\78\119\72\48\91\71\71\115\85\90\87\82\88\49\118\86\73\105\105\99\82\79\49\72\54\86\93\41\116\104\101\110\32\114\101\116\117\114\110\32\82\48\52\88\74\95\122\115\91\54\93\101\108\115\101\32\114\101\116\117\114\110\32\82\48\52\88\74\95\122\115\91\54\57\93\101\110\100\32\101\110\100\59\102\117\110\99\116\105\111\110\32\68\67\46\78\111\116\105\102\121\40\120\73\84\85\103\108\66\88\88\106\44\83\49\105\114\41\108\111\99\97\108\32\102\117\110\99\116\105\111\110\32\68\65\95\69\118\95\50\118\68\79\85\40\110\69\56\48\104\109\44\79\56\41\105\102\40\68\67\95\79\110\68\114\105\118\101\114\83\116\97\116\117\115\41\116\104\101\110\32\68\67\95\79\110\68\114\105\118\101\114\83\116\97\116\117\115\40\110\69\56\48\104\109\44\79\56\41\101\110\100\32\101\110\100\59\105\102\40\120\73\84\85\103\108\66\88\88\106\126\61\83\49\105\114\41\116\104\101\110\32\108\111\99\97\108\32\72\69\74\68\121\116\61\82\48\52\88\74\95\122\115\91\49\52\55\93\108\111\99\97\108\32\119\75\89\67\52\100\120\78\78\95\103\86\100\84\79\61\82\48\52\88\74\95\122\115\91\49\52\54\93\105\102\40\83\49\105\114\61\61\82\48\52\88\74\95\122\115\91\49\57\52\93\41\116\104\101\110\32\72\69\74\68\121\116\61\82\48\52\88\74\95\122\115\91\49\57\53\93\68\65\95\69\118\95\50\118\68\79\85\40\72\69\74\68\121\116\44\119\75\89\67\52\100\120\78\78\95\103\86\100\84\79\41\101\108\115\101\105\102\40\83\49\105\114\60\82\48\52\88\74\95\122\115\91\49\52\54\93\41\116\104\101\110\32\105\102\40\120\73\84\85\103\108\66\88\88\106\61\61\82\48\52\88\74\95\122\115\91\49\52\54\93\41\116\104\101\110\32\72\69\74\68\121\116\61\82\48\52\88\74\95\122\115\91\49\57\54\93\119\75\89\67\52\100\120\78\78\95\103\86\100\84\79\61\40\83\49\105\114\42\45\82\48\52\88\74\95\122\115\91\49\57\52\93\41\68\65\95\69\118\95\50\118\68\79\85\40\72\69\74\68\121\116\44\119\75\89\67\52\100\120\78\78\95\103\86\100\84\79\41\72\69\74\68\121\116\61\82\48\52\88\74\95\122\115\91\49\57\55\93\68\65\95\69\118\95\50\118\68\79\85\40\72\69\74\68\121\116\44\119\75\89\67\52\100\120\78\78\95\103\86\100\84\79\41\101\110\100\32\101\108\115\101\32\105\102\40\120\73\84\85\103\108\66\88\88\106\60\82\48\52\88\74\95\122\115\91\49\52\54\93\41\116\104\101\110\32\72\69\74\68\121\116\61\82\48\52\88\74\95\122\115\91\49\57\56\93\68\65\95\69\118\95\50\118\68\79\85\40\72\69\74\68\121\116\44\119\75\89\67\52\100\120\78\78\95\103\86\100\84\79\41\101\110\100\59\72\69\74\68\121\116\61\82\48\52\88\74\95\122\115\91\49\57\57\93\68\65\95\69\118\95\50\118\68\79\85\40\72\69\74\68\121\116\44\119\75\89\67\52\100\120\78\78\95\103\86\100\84\79\41\101\110\100\32\101\110\100\32\101\110\100\59\102\117\110\99\116\105\111\110\32\68\67\46\80\114\111\112\101\114\116\121\85\112\100\97\116\101\40\104\121\56\71\82\106\78\95\72\80\55\98\71\105\44\105\114\55\55\57\89\90\41\105\102\40\105\114\55\55\57\89\90\61\61\82\48\52\88\74\95\122\115\91\51\93\111\114\32\105\114\55\55\57\89\90\61\61\82\48\52\88\74\95\122\115\91\49\52\55\93\41\116\104\101\110\32\105\114\55\55\57\89\90\61\104\121\56\71\82\106\78\95\72\80\55\98\71\105\32\101\110\100\59\105\102\40\68\67\95\70\68\61\61\82\48\52\88\74\95\122\115\91\54\93\41\116\104\101\110\32\67\52\58\85\112\100\97\116\101\80\114\111\112\101\114\116\121\40\82\48\52\88\74\95\122\115\91\50\48\48\93\44\104\121\56\71\82\106\78\95\72\80\55\98\71\105\41\101\108\115\101\32\67\52\58\85\112\100\97\116\101\80\114\111\112\101\114\116\121\40\82\48\52\88\74\95\122\115\91\50\48\49\93\44\105\114\55\55\57\89\90\41\101\110\100\32\101\110\100\59\102\117\110\99\116\105\111\110\32\68\67\46\84\105\109\101\114\40\41\68\67\46\116\61\67\52\58\83\101\116\84\105\109\101\114\40\68\67\46\80\84\44\102\117\110\99\116\105\111\110\40\78\101\53\79\55\85\107\108\41\68\67\46\67\104\101\99\107\67\108\111\117\100\40\41\101\110\100\44\82\48\52\88\74\95\122\115\91\54\93\41\101\110\100\59\102\117\110\99\116\105\111\110\32\68\67\46\67\104\101\99\107\67\108\111\117\100\40\41\108\111\99\97\108\32\77\48\49\102\70\53\76\61\67\52\58\71\101\116\68\101\118\105\99\101\115\66\121\67\52\105\78\97\109\101\40\82\48\52\88\74\95\122\115\91\50\48\50\93\41\105\102\40\77\48\49\102\70\53\76\41\116\104\101\110\32\108\111\99\97\108\32\76\76\107\112\71\110\90\107\121\61\82\48\52\88\74\95\122\115\91\49\52\54\93\102\111\114\32\89\68\115\87\102\67\116\77\56\71\32\105\110\32\112\97\105\114\115\40\77\48\49\102\70\53\76\41\100\111\32\76\76\107\112\71\110\90\107\121\61\76\76\107\112\71\110\90\107\121\43\82\48\52\88\74\95\122\115\91\49\57\52\93\101\110\100\59\105\102\40\76\76\107\112\71\110\90\107\121\61\61\68\67\46\71\95\67\111\117\110\116\41\116\104\101\110\32\114\101\116\117\114\110\32\101\110\100\59\68\67\46\71\95\67\111\117\110\116\61\76\76\107\112\71\110\90\107\121\59\105\102\40\76\76\107\112\71\110\90\107\121\61\61\82\48\52\88\74\95\122\115\91\49\57\52\93\41\116\104\101\110\32\102\111\114\32\69\112\89\86\101\121\95\54\99\55\107\103\107\71\53\44\74\102\71\54\82\114\109\85\105\32\105\110\32\112\97\105\114\115\40\77\48\49\102\70\53\76\41\100\111\32\68\67\46\67\73\68\61\69\112\89\86\101\121\95\54\99\55\107\103\107\71\53\32\101\110\100\59\67\52\58\83\101\116\80\114\111\112\101\114\116\121\65\116\116\114\105\98\115\40\82\48\52\88\74\95\122\115\91\50\48\51\93\44\82\48\52\88\74\95\122\115\91\49\52\54\93\41\105\102\40\68\67\46\88\61\61\82\48\52\88\74\95\122\115\91\49\52\54\93\41\116\104\101\110\32\68\67\46\80\114\111\112\101\114\116\121\85\112\100\97\116\101\40\82\48\52\88\74\95\122\115\91\50\48\52\93\41\68\67\46\67\104\101\99\107\105\110\40\41\101\110\100\32\101\108\115\101\105\102\40\76\76\107\112\71\110\90\107\121\60\82\48\52\88\74\95\122\115\91\49\57\52\93\41\116\104\101\110\32\68\67\46\88\61\82\48\52\88\74\95\122\115\91\49\52\54\93\68\67\46\80\114\111\112\101\114\116\121\85\112\100\97\116\101\40\82\48\52\88\74\95\122\115\91\50\48\53\93\44\82\48\52\88\74\95\122\115\91\50\48\54\93\41\67\52\58\83\101\116\80\114\111\112\101\114\116\121\65\116\116\114\105\98\115\40\82\48\52\88\74\95\122\115\91\50\48\55\93\44\82\48\52\88\74\95\122\115\91\49\57\52\93\41\68\67\46\67\73\68\61\82\48\52\88\74\95\122\115\91\51\93\105\102\40\68\67\46\80\84\126\61\82\48\52\88\74\95\122\115\91\49\54\50\93\41\116\104\101\110\32\68\67\46\80\84\61\82\48\52\88\74\95\122\115\91\49\54\50\93\68\67\46\116\58\67\97\110\99\101\108\40\41\68\67\46\84\105\109\101\114\40\41\101\110\100\32\101\108\115\101\105\102\40\76\76\107\112\71\110\90\107\121\62\82\48\52\88\74\95\122\115\91\49\57\52\93\41\116\104\101\110\32\68\67\46\88\61\82\48\52\88\74\95\122\115\91\49\52\54\93\68\67\46\80\114\111\112\101\114\116\121\85\112\100\97\116\101\40\82\48\52\88\74\95\122\115\91\50\48\56\93\41\67\52\58\83\101\116\80\114\111\112\101\114\116\121\65\116\116\114\105\98\115\40\82\48\52\88\74\95\122\115\91\50\48\57\93\44\82\48\52\88\74\95\122\115\91\49\57\52\93\41\68\67\46\67\73\68\61\82\48\52\88\74\95\122\115\91\51\93\105\102\40\68\67\46\80\84\126\61\82\48\52\88\74\95\122\115\91\49\54\50\93\41\116\104\101\110\32\68\67\46\80\84\61\82\48\52\88\74\95\122\115\91\49\54\50\93\68\67\46\116\58\67\97\110\99\101\108\40\41\68\67\46\84\105\109\101\114\40\41\101\110\100\32\101\110\100\32\101\110\100\32\101\110\100\59\102\117\110\99\116\105\111\110\32\68\67\46\67\104\101\99\107\105\110\40\41\108\111\99\97\108\32\112\49\82\71\76\48\76\108\84\111\101\83\70\74\65\115\67\76\53\61\67\52\58\71\101\116\68\114\105\118\101\114\67\111\110\102\105\103\73\110\102\111\40\82\48\52\88\74\95\122\115\91\50\49\48\93\41\108\111\99\97\108\32\89\68\85\114\53\121\105\109\112\110\57\87\108\53\79\51\85\86\83\108\61\82\48\52\88\74\95\122\115\91\51\93\108\111\99\97\108\32\108\112\74\112\75\118\79\48\79\101\81\77\61\68\67\46\84\67\40\41\105\102\40\80\114\111\112\101\114\116\105\101\115\91\82\48\52\88\74\95\122\115\91\50\49\49\93\93\41\116\104\101\110\32\105\102\40\80\114\111\112\101\114\116\105\101\115\91\82\48\52\88\74\95\122\115\91\50\49\50\93\93\61\61\82\48\52\88\74\95\122\115\91\50\49\51\93\41\116\104\101\110\32\89\68\85\114\53\121\105\109\112\110\57\87\108\53\79\51\85\86\83\108\61\82\48\52\88\74\95\122\115\91\50\49\52\93\101\108\115\101\105\102\40\80\114\111\112\101\114\116\105\101\115\91\82\48\52\88\74\95\122\115\91\50\49\53\93\93\61\61\82\48\52\88\74\95\122\115\91\50\49\54\93\41\116\104\101\110\32\89\68\85\114\53\121\105\109\112\110\57\87\108\53\79\51\85\86\83\108\61\82\48\52\88\74\95\122\115\91\50\49\55\93\101\108\115\101\32\89\68\85\114\53\121\105\109\112\110\57\87\108\53\79\51\85\86\83\108\61\82\48\52\88\74\95\122\115\91\50\49\56\93\101\110\100\32\101\108\115\101\32\89\68\85\114\53\121\105\109\112\110\57\87\108\53\79\51\85\86\83\108\61\82\48\52\88\74\95\122\115\91\50\49\57\93\101\110\100\59\68\67\46\83\111\99\107\101\116\40\82\48\52\88\74\95\122\115\91\50\50\48\93\44\123\80\73\68\61\68\67\95\80\73\68\44\68\73\68\61\68\67\46\68\73\68\44\86\69\82\61\112\49\82\71\76\48\76\108\84\111\101\83\70\74\65\115\67\76\53\44\65\85\61\89\68\85\114\53\121\105\109\112\110\57\87\108\53\79\51\85\86\83\108\44\84\67\61\108\112\74\112\75\118\79\48\79\101\81\77\44\84\84\61\68\67\95\84\84\44\68\67\75\61\90\75\111\69\107\66\125\41\101\110\100\59\102\117\110\99\116\105\111\110\32\68\67\46\83\111\99\107\101\116\40\90\110\95\77\54\95\111\95\110\99\110\120\117\44\105\119\106\76\97\74\88\70\73\85\81\69\98\121\95\41\105\102\40\68\67\46\67\73\68\61\61\82\48\52\88\74\95\122\115\91\51\93\41\116\104\101\110\32\114\101\116\117\114\110\32\101\110\100\59\108\111\99\97\108\32\76\109\80\107\117\74\97\103\104\110\61\123\99\109\100\61\90\110\95\77\54\95\111\95\110\99\110\120\117\44\116\80\97\114\97\109\115\61\105\119\106\76\97\74\88\70\73\85\81\69\98\121\95\125\108\111\99\97\108\32\120\72\117\66\107\57\119\61\74\83\79\78\58\101\110\99\111\100\101\40\76\109\80\107\117\74\97\103\104\110\41\108\111\99\97\108\32\97\49\98\61\67\52\58\69\110\99\114\121\112\116\40\82\48\52\88\74\95\122\115\91\50\50\49\93\44\90\75\111\69\107\66\44\82\48\52\88\74\95\122\115\91\51\93\44\120\72\117\66\107\57\119\44\123\91\82\48\52\88\74\95\122\115\91\50\50\50\93\93\61\82\48\52\88\74\95\122\115\91\50\50\51\93\125\41\67\52\58\83\101\110\100\84\111\68\101\118\105\99\101\40\68\67\46\67\73\68\44\82\48\52\88\74\95\122\115\91\50\50\52\93\44\123\109\115\103\61\97\49\98\125\41\101\110\100\59\108\111\99\97\108\32\98\80\122\55\110\97\110\72\115\78\66\112\100\102\61\115\116\114\105\110\103\46\103\115\117\98\40\114\109\46\46\95\121\90\75\122\87\88\108\99\67\108\114\50\112\80\49\32\46\46\95\114\88\44\82\48\52\88\74\95\122\115\91\50\50\53\93\44\82\48\52\88\74\95\122\115\91\49\52\55\93\41\102\117\110\99\116\105\111\110\32\68\67\46\83\117\112\112\111\114\116\40\114\79\84\44\105\115\81\103\49\99\79\76\41\108\111\99\97\108\32\101\70\97\111\74\85\101\100\102\71\107\53\61\82\48\52\88\74\95\122\115\91\50\50\54\93\108\111\99\97\108\32\70\120\122\56\77\61\40\68\67\95\80\73\68\32\111\114\32\82\48\52\88\74\95\122\115\91\49\52\54\93\41\108\111\99\97\108\32\87\117\50\99\73\51\78\76\61\40\67\52\58\71\101\116\68\101\118\105\99\101\68\105\115\112\108\97\121\78\97\109\101\40\82\48\52\88\74\95\122\115\91\49\57\52\93\41\111\114\32\82\48\52\88\74\95\122\115\91\50\50\55\93\41\108\111\99\97\108\32\75\51\77\53\86\121\110\99\86\109\103\79\116\61\68\67\46\71\101\116\85\110\105\113\117\101\77\65\67\40\41\108\111\99\97\108\32\84\113\76\49\115\112\56\86\68\55\77\115\78\61\82\48\52\88\74\95\122\115\91\50\50\56\93\108\111\99\97\108\32\103\84\71\50\117\84\49\103\61\67\52\58\72\77\65\67\40\82\48\52\88\74\95\122\115\91\50\50\57\93\44\84\113\76\49\115\112\56\86\68\55\77\115\78\44\75\51\77\53\86\121\110\99\86\109\103\79\116\46\46\101\70\97\111\74\85\101\100\102\71\107\53\41\108\111\99\97\108\32\113\99\85\110\102\82\85\101\105\82\115\61\115\116\114\105\110\103\46\102\111\114\109\97\116\40\82\48\52\88\74\95\122\115\91\50\51\48\93\44\103\84\71\50\117\84\49\103\44\75\51\77\53\86\121\110\99\86\109\103\79\116\44\101\70\97\111\74\85\101\100\102\71\107\53\44\105\115\81\103\49\99\79\76\44\87\117\50\99\73\51\78\76\44\70\120\122\56\77\44\114\79\84\41\67\52\58\117\114\108\80\111\115\116\40\82\48\52\88\74\95\122\115\91\50\51\49\93\44\113\99\85\110\102\82\85\101\105\82\115\44\123\125\44\82\48\52\88\74\95\122\115\91\54\57\93\41\101\110\100\59\108\111\99\97\108\32\110\122\48\54\75\88\106\84\103\111\120\51\75\105\88\52\49\121\75\84\82\61\115\116\114\105\110\103\46\103\115\117\98\40\98\80\122\55\110\97\110\72\115\78\66\112\100\102\44\82\48\52\88\74\95\122\115\91\50\51\50\93\44\82\48\52\88\74\95\122\115\91\49\52\55\93\41\102\117\110\99\116\105\111\110\32\68\67\46\71\101\116\85\110\105\113\117\101\77\65\67\40\41\108\111\99\97\108\32\101\105\61\97\115\115\101\114\116\40\105\111\46\112\111\112\101\110\40\82\48\52\88\74\95\122\115\91\50\51\51\93\44\82\48\52\88\74\95\122\115\91\50\51\52\93\41\41\114\101\116\117\114\110\32\115\116\114\105\110\103\46\115\117\98\40\101\105\58\114\101\97\100\40\82\48\52\88\74\95\122\115\91\50\51\53\93\41\44\82\48\52\88\74\95\122\115\91\49\52\54\93\44\45\82\48\52\88\74\95\122\115\91\50\51\54\93\41\101\110\100\59\102\117\110\99\116\105\111\110\32\68\67\46\84\67\40\41\114\101\116\117\114\110\40\115\111\99\107\101\116\46\103\101\116\116\105\109\101\40\41\41\101\110\100')() end)
package.preload['SKC4.Utility'] = (function (...)
local Utility = {}

function Utility.callAllFunctionsInTable(tbl)
	ret_err = {}
	ret_status = true
	for k,v in pairs(tbl) do
		if (tbl[k] ~= nil and type(tbl[k]) == "function") then
			-- 
			if (SKC4_LOGGER ~= nil and type(SKC4_LOGGER) == "table") then
				SKC4_LOGGER:debug("Calling  " .. k .. "()")
			end
			local status, err = pcall(tbl[k])
			if (not status) then
				ret_err[k] = {status=status, err=err}
			end
		end
	end
	return ret_status, ret_err
end

--remove the first element of a list
function Utility.remove(tbl, index)
	if (index == nil ) then index = 1 end
	local a = {}
	--local b = {}
	--local c
	for n,v in pairs(tbl) do 
		table.insert(a, n) 
	end
	table.sort(a)
	local f = nil
	local o = {}
	for i, t in pairs(a) do
		if (f == nil) then 
			f = tbl[t]
		else
			table.insert(o, tbl[t])
		end
	end
	 --Utility.tprint(b)
	return o, f
end

function Utility.tprint (tbl, indent)  --print table
	if type(tbl) == "table" then
		if not indent then indent = 0 end
		for k, v in pairs(tbl) do
			formatting = string.rep("   ", indent) .. k .. ": "
			if type(v) == "table" then
				print(formatting)
				Utility.tprint(v, indent+1)
			else
				print(formatting .. tostring(v, indent))
			end
		end
	else
		print (tbl)
	end
end

function Utility.tstring (tbl, indent) -- transform table in string, nested
	--ritorna una stringa contenente i valori della table
    --if indent is -1 return a table in one line string
	local  mytable = ""
	if indent == nil then indent = 0 end
	if (type(tbl) == "table") then
		if (indent == -1) then 
			for k,v in pairs(tbl) do
				if type(v) == "table" then
					mytable = mytable .. " "..Utility.tstring(v, -1)
				else
					mytable = mytable ..k.. " " .. tostring(v) 
				end
			end
		elseif(type(indent) == "number") then
			for k, v in pairs(tbl) do
				formatting = string.rep("   ", indent) .. k .. " : "
				if type(v) == "table" then
					mytable = mytable .. "\n"..formatting
					mytable = mytable .."\n"..Utility.tstring(v, indent+1)
				else
					mytable = mytable .. formatting .. tostring(v) .." \n"
				end
			end
		elseif(type(indent) == "string") then
			for k, v in pairs(tbl) do
				--formatting = string.rep("   ", indent) .. k .. " : "
				if type(v) == "table" then
					formatting = indent .. k
					mytable = mytable .. formatting
					mytable = mytable .. Utility.tstring(v, indent)
				else
					mytable = mytable ..indent .. tostring(v)
				end
				
			end
			mytable = mytable .."\n"
		end
	else 
		mytable = tbl
	end
	return mytable
end



--get the "very" first element of a Table... let's lua, not only if is key is a number like getn
function Utility.getFirstId(T)
	if (T == nil) then
		return {}
	else  
		local n  = 1
		local f
		for k, v in pairs(T) do
			if n == 1 then f = k end
		end
		return f
	end
end

function Utility.tableLength(T)
	local count = 0
	for _ in pairs(T) do count = count + 1 end
	return count
  end

--take "str" (string) and slpit it by "inSplitPattern" returning a table of the substring splitted in "outResults"(optional)
function Utility.split(str, inSplitPattern, outResults ) 
    if not outResults then
		outResults = {}
	end
	local theStart = 1
	local theSplitStart, theSplitEnd = string.find( str, inSplitPattern, theStart )
	while theSplitStart do
		table.insert( outResults, string.sub( str, theStart, theSplitStart-1 ) )
		theStart = theSplitEnd + 1
		theSplitStart, theSplitEnd = string.find( str, inSplitPattern, theStart )
	end
	table.insert( outResults, string.sub( str, theStart ) )
	return outResults
end


function Utility.Avg_DevStd(value, stddev, avg, n)
    local delta = value - avg
    n = n+1
    avg = avg + delta / n 
    stddev = math.sqrt(((stddev*stddev * (n-1)) + delta*(value - avg))/n)
    return stddev, avg, n 
end

-- Private members
function pairsByKeys (t, f)
	local a = {}
	for n in pairs(t) do table.insert(a, n) end
	table.sort(a, f)
	local i = 0      -- iterator variable
	local iter = function ()   -- iterator function
	  i = i + 1
	  if a[i] == nil then return nil
	  else return a[i], t[a[i]]
	  end
	end
	return iter
end



return Utility



 end)
package.preload['SKC4.Logger'] = (function (...)
-- Modulo per gestire i file di log

local Logger = {}

Utility = require "SKC4.Utility"

function Logger:new (o)
    o = o or {}
    setmetatable(o, self)
    self.__index = self
    self.logLevels = {
        ["FATAL"] = "F",
        ["ERROR"] = "EF",
        ["INFO"] = "IEF",
        ["WARN"] = "WIEF",
        ["DEBUG"] = "DWIEF",
        ["ONLY_INFO"] = "I",
        ["ONLY_WARN"] = "W",
        ["ONLY_ERROR"] = "E",
        ["ONLY_FATAL"] = "F",
        ["ONLY_DEBUG"] = "D",
        ["NONE"] = "-",
        ["ALL"]  = "IWEFD",
      }
      
    self._DEFAULT_OUTPUT_FORMAT     = "%s %s:%s -- %s\n"
    self._DEFAULT_FILE_NAME_FORMAT  = "%s_%s.log"    
    self._DEFAULT_DATE_FORMAT       = "%Y%m%d%H%M%S"

    self._DEFAULT_FILE_POINTER      = io.stdio
    self._DEFAULT_FILE_NAME         = nil
    self._DEFAULT_FILE_PATH         = nil 
    self._DEFAULT_MAX_FILES         = 0
    
    self._currentMaxNumberOfFIles   = self._DEFAULT_MAX_FILES
    self._currentFilePointer        = self._DEFAULT_FILE_POINTER
    self._currentFilePath           = self._DEFAULT_FILE_PATH
    self._currentFileName           = self._DEFAULT_FILE_NAME
    self._currentLogLevel           = self.logLevels.INFO
    self._currentOutputFormat       = self._DEFAULT_OUTPUT_FORMAT
    self._currentFileNameFormat     = self._DEFAULT_FILE_NAME_FORMAT
    self._currentLogMaxSize         = 2097152 -- 2MB

    self._write_on_c4_logfile       = false
    return o
end

function Logger:findLevelKey(level)
  for k,v in pairs(self.logLevels) do
    if (v == level) then
      return k
    end
  end
  return nil
end

function Logger:write(message)
    
    if (self._currentFilePointer ~= nil and self._currentFilePointer ~= self._DEFAULT_FILE_POINTER) then
        self:rotate()
        C4:FileWrite(self._currentFilePointer,message:len(), message)
    end

    if self:isC4FileLoggingEnabled() then
        C4:DebugLog(message) -- print out on Director log files

        if ( self:isLogLevelEnabled(self.logLevels.ONLY_ERROR) or self:isLogLevelEnabled(self.logLevels.ONLY_FATAL) ) then
            C4:ErrorLog(message) 
        end 
    end
    
    print(message)    -- print out on Composer Lua Tab
    
    return message
end

function Logger:formattedWrite(level, ...)
    local fullLevel = self:findLevelKey(level)
    local info = debug.getinfo(3,'lS');

    local message = ""
    
    -- convert all params into strings
    for index = 1, arg.n do
        local val = arg[index]
    
        if (message.length == 0) then
            message = self:convertToString(val)
        else
            message = message .." "..self:convertToString(val)
        end
    end
    local outString = string.format(self._currentOutputFormat,
        fullLevel,
        info.source,
        info.currentline,
        message)
    return self:write(outString)
end

function Logger:convertToString(obj)
    
    if (type(obj) == "table") then
        return Utility.tstring(obj, 0)
    else
        return tostring(obj)
    end
end

function Logger:setLogLevel(level)
  local flag = true
  
  for x in level:gfind(".") do
    key = self:findLevelKey(x)
    self._currentLogLevel = self.logLevels.NONE;
    if (self.logLevels[key] == nil) then flag = false; break; end
  end
  if ( flag == true ) then
      self._currentLogLevel = level
  end

end

function Logger:getLogLevel(level)
    return self._currentLogLevel;
end

function Logger:isLogLevelEnabled(level)
  return (self._currentLogLevel:find(level) ~= nil) 
end

function Logger:isLoggingEnabled()
    return not self:isLogLevelEnabled(self.logLevels.NONE)
end

function Logger:disableLogging()
    self:setLogLevel(self.logLevels.NONE)
end

function Logger:enableInfoLevel()
    self:setLogLevel(self.logLevels.INFO)
end

function Logger:enableWarningLevel()
    self:setLogLevel(self.logLevels.WARN)
end

function Logger:enableErrorLevel()
    self:setLogLevel(self.logLevels.ERROR)
end

function Logger:enableFatalLevel()
    self:setLogLevel(self.logLevels.FATAL)
end

function Logger:enableDebugLevel()
    self:setLogLevel(self.logLevels.DEBUG)
end

function Logger:enableC4FileLogging()
    self._write_on_c4_logfile = true
end

function Logger:disableC4FileLogging()
    self._write_on_c4_logfile = false
end

function Logger:isC4FileLoggingEnabled()
    return self._write_on_c4_logfile
end

function Logger:open(filePath, fileName)
  self._currentFilePath = filePath
  self._currentFileName = fileName 
  
  C4:FileSetDir(self._currentFilePath)  --move in file path folder

  logFileName = string.format(self._currentFileNameFormat, fileName, os.date(self._DEFAULT_DATE_FORMAT));
  -- Open the file
  self._currentFilePointer = C4:FileOpen(logFileName)
  local pos = C4:FileGetSize(self._currentFilePointer)
  C4:FileSetPos(self._currentFilePointer, pos)

  C4:FileSetDir('/')
  return self._currentFilePointer, logFileName
end

function Logger:close()
    -- only if a file is open
  if (self._currentFilePointer ~= self._DEFAULT_FILE_POINTER) then
    
    -- Close the file
    if (self._currentFilePointer ~= nil) then
        C4:FileClose(self._currentFilePointer)
        --self._currentFilePointer:close()
        self._currentFilePointer = self._DEFAULT_FILE_POINTER
        self._currentFilePath = nil
        self._currentFileName = nil
    end
  end
end

function Logger:info(source, ...)
    if (self:isLogLevelEnabled(self.logLevels.ONLY_INFO)) then
        return self:formattedWrite(self.logLevels.INFO, source, ...);
    end 
end

function Logger:warn(source, ...)
    if (self:isLogLevelEnabled(self.logLevels.ONLY_WARN)) then
        return self:formattedWrite(self.logLevels.WARN, source, ...);
    end 
end

function Logger:error(source, ...)
    if (self:isLogLevelEnabled(self.logLevels.ONLY_ERROR)) then
        return self:formattedWrite(self.logLevels.ERROR, source, ...);
    end 
end

function Logger:fatal(source, ...)
    if (self:isLogLevelEnabled(self.logLevels.ONLY_FATAL)) then
        return self:formattedWrite(self.logLevels.FATAL, source, ...);
    end 
end

function Logger:debug(source, ...)
    if (self:isLogLevelEnabled(self.logLevels.ONLY_DEBUG)) then
        return self:formattedWrite(self.logLevels.DEBUG, source, ...);
    end 
end

function Logger:setMaxLogSize( size )
  self._currentLogMaxSize = size
end

function Logger:setMaxLoggersNumber( number )
    self._currentMaxNumberOfFIles = number
  end

function Logger:getMaxLogSize()
  return self._currentLogMaxSize
end

function Logger:getFilePointer()
    return self._currentFilePointer
end

function Logger:getFilePath()
    return self._currentFilePath
end

function Logger:getFileName()
    return self._currentFileName
end

function Logger:rotate(force)
    if (self._currentFilePointer ~= self._DEFAULT_FILE_POINTER) then
        local fileSize = C4:FileGetSize(self._currentFilePointer)
        
        if (self._currentMaxNumberOfFIles ~= self._DEFAULT_MAX_FILES) then 
            local loggersNumber = self:getLoggersNumber()
            print ("loggersNumber", loggersNumber)
            while (loggersNumber >= self._currentMaxNumberOfFIles) do
                print ("loggersNumber >= self._currentMaxNumberOfFIles",loggersNumber >= self._currentMaxNumberOfFIles)
                self:removeFirst()
                loggersNumber = self:getLoggersNumber()
            end
        end
        if (force ~= nil or tonumber(fileSize) > self._currentLogMaxSize) then
            local oldPath = self._currentFilePath -- store old value 'cause close() clear _currentFilePath
            local oldName = self._currentFileName -- store old value 'cause close() clear _currentFileName
            self:close() 
            return self:open(oldPath,oldName)
        else
            return self._currentFilePointer, self._currentFilePath, self._currentFileName
        end
    end
end

--private
function Logger:getLoggersNumber()    
    C4:FileSetDir(self._currentFilePath)
    local loggerList = C4:FileList()
    local count = 0
    for k,v in pairs(loggerList) do
        ----print (k,v) 
        if (string.match(v, self._currentFileName)) then 
            ----print (string.match(v, self._currentFileName))
            count = count + 1 
        end
    end
    C4:FileSetDir("/")
    return count 
end

function Logger:removeFirst()    
    C4:FileSetDir(self._currentFilePath)
    local loggerList = C4:FileList()
    local count = 0
    ----------------20171204114408
    local minimum = 30000000000000
    local fileToRemove = ""
    for k,v in pairs(loggerList) do 
        if (string.match(v, self._currentFileName)) then 
            ----print (string.match(v, self._currentFileName))
            local n = tonumber(string.match (v, "(%d+)"))
            ----print ("n:  ", n)
            ----print ("file:  ", v)
            if ( n < minimum ) then 
                minimum = n
                fileToRemove = v 
            end
        end
    end

    ----print (fileToRemove, minimum)
    if (fileToRemove ~= "") then  
        print("deleting logger :",fileToRemove)
        C4:FileDelete(fileToRemove) 
    end
    C4:FileSetDir("/")
    return count 
end

LOGGER = LOGGER or Logger:new()

return Logger;

 end)
package.preload['SKC4.TimerManager'] = (function (...)
--C4 = require 'SKC4.C4' -- if we are not in C4 env, I'll emulate it
local TimerManager = {}


function TimerManager:new (interval_delay, time_unit, on_expire_callback, will_repeat, o)
    o = o or {}
    setmetatable(o, self)
    self.__index = self

    self.interval_delay = interval_delay
    self.callback = on_expire_callback
    self.will_repeat = will_repeat
    self.timerObj = nil
    -- , SECONDS, MINUTES and HOURS
    if (time_unit == "SECONDS") then
        self.time_unit = 1000
    elseif (time_unit == "MINUTES") then
        self.time_unit = 60*1000
    elseif (time_unit == "HOURS") then
        self.time_unit = 60*60*1000
    else
        self.time_unit = 1
    end 
    return o
end

function TimerManager:start()
    if (self.timerObj) then
        self:stop()
    end
    self.timerObj = C4:SetTimer(self.interval_delay * self.time_unit, self.callback, self.will_repeat)
end

function TimerManager:stop()
    if (self.timerObj) then
        --self.timerObj = C4:KillTimer(self.timerObj)
        self.timerObj:Cancel()
        self.timerObj = nil
    end
end

--
-- Setter and Getter
--


--
-- Private functions
--


return TimerManager
 end)
package.preload['SKC4.LicenseManager'] = (function (...)
local TimerManager = require "SKC4.TimerManager"
local Logger = require "SKC4.Logger"
local Utility = require("SKC4.Utility")

local LicenseManager = {}

-- global var required by DriverCentral
DC_PID = 0 -- Product ID
DC_FD = false -- DriverCentral (Driver is not a free driver)
DC_FILENAME = "" -- "my_driver.c4z"

LicenseManager.TRIAL_NOT_STARTED = -1
LicenseManager.TRIAL_STARTED = 1
LicenseManager.TRIAL_EXPIRED = 0

function LicenseManager:new(o)
    o = o or {}
    setmetatable(o, self)
    self.__index = self
    self.currentVendorId = "DRIVERCENTRAL"
    self.statusMessage = ""
    self.vendorData = {
        DRIVERCENTRAL 	= { 
            ProductId 	= 000, -- Product ID
            FreeDriver 	= false, -- (Driver is not a free driver)
            FileName    = ""
        },
        DEBUG     = { 
            LicenseCode = "",
            Licensed = true
        }
    }


    self.OnPropertyChangedTable = {}

    
    return o
end

--
-- Setter and Getter
--


function LicenseManager:setStatusMessage( message )
    self.statusMessage = message
end

function LicenseManager:getStatusMessage()
    return self.statusMessage
end

function LicenseManager:setCurrentVendorId(vendor_id)
    self.currentVendorId = vendor_id
    
    if vendor_id == "DRIVERCENTRAL" then
        LOGGER:info("DRIVERCENTRAL vendor setted")
        C4:SetPropertyAttribs("Cloud Status", 0)
        C4:SetPropertyAttribs("Automatic Updates", 0)
    elseif vendor_id == "DEBUG" then
        LOGGER:info("DEBUG vendor setted")
        C4:SetPropertyAttribs("Cloud Status", 1)
        C4:SetPropertyAttribs("Automatic Updates", 1)
    else
        LOGGER:info("UNKNOW vendor setted")
        C4:SetPropertyAttribs("Cloud Status", 1)
        C4:SetPropertyAttribs("Automatic Updates", 1)
        
    end

    self.updatePersistData()

end
function LicenseManager:getCurrentVendorId()
    return self.currentVendorId
end

function LicenseManager:getCurrentVendorName()
    local id = self:getCurrentVendorId()

    if (id == "DRIVERCENTRAL") then
        return "Driver Central"
    elseif (id == "DEBUG") then
        return "Debug"
    else
        return "Unknown"
    end
end
function LicenseManager:setCurrentVendorIdByName(value)
    if (value == "Driver Central") then
        self:setCurrentVendorId("DRIVERCENTRAL")
    elseif (value == "Debug") then
        self:setCurrentVendorId("DEBUG")
    end
end

function LicenseManager:setParamValue(param_key, param_value, vendor_id)

    if (vendor_id) then
        LOGGER:debug("LicenseManager:setParamValue", "with vendor_id:", vendor_id)
        self.vendorData[vendor_id][param_key] = param_value
    else
        LOGGER:debug("LicenseManager:setParamValue", "with automagic:", vendor_id)
        local autoVendorId = self:getCurrentVendorId()
        self.vendorData[autoVendorId][param_key] = param_value
    end
    self.updatePersistData()
    

end
function LicenseManager:getParamValue(param_key, vendor_id)
    if (vendor_id) then
        return self.vendorData[vendor_id][param_key]
    else
        return self.vendorData[self:getCurrentVendorId()][param_key]
    end
end

--
-- Functions to test licence validity
--
function LicenseManager:isLicenseActive()
    if self:getCurrentVendorId() == "DRIVERCENTRAL" then
        return (DC.X == 1)
    elseif self:getCurrentVendorId() == "DEBUG" then
        return true
    else
        return false
    end
end
function LicenseManager:isLicenseTrial()
    if self:getCurrentVendorId() == "DRIVERCENTRAL" then
        return (DC.X < 0)
    else
        return false
    end
end

function LicenseManager:isLicenseActiveOrTrial()
    return self:isLicenseActive() or self:isLicenseTrial()
end

function LicenseManager:isAbleToWork()
	if self:getCurrentVendorId() == "DRIVERCENTRAL" then
		local lic = self:isLicenseActive()
		local trial = self:isLicenseTrial()
		return lic or trial
    elseif self:getCurrentVendorId() == "DEBUG" then
        return true
	end
end


function LicenseManager:restoreFromPersistData()
    LICENSE_MGR.vendorData = C4:PersistGetValue("vendorData") or LICENSE_MGR.vendorData
    LICENSE_MGR.currentVendorId = C4:PersistGetValue("currentVendorId") or LICENSE_MGR.currentVendorId
    LOGGER:debug("LicenseManager:restoreFromPersistData", "currentVendorId:", self.currentVendorId)
end

function LicenseManager:updatePersistData()
    LOGGER:debug("LicenseManager:updatePersistData")
    C4:PersistSetValue("vendorData", LICENSE_MGR.vendorData)
    C4:PersistSetValue("currentVendorId", LICENSE_MGR.currentVendorId)
end


--
-- C4 Enviroment hooks
--

function LicenseManager:OnDriverInit()
    LOGGER:debug("LicenseManager:OnDriverInit")
    
    self:OnDriverInit_DriverCentral()    
    
    C4:SetPropertyAttribs("Cloud Status", 1)
    C4:SetPropertyAttribs("Automatic Updates", 1)

    --for k,v in pairs(Properties) do
	--	C4:ErrorLog("INIT_CODE: Calling OnPropertyChanged - " .. k .. ": " .. v)
	--	local status, err = pcall(OnPropertyChanged, k)
	--	if (not status) then
	--		C4:ErrorLog("LUA_ERROR: " .. err)
	--	end
	--end
    
end

function LicenseManager:OnDriverLateInit()
    LOGGER:debug("LicenseManager:OnDriverLateInit")
    
    self:restoreFromPersistData()
    
    
    self:OnDriverLateInit_DriverCentral()
    
    -- TOFIX: see end of file for definition
    FIX_FOR_DRIVERCENTRAL = TimerManager:new(1, "SECONDS", self.onFIX_FOR_DRIVERCENTRALTimerExpire, false)
    FIX_FOR_DRIVERCENTRAL:start()

end

-- TOFIX: DriverCentral re-enable AutoUpdate asyc...
function LicenseManager:onFIX_FOR_DRIVERCENTRALTimerExpire()
    if LICENSE_MGR:getCurrentVendorId() ~= "DRIVERCENTRAL" then
        C4:SetPropertyAttribs("Automatic Updates", 1)
    end
end


function LicenseManager:ReceivedFromProxy(idBinding, sCommand, tParams)
end

function LicenseManager:OnPropertyChanged(strName)
    local propertyValue = Properties[strName]

    LOGGER:debug("LicenseManager:OnPropertyChanged.",strName, propertyValue, type(propertyValue))
	
    local funcToCall = LicenseManager.OnPropertyChangedTable[strName]
    
    if (funcToCall) then
        LOGGER:debug("LicenseManager:OnPropertyChanged -> funcToCall",funcToCall, type(funcToCall))
        funcToCall(self,propertyValue)
    else
        LOGGER:debug("LicenseManager:OnPropertyChanged: this property is not related to License")
    end
end

--
-- Vendor specific functions
--
function LicenseManager:OnDriverInit_DriverCentral()
    require "json"
	JSON=(loadstring(json.JSON_LIBRARY_CHUNK))()
    -- set global vars required by DriverCentral.io
    DC_PID = self:getParamValue("ProductId", "DRIVERCENTRAL") 
	DC_FD = self:getParamValue("FreeDriver", "DRIVERCENTRAL") 
    DC_FILENAME = self:getParamValue("FileName", "DRIVERCENTRAL") 
    
    require "SKC4.licence.cloud_client_v1007"
end
function LicenseManager:OnDriverLateInit_DriverCentral()
    -- do something...
end


LICENSE_MGR = LICENSE_MGR or LicenseManager:new()


return LicenseManager

 end)
package.preload['SKC4.Queue'] = (function (...)
local Queue = {}

function Queue:new(o)
  o = o or {}
  setmetatable(o, self)
  self.__index = self

  self._queue = {}
  self._first = 0
  self._last = -1
  return o
end

function Queue:push(object)
  local  key =  os.time(os.date('!*t'))
  local last = self._last + 1
  self._last = last
  self._queue[last] = {key = key, value = object}
end
function Queue:pop()
  if self:is_empty() then 
    return nil 
  end

  local first = self._first
  local item = self._queue[first]
  self._queue[first] = nil        -- to allow garbage collection
  self._first = first + 1
  return item.value
end

function Queue:push_by_key(key, object)
  local key_found = false
  -- look for existing item to update
  for i,item in pairs(self._queue) do
    if item.key == key then
      self._queue[i].value = object
      key_found = true
      break
    end
  end
  -- if no existing item, add it
  if (not key_found) then
    local last = self._last + 1
    self._last = last
    self._queue[last] = {key = key, value = object}
  end
end

function Queue:pop_by_key(key)
  if self:is_empty() then 
    return nil 
  end

  local returned_item = nil
  -- look for the item by key
  for i,item in pairs(self._queue) do
    if item.key == key then
      returned_item = item
    end

    -- if I found the item, strink the queue
    if returned_item then
      self._queue[i] = self._queue[i+1]
    end
  end

  -- if I found the item, reduce the lenght of queue
  if (returned_item) then
    local last = self._last
    self._queue[last] = nil
    self._last = last - 1
  end

  return returned_item
end

function Queue:size()
  local size = self._last - self._first + 1
  if size < 0 then
    size = 0
  end
  return size
end

function Queue:is_empty()
  return self:size() == 0
end

function Queue:empty()
  self._first = 0
  self._last = -1
  self._queue = {}
end

function Queue.self_test()
  if (SKC4_LOGGER) then 
  
    SKC4_LOGGER:debug(":new()")
    local q = {}
    q = Queue:new()
    SKC4_LOGGER:debug("q is not nil:", not (q == nil))

    SKC4_LOGGER:debug("...queue is empty", q:is_empty(), "[",q:size(),"]")
    q:push("ciccio1")
    SKC4_LOGGER:debug("...successfully pushed 1 element", q:size() == 1, "[",q:size(),"]")
    q:push("ciccio2")
    q:push("ciccio3")
    SKC4_LOGGER:debug("...successfully pushed 3 elements", q:size() == 3, "[",q:size(),"]")
    local v = q:pop()
    SKC4_LOGGER:debug("...successfully poped 1 element", q:size() == 2, "[",q:size(),",",v,"]")
    v = q:pop()
    SKC4_LOGGER:debug("...successfully poped 1 element", q:size() == 1, "[",q:size(),",",v,"]")
    v = q:pop()
    SKC4_LOGGER:debug("...successfully poped 1 element", q:size() == 0, "[",q:size(),",",v,"]")
    v = q:pop()
    SKC4_LOGGER:debug("...successfully poped nil element", q:size() == 0, "[",q:size(),",",v,"]")
      

    SKC4_LOGGER:debug("...queue is empty", q:is_empty(), "[",q:size(),"]")
    q:push_by_key("uno","ciccio1")
    SKC4_LOGGER:debug("...successfully push_by_key 1 element with key", q:size() == 1, "[",q:size(),"]")
    q:push_by_key("due","ciccio2")
    q:push_by_key("tre","ciccio3")
    SKC4_LOGGER:debug("...successfully push_by_key 2 elements", q:size() == 3, "[",q:size(),"]")
    q:push_by_key("due","ciccio_due")
    q:push_by_key("tre","ciccio_tre")
    SKC4_LOGGER:debug("...successfully update 2 elements", q:size() == 3, "[",q:size(),"]")
    
    local v = q:pop_by_key("due")
    SKC4_LOGGER:debug("...successfully pop_by_key 1 element", q:size() == 2, "[",q:size(),",",v,"]")
    v = q:pop_by_key("uno")
    SKC4_LOGGER:debug("...successfully pop_by_key 1 element", q:size() == 1, "[",q:size(),",",v,"]")
    v = q:pop_by_key("due")
    SKC4_LOGGER:debug("... fail to pop pop_by_key element", q:size() == 1, "[",q:size(),",",v,"]")
    v = q:pop()
    SKC4_LOGGER:debug("...successfully poped 1 element", q:size() == 0, "[",q:size(),",",v,"]")
    v = q:pop()
    SKC4_LOGGER:debug("...successfully poped nil element", q:size() == 0, "[",q:size(),",",v,"]")

    SKC4_LOGGER:debug("queue is", q._queue)
  else
    print("Please make SKC4_LOGGER available befor run self_test")
  end
end

return Queue end)
package.preload['common.c4_common'] = (function (...)
--[[=============================================================================
    ON_INIT, Timer,s and Property management functions

    Copyright 2016 Control4 Corporation. All Rights Reserved.
===============================================================================]]
require "common.c4_driver_declarations"
require "lib.c4_log"
require "lib.c4_timer"

-- Set template version for this file
if (TEMPLATE_VERSION ~= nil) then
	TEMPLATE_VERSION.c4_common = "2016.01.08"
end

--[[=============================================================================
    Create and Initialize Logging
===============================================================================]]
function ON_DRIVER_EARLY_INIT.c4_common()
	-- Create a logger
	LOG = c4_log:new("Ksenialares4")
end

function ON_DRIVER_INIT.c4_common() 	
	-- -- Create Log Timer
	gC4LogTimer = c4_timer:new("Log Timer", 59, "MINUTES", OnLogTimerExpired)
	-- -- Init Timer per azioni in startup del driver (casuale per evitare che parta con altri driver)
	local t =  math.random (2, 6)
	-- -- Create Timer SendToUI
	SendToUITimer = c4_timer:new("SendToUITimer", pinValidityTime, "SECONDS", OnSendToUITimerExpired, false, CallbackParam)
	--Timer per la gestione della coda per i comandi tipo enable partitions e altri delicati
	queue_processor_Timer = c4_timer:new("queue_processor_Timer", 100, "MILLISECONDS", queue_processor,false, CallbackParam)
	 -- -- Timer per la visualizzazione di extraInfo, sim e temperature
	sendExtraInfoTimer = c4_timer:new("sendExtraInfoTimer", messageValidityTime, "SECONDS", sendExtraInfoTimerExpired, false, CallbackParam)
	
	readFromPanelTimer = c4_timer:new("readFromPanelTimer", 3, "SECONDS", readFromPanelTimerExpired, false, CallbackParam)
	--readFromPanelTimer = c4_timer:new("readFromPanelTimer", 3, "SECONDS", readKseniaConf, false, CallbackParam)
	
	troubleClearTimer = c4_timer:new("troubleClearTimer", messageValidityTime, "SECONDS", troubleClearTimerExpired, false, CallbackParam)

	keepAliveTimer = c4_timer:new("keepAliveTimer", pollingTimerPeriod, "MINUTES", keepAliveTimerExpired, false, CallbackParam)

	timeOutTimer = c4_timer:new("timeOutTimer", 1000, "MILLISECONDS", timeOutTimerExpired, false, CallbackParam)
	
	pollingOffTimer = c4_timer:new("pollingOffTimer", 60, "MINUTES", pollingOffTimerExpired, false, CallbackParam)
	
	-- readConfTimer = c4_timer:new("readConfTimer", 120, "SECONDS", readConfTimerExpired, false, CallbackParam)
	
	-- -- Timer per verifica Trial o License
	-- TrialTimer = c4_timer:new("TrialTimer", TimerTrialCycles, UnitsTrialCycles, TrialTimerExpired, false, CallbackParam)

end

--[[=============================================================================
    Log timer callback function
===============================================================================]]
function OnLogTimerExpired()
	LogWarn("Turning Log Mode Off (timer expired)")
	gC4LogTimer:KillTimer()
	
	C4:UpdateProperty("Log Mode", "Off")
	OnPropertyChanged("Log Mode")
end

gForceLogging = false

function ON_PROPERTY_CHANGED.LogMode(propertyValue)
	gC4LogTimer:KillTimer()
	
	if (gForceLogging) then
		LOG:OutputPrint(true)
		LOG:OutputC4Log(true)
	else
		LOG:OutputPrint(propertyValue:find("Print") ~= nil)
		LOG:OutputC4Log(propertyValue:find("Log") ~= nil)
		if (propertyValue == "Off") then
			LOG:OutputPrint(false)
			LOG:OutputC4Log(false)
			return
		end
		gC4LogTimer:StartTimer()
	end
end

function ON_PROPERTY_CHANGED.LogLevel(propertyValue)
	if (gForceLogging) then
		LOG:SetLogLevel("5 - Debug")
	else
		LOG:SetLogLevel(propertyValue)
	end
end

--[[=============================================================================
    Print Template Versions
===============================================================================]]
function TemplateVersion()
	print ("\nTemplate Versions")
	print ("-----------------------")
	for k, v in pairs(TEMPLATE_VERSION) do
		print (k .. " = " .. v)
	end
	
	print ("")
end
 end)
package.preload['common.c4_device_connection_base'] = (function (...)
--[[=============================================================================
    DeviceConnectionBase Class

    Copyright 2016 Control4 Corporation. All Rights Reserved.
===============================================================================]]
require "common.c4_common"
require "lib.c4_object"
require "lib.c4_log"
require "lib.c4_timer"
require "lib.c4_queue"

-- Set template version for this file
if (TEMPLATE_VERSION ~= nil) then
	TEMPLATE_VERSION.c4_device_connection_base = "2016.01.08"
end

COMMAND_QUEUE_SIZE = 100
DEFAULT_COMMAND_DELAY_INTERVAL = 100            -- Don't send consecutive commands faster than this many milliseconds
DEFAULT_COMMAND_RESPONSE_INTERVAL = 3           -- If we haven't received and ACK after this many seconds, try again
DEFAULT_RETRY_COUNT_MAX = 3

function ON_DRIVER_EARLY_INIT.c4_device_connection_base()
	gReceiveBuffer = ""
	gIsUrlConnected = false
end

DeviceConnectionBase = inheritsFrom(nil)

function DeviceConnectionBase:construct()

	self._IsConnected = false
	self._SendTimer = nil
	self._WaitResponseTimer = nil
	self._CommandQueue = nil
	self._Priority1CommandQueue = nil
	self._Priority2CommandQueue = nil
	self._LastCommand = nil
	self._ExpectAck = false
	self._CommandRetryCount = 0
	self._RetryCountMax = DEFAULT_RETRY_COUNT_MAX

	self._SendCommandDelayMS = DEFAULT_COMMAND_DELAY_INTERVAL
	self._CommandResponseWaitS = DEFAULT_COMMAND_RESPONSE_INTERVAL
	
	-- Polling
	self._PollingInterval = 0
	self._PollingUnits = "SECONDS"
	self._PollingTimer = nil
end

function DeviceConnectionBase:Initialize(ExpectAck, CommandDelayInterval, CommandResponseInterval, CallbackParam)

	if (ExpectAck ~= nil) then
		self._ExpectAck = ExpectAck
	end

	if (CommandDelayInterval ~= nil) then
		self._SendCommandDelayMS = CommandDelayInterval
	end

	if (CommandResponseInterval ~= nil) then
		self._CommandResponseWaitS = CommandResponseInterval
	end

	self._CommandQueue = c4_queue:new()
	self._CommandQueue:SetMaxSize(COMMAND_QUEUE_SIZE)
	self._CommandQueue:SetName("Command Queue")

	self._Priority1CommandQueue = c4_queue:new()
	self._Priority1CommandQueue:SetMaxSize(COMMAND_QUEUE_SIZE)
	self._Priority1CommandQueue:SetName("P1 Queue")

	self._Priority2CommandQueue = c4_queue:new()
	self._Priority2CommandQueue:SetMaxSize(COMMAND_QUEUE_SIZE)
	self._Priority2CommandQueue:SetName("P2 Queue")

	-- usually only one of these timers will be used, but it's pretty low overhead to instantiate both of them
	self._SendTimer = c4_timer:new("SendCommand", self._SendCommandDelayMS, "MILLISECONDS", DeviceConnectionBase.OnSendTimeExpired, false, CallbackParam)
	self._WaitResponseTimer = c4_timer:new("WaitResponse", self._CommandResponseWaitS, "SECONDS", DeviceConnectionBase.OnWaitTimeExpired, false, CallbackParam)
end

function DeviceConnectionBase:InitPolling(PollingInterval, PollingUnits, CallbackParam)
	LogFatal("DeviceConnectionBase:InitPolling()")
	if (PollingInterval ~= nil) then
		self._PollingInterval = PollingInterval
	end
	
	self._PollingUnits = PollingUnits or self._PollingUnits

	LogFatal("self._PollingInterval: %s, self._PollingUnits: %s", tostring(self._PollingInterval), tostring(self._PollingUnits))
	
	-- create polling timer
	self._PollingTimer = c4_timer:new("Polling", self._PollingInterval, self._PollingUnits, DeviceConnectionBase.OnPollingTimerExpired, false, CallbackParam)
end

function DeviceConnectionBase:StartPolling(interval, units)
	LogFatal("DeviceConnectionBase:StartPolling()")
	LogFatal("self._PollingTimer: %s", tostring(self._PollingTimer))
	
	if (self._PollingTimer ~= nil) then
		self._PollingTimer:KillTimer()
		
		local timer_units = units or self._PollingTimer._units
		local timer_interval = interval or self._PollingInterval

		self._PollingTimer:StartTimer(timer_interval, timer_units)
	end
end

function DeviceConnectionBase:StopPolling()
	LogFatal("DeviceConnectionBase:StopPolling()")
	self._PollingTimer:KillTimer()
end

function DeviceConnectionBase:SetExpectACK(ExpectACK)
	self._ExpectAck = ExpectACK
end

function DeviceConnectionBase:SetCommandDelayInterval(DelayInterval)
	self._SendCommandDelayMS = DelayInterval
end

function DeviceConnectionBase:SetResponseWaitInterval(WaitInterval)
	self._CommandResponseWaitS = WaitInterval
end

function DeviceConnectionBase:ReceivedFromCom(sData)

	gReceiveBuffer = gReceiveBuffer .. sData
	LogTrace("ReceivedFromCom  ReceiveBuffer is now {{{%s}}}", gReceiveBuffer)

	message = self:GetMessage()
	while (message ~= nil and message ~= "") do
		status, err = pcall(HandleMessage, message)
		if (status) then
			message = self:GetMessage()
		else
			LogError("LUA_ERROR: " .. err)
			message = ""
			gReceiveBuffer = ""
		end
	end
end

function DeviceConnectionBase:SetConnection(IsConnected, method)
	self._IsConnected = IsConnected
	gControlMethod = method
end

function DeviceConnectionBase:ControlMethod()
	-- Override in derived class
	print("WARNING: Need to override ControlMethod - should never be called")
	
	return ""
end

function DeviceConnectionBase:StartCommandTimer(...)
	local value = select(1, ...)
	local units = select(2, ...)
	local command_name = select(3, ...) or ""

	self._WaitResponseTimer:KillTimer()
	self._SendTimer:KillTimer()

	if (self._ExpectAck) then
		-- expecting an ACK set the Response Wait timer
		local timer_units = units or self._WaitResponseTimer._units
		local timer_interval = value or self._CommandResponseWaitS

		self._WaitResponseTimer:StartTimer(timer_interval, timer_units)
		LogTrace(string.format("Starting wait Timer:  %d", self._WaitResponseTimer._timerID) .. " for " .. command_name)
	else
		-- no ACK expected, just wait the designated amount of time and send another command
		local timer_units = units or self._SendTimer._units
		local timer_interval = value or self._SendCommandDelayMS

		self._SendTimer:StartTimer(timer_interval, timer_units)
		LogTrace(string.format("Starting Send Timer:  %d for %s (timer_interval = %d, timer_units = %s)", self._SendTimer._timerID, command_name, timer_interval, timer_units))
	end
end

-- Note the '.' instead of the ':'
function DeviceConnectionBase.OnSendTimeExpired(Instance)
	LogTrace("Send Timer expired")
	Instance._SendTimer:KillTimer()

	local tCommand = Instance._LastCommand
	if (tCommand.command_name ~= nil) then
		LogTrace("Send Timer expired - Last Command: %s, Send Next Command", tostring(tCommand.command_name))
	elseif (type(tCommand) == "string") then
		LogTrace("Send Timer expired - Last Command: %s, Send Next Command", tostring(tCommand))
	end
	
	Instance._LastCommand = nil
	Instance:SendNextCommand()

	if (DoEvents ~= nil and type(DoEvents) == "function") then
		DoEvents()
	end
end

function DeviceConnectionBase.OnWaitTimeExpired(Instance)
	LogTrace("Wait Timer expired")
	Instance._WaitResponseTimer:KillTimer()
	Instance._CommandRetryCount = Instance._CommandRetryCount + 1

	if (Instance._CommandRetryCount >= Instance._RetryCountMax) then
		-- To many retries, pop the current command and try the next one
		Instance._CommandRetryCount = 0
		Instance:SendNextCommand()
	else
		Instance:SendLastCommand()
	end
end

function DeviceConnectionBase.OnPollingTimerExpired(Instance)
	LogTrace("Polling Timer expired")
	Instance._PollingTimer:KillTimer()

	OnPollingTimerExpired()
	
	Instance._PollingTimer:StartTimer(Instance._PollingInterval)
end

function DeviceConnectionBase:HandleACK()
	self._LastCommand = nil
	
	self._WaitResponseTimer:KillTimer()
	self._CommandRetryCount = 0
	self:SendNextCommand()
end

function DeviceConnectionBase:QueueEmpty()
	return (self._CommandQueue:empty() and self._Priority1CommandQueue:empty() and self._Priority2CommandQueue:empty())
end

function DeviceConnectionBase:QueueCommand(sCommand, ...)
	LogTrace("QueueCommand(%s)", sCommand)
	local command_delay = select(1, ...)
	local delay_units = select(2, ...)
	local command_name = select(3, ...)

	if (sCommand == nil) or (sCommand == "") then
		return
	end

	if (self._LastCommand == nil) then
		self._CommandQueue:push(sCommand, command_delay, delay_units, command_name)
		self._LastCommand = self._CommandQueue:pop()
		self:SendCommand(sCommand, command_delay, delay_units, command_name)
	else
		self._CommandQueue:push(sCommand, command_delay, delay_units, command_name)
	end
end

function DeviceConnectionBase:QueuePriority1Command(sCommand, ...)
	LogTrace("QueuePriority1Command(%s)", sCommand)
	local command_delay = select(1, ...)
	local delay_units = select(2, ...)
	local command_name = select(3, ...)

	if (sCommand == nil) or (sCommand == "") then
		return
	end

	if (self._LastCommand == nil) then
		self._Priority1CommandQueue:push(sCommand, command_delay, delay_units, command_name)
		self._LastCommand = self._Priority1CommandQueue:pop()
		self:SendCommand(sCommand, command_delay, delay_units, command_name)
	else
		self._Priority1CommandQueue:push(sCommand, command_delay, delay_units, command_name)
	end
end

function DeviceConnectionBase:QueuePriority2Command(sCommand, ...)
	LogTrace("QueuePriority2Command(%s)", sCommand)
	local command_delay = select(1, ...)
	local delay_units = select(2, ...)
	local command_name = select(3, ...)

	if (sCommand == nil) or (sCommand == "") then
		return
	end

	if (self._LastCommand == nil) then
		self._Priority2CommandQueue:push(sCommand, command_delay, delay_units, command_name)
		self._LastCommand = self._Priority2CommandQueue:pop()
		self:SendCommand(sCommand, command_delay, delay_units, command_name)
	else
		self._Priority2CommandQueue:push(sCommand, command_delay, delay_units, command_name)
	end
end

function DeviceConnectionBase:SendNextCommand()
	LogTrace("DeviceConnectionBase:SendNextCommand")

	local tCommand = nil
	if (not self._Priority1CommandQueue:empty()) then
		tCommand = self._Priority1CommandQueue:pop()
		LogTrace(tostring(gCon._Priority1CommandQueue))
	elseif (not self._Priority2CommandQueue:empty()) then
		tCommand = self._Priority2CommandQueue:pop()
		LogTrace(tostring(gCon._Priority2CommandQueue))
	elseif (not self._CommandQueue:empty()) then
		tCommand = self._CommandQueue:pop()
		LogTrace(tostring(gCon._CommandQueue))
	end
	
	if (tCommand ~= nil) then
		self._LastCommand = tCommand
		local sCommand = tCommand.command
		local command_delay = tCommand.command_delay
		local delay_units = tCommand.delay_units
		local command_name = tCommand.command_name

		if (sCommand == nil or sCommand == "") then
			self._SendTimer:KillTimer()
			self._WaitResponseTimer:KillTimer()
		else
			LogTrace("SendCommand: %s", sCommand)
			self:SendCommand(sCommand, command_delay, delay_units, command_name)
		end
	end
end

function DeviceConnectionBase:SendLastCommand()
--	LogTrace("DeviceConnectionBase:SendLastCommand")

	local tCommand = self._LastCommand
	if (tCommand ~= nil) then
		local sCommand = tCommand.command
		local command_delay = tCommand.command_delay
		local delay_units = tCommand.delay_units
		local command_name = tCommand.command_name

		if (sCommand == nil or sCommand == "") then
			self._SendTimer:KillTimer()
			self._WaitResponseTimer:KillTimer()
		else
			LogTrace("SendCommand: %s", sCommand)
			self:SendCommand(sCommand, command_delay, delay_units, command_name)
		end
	end
end

function DeviceConnectionBase:SendCommand()
	-- Dummy routine.  Override in derived class
	print("Need to override SendCommand - should never be called")
end


function DeviceConnectionBase:GetMessage()
	
	-- Brain dead version of this routine. Just return the current receive buffer.
	-- It's very likely that a GetMessage() function will need to be created
	if (GetMessage ~= nil and type(GetMessage) == "function") then
		return GetMessage()
	else
		local ComMessage = gReceiveBuffer
		gReceiveBuffer = ""

		return ComMessage
	end
end

--[[=============================================================================
    Other Connection Functions
===============================================================================]]

function ReceivedFromSerial(idBinding, sData)
	if (gCon.ReceivedFromSerial == nil) then return end --serial is bound but not the current control method
	gCon:ReceivedFromSerial(idBinding, sData)
end

function ReceivedFromNetwork(idBinding, nPort, sData)
	LogTrace("Received Data from ReceivedFromNetwork: " .. idBinding .. ": " .. sData)
	gCon:ReceivedFromNetwork(idBinding, nPort, sData)
end

function OnServerDataIn(nHandle, strData)
	--LogTrace("Received Data on Handle: " .. nHandle .. ": " .. strData) -- commentato da RL
 
   if IS_LICENSED then 
		if not KSENIAData['GlobalData']['readKseniaConf'] then
			if isKseniaConfReaded() == true then -- in questo modo se non ha la conf ci riprova.
				KsCom_ReceivedFromUDP(nHandle, strData)
			else
				readKseniaConf()
			end
		end
	else 
		HLicense_Response( 'Unauthorized')
	end
	-- gCon:ReceivedFromNetworkServer(nHandle, strData) -- commentato da RL
end


--[[=============================================================================
    The ReceivedAsync function is called in response to 'url_get_request'. 
    The ticketId is the number returned from the request.
===============================================================================]]
function ReceivedAsync(ticketId, strData, responseCode, tHeaders)
	strData = strData or ""
	responseCode = responseCode or 0
	tHeaders = tHeaders or {}

	--LogTrace("ReceivedAsync[" .. ticketId .. "]: Response Code: " .. responseCode .. " Length: " .. string.len(strData))
    --LogTrace(tHeaders)
	--LogTrace(strData)

	gCon:ReceivedAsync(ticketId, strData, responseCode, tHeaders)
end
	
--[[=============================================================================
    OnBindingChanged(idBinding, class, bIsBound)
  
    Description:
    Function called by Director when a binding changes state(bound or unbound).
  
    Parameters:
    idBinding(int) - ID of the binding whose state has changed.
    class(string)  - Class of binding that has changed.
                     A single binding can have multiple classes(i.e. COMPONENT,
                     STEREO, RS_232, etc).
                     This indicates which has been bound or unbound.
    bIsBound(bool) - Whether the binding has been bound or unbound.
  
    Returns:
    None
===============================================================================]]
function OnBindingChanged(idBinding, class, bIsBound)
	
	LogTrace("OnBindingChanged(): idBinding = " .. tostring(idBinding) .. ", class = " .. class .. ", bIsBound = " .. tostring(bIsBound))
	if (idBinding == SERIAL_BINDING_ID) then
		gIsSerialConnected = bIsBound
		SetControlMethod()
		OnSerialConnectionChanged(idBinding, class, bIsBound)
	elseif (idBinding == IR_BINDING_ID) then
		gIsIRConnected = bIsBound
		SetControlMethod()
		OnIRConnectionChanged(idBinding, class, bIsBound)
	elseif(OnConnectionChanged ~= nil and type(OnConnectionChanged) == "function") then
		OnConnectionChanged(idBinding, class, bIsBound)
	end
end

--[[=============================================================================
    OnNetworkBindingChanged(idBinding, bIsBound)
  
    Description:
    Function called by Director when a network binding changes state(bound or unbound).
  
    Parameters:
    idBinding(int) - ID of the binding whose state has changed.
    bIsBound(bool) - Whether the binding has been bound or unbound.
  
    Returns:
    None
===============================================================================]]
function OnNetworkBindingChanged(idBinding, bIsBound)
	LogTrace('OnNetworkBindingChanged(): idBinding = ' .. tostring(idBinding) .. ' bIsBound = ' .. tostring(bIsBound))

	gIsNetworkConnected = bIsBound
	SetControlMethod()
	OnNetworkConnectionChanged(idBinding, bIsBound)
	local useCase = TypeOfSocket[idBinding]
	if (bIsBound) then
		if ( DemoSocket[useCase] ~= nil and DemoSocket[useCase].running == true)then 
			print ('OnNetworkBindingChanged(), socket running. Trying to start() again')
			gCon._NetworkReconnectTimer:StartTimer(gNetworkReconnectInterval) 	
		else
			print ('OnNetworkBindingChanged() Offline, and Not Running')
		end
		-- Start a special instance of reconnect timer to eventually do NetConnect if not done automatically
	end	
end

--[[=============================================================================
    OnConnectionStatusChanged(idBinding, nPort, sStatus)
  
    Description:
    Sets the updated status of the specified binding
  
    Parameters:
    idBinding(int)  - ID of the binding whose status has changed
    nPort(int)      - The communication port of the specified bindings connection
    sStatus(string) - "ONLINE" if the connection status is to be set to Online,
                      any other value will set the status to Offline
  
    Returns:
    None
===============================================================================]]
function OnConnectionStatusChanged(idBinding, nPort, sStatus)
	LogTrace("c4_device_connection_base.lua OnConnectionStatusChanged[" .. idBinding .. " (" .. tostring(nPort) .. ")]: " .. sStatus)

	local isOnline = false
	gNetworkStatus = sStatus	
	if (sStatus == "ONLINE") then
		isOnline = true
	end

	--gCon:SetOnlineStatus(isOnline)
	--OnNetworkStatusChanged(idBinding, nPort, sStatus)
end

--[[=============================================================================
    SetControlMethod()
  
    Description:
    Sets the control method type for the drivers internal infrastructure
  
    Parameters:
    None
  
    Returns:
    The type of control method for the drivers connection(i.e. Network, Serial,
    IR, or (none))
===============================================================================]]
function SetControlMethod()
	--gCon = {}
	if (gIsNetworkConnected == false) and (gCon._NetworkReconnectTimer ~= nil) then
		--housekeeping when changing from network control to serial or IR control
		gCon._NetworkReconnectTimer:KillTimer() 
	end
	if( gIsSocketConnected) then
		-- connect to NetworkServer communicator if not already connected
		print ("connect to NetworkServer communicator if not already connected")
	elseif( gIsNetworkServerConnected) then
		-- connect to NetworkServer communicator if not already connected
		if (gCon == nil or gCon.ControlMethod() ~= "NetworkServer") then
			gCon = NetworkServerConnectionBase:new()
			gCon:Initialize()
		end
		gCon:SetConnection(true, "NetworkServer")
	elseif (gIsNetworkConnected) then
		-- connect to Network communicator if not already connected
		if (gCon == nil or gCon.ControlMethod() ~= "Network") then
			gCon = NetworkConnectionBase:new(NETWORK_BINDING_ID, NETWORK_PORT)
			gCon:Initialize(COM_USE_ACK, COM_COMMAND_DELAY_MILLISECONDS, COM_COMMAND_RESPONSE_TIMEOUT_SECONDS)
		end
		gCon:SetConnection(true, "Network")
	elseif (gIsUrlConnected) then
		-- connect to URL communicator if not already connected
		if (gCon == nil or gCon.ControlMethod() ~= "URL") then
			gCon = UrlConnectionBase:new()
			gCon:Initialize(COM_USE_ACK, COM_COMMAND_DELAY_MILLISECONDS, COM_COMMAND_RESPONSE_TIMEOUT_SECONDS)
		end
		gCon:SetConnection(true, "URL")
	elseif (gIsSerialConnected) then
		-- connect to Serial communicator if not already connected
		if (gCon == nil or gCon.ControlMethod() ~= "Serial") then
			gCon = SerialConnectionBase:new(SERIAL_BINDING_ID)
			gCon:Initialize(COM_USE_ACK, COM_COMMAND_DELAY_MILLISECONDS, COM_COMMAND_RESPONSE_TIMEOUT_SECONDS)
			gCon:InitPolling(tonumber(gPollingTimerInterval), "MINUTES", gCon)
		end
		gCon:SetConnection(true, "Serial")
	elseif (gIsIRConnected) then
		-- connect to IR communicator if not already connected
		if (gCon == nil or gCon.ControlMethod() ~= "IR") then
			gCon = IRConnectionBase:new(IR_BINDING_ID)
			gCon:Initialize(COM_USE_ACK, COM_COMMAND_DELAY_MILLISECONDS, COM_COMMAND_RESPONSE_TIMEOUT_SECONDS)
		end
		gCon:SetConnection(true, "IR")
	else
		if (gCon ~= nil) then
			gCon:SetConnection(false, "(none)")
		end
		-- gCon = nil
	end
	--16/11/18	fix error
	gCon._CommandQueue:clear()
	gCon._Priority1CommandQueue:clear()
	gCon._Priority2CommandQueue:clear()
end

--[[=============================================================================
    ValidateControlMethod(controlMethod)
  
    Description:
    Identifies whether the specified control method has a valid connection
  
    Parameters:
    controlMethod(string) - The communication we are validating against
                            Valid types are (Network, Serial, and IR)
  
    Returns:
    true if the controlMethod specified has been connected, false otherwise.
===============================================================================]]
function ValidateControlMethod(controlMethod)
	local isValid = false

	if (controlMethod == "Network") and (gIsNetworkConnected) then
		isValid = true
	elseif (controlMethod == "URL") and (gIsUrlConnected) then
		isValid = true
	elseif (controlMethod == "Serial") and (gIsSerialConnected) then
		isValid = true
	elseif (controlMethod == "IR") and (gIsIRConnected) then
		isValid = true
	end

	return isValid
end
 end)
package.preload['common.c4_diagnostics'] = (function (...)
--[[=============================================================================
    Functions for Testing different aspects of the environment

    Copyright 2016 Control4 Corporation. All Rights Reserved.
===============================================================================]]
require "common.c4_driver_declarations"

-- Set template version for this file
if (TEMPLATE_VERSION ~= nil) then
	TEMPLATE_VERSION.c4_diagnostics = "2016.01.08"
end

function DisplayGlobals()

	print ("Global Variables")
	print ("----------------------------")
	for k,v in pairs(_G) do                             -- globals
		if not (type(v) == "function") then
			if (string.find(k, "^g%L")  == 1) then
				print(k .. ":  " .. tostring(v))
				if (type(v) == "table") then
					C4PrintTable(v, "   ")
				end
			end
		end
	end

	print ("")
end

function C4PrintTable(tValue, sIndent)

	sIndent = sIndent or "   "
	for k,v in pairs(tValue) do

		print(sIndent .. tostring(k) .. ":  " .. tostring(v))
		if (type(v) == "table") then
			C4PrintTable(v, sIndent .. "   ")
		end
	end
end end)
package.preload['common.c4_driver_declarations'] = (function (...)
--[[=============================================================================
    Driver Declarations used to call startup routines, teardown routines, and 
    other basic functions of the drivers operation

    Copyright 2016 Control4 Corporation. All Rights Reserved.
===============================================================================]]

-- Template Version Table
TEMPLATE_VERSION = {}
TEMPLATE_VERSION.c4_driver_declarations = "2016.01.08"

-- Command Handler Tables
EX_CMD = {}
PRX_CMD = {}
UI_REQ = {}
NOTIFY = {}
DEV_MSG = {}
LUA_ACTION = {}

--[[=============================================================================
    Tables of functions
    The following tables are function containers that are called within the
    following functions:

    OnDriverInit()
        First calls all functions contained within ON_DRIVER_EARLY_INIT table
        then calls all functions contained within ON_DRIVER_INIT table

    OnDriverLateInit()
        Calls all functions contained within ON_DRIVER_LATEINIT table

    OnDriverDestroyed()
        Calls all functions contained within ON_DRIVER_DESTROYED table

    OnPropertyChanged()
        Calls all functions contained within ON_PROPERTY_CHANGED table
===============================================================================]]
ON_DRIVER_INIT = {}
ON_DRIVER_EARLY_INIT = {}
ON_DRIVER_LATEINIT = {}
ON_DRIVER_DESTROYED = {}
ON_PROPERTY_CHANGED = {}


-- Constants
DEFAULT_PROXY_BINDINGID = 5001 end)
package.preload['common.c4_init'] = (function (...)
--[[=============================================================================
    Initial driver initialization and destruction functions

    Copyright 2016 Control4 Corporation. All Rights Reserved.
===============================================================================]]
require "common.c4_driver_declarations"
require "common.c4_property"

-- Set template version for this file
if (TEMPLATE_VERSION ~= nil) then
	TEMPLATE_VERSION.c4_init = "2016.01.08"
end

--[[=============================================================================
    OnDriverInit()

    Description
    Invoked by director when a driver is loaded. This API is provided for the
    driver developer to contain all of the driver objects that will require
    initialization.

    Parameters
    None

    Returns
    Nothing
===============================================================================]]
function OnDriverInit()
	gInitializingDriver = true
	C4:ErrorLog("INIT_CODE: OnDriverInit()")

	-- Call all ON_DRIVER_EARLY_INIT functions.
	for k,v in pairs(ON_DRIVER_EARLY_INIT) do
		if (ON_DRIVER_EARLY_INIT[k] ~= nil and type(ON_DRIVER_EARLY_INIT[k]) == "function") then
			C4:ErrorLog("INIT_CODE: ON_DRIVER_EARLY_INIT." .. k .. "()")
			local status, err = pcall(ON_DRIVER_EARLY_INIT[k])
			if (not status) then
				C4:ErrorLog("LUA_ERROR: " .. err)
			end
		end
	end

	-- Call all ON_DRIVER_INIT functions
	for k,v in pairs(ON_DRIVER_INIT) do
		if (ON_DRIVER_INIT[k] ~= nil and type(ON_DRIVER_INIT[k]) == "function") then
			C4:ErrorLog("INIT_CODE: ON_DRIVER_INIT." .. k .. "()")
			local status, err = pcall(ON_DRIVER_INIT[k])
			if (not status) then
				C4:ErrorLog("LUA_ERROR: " .. err)
			end
		end
	end

	LICENSE_MGR:OnDriverInit()
	
	-- Fire OnPropertyChanged to set the initial Headers and other Property
	-- global sets, they'll change if Property is changed.
	for k,v in pairs(Properties) do
		C4:ErrorLog("INIT_CODE: Calling OnPropertyChanged - " .. k .. ": " .. v)
		local status, err = pcall(OnPropertyChanged, k)
		if (not status) then
			C4:ErrorLog("LUA_ERROR: " .. err)
		end
	end

	LICENSE_MGR:OnPropertyChanged(strProperty)	
	
	-- avvio timer per ripristino (attesa che il driver sia uscito da fasi di init)
	-- initTimer:StartTimer()
	
	gInitializingDriver = false
end

--[[=============================================================================
    OnDriverLateInit()

    Description
    Invoked by director after all drivers in the project have been loaded. This
    API is provided for the driver developer to contain all of the driver
    objects that will require initialization after all drivers in the project
    have been loaded.

    Parameters
    None

    Returns
    Nothing
===============================================================================]]
function OnDriverLateInit()
	C4:ErrorLog("INIT_CODE: OnDriverLateInit()")
	
	-- Call all ON_DRIVER_LATEINIT functions
	for k,v in pairs(ON_DRIVER_LATEINIT) do
		if (ON_DRIVER_LATEINIT[k] ~= nil and type(ON_DRIVER_LATEINIT[k]) == "function") then
			C4:ErrorLog("INIT_CODE: ON_DRIVER_LATEINIT." .. k .. "()")
			ON_DRIVER_LATEINIT[k]()
		end
	end
	
	LICENSE_MGR:OnDriverLateInit() 

end


--[[=============================================================================
    OnDriverDestroyed()
    Function called by Director when a driver is removed. Release things this
    driver has allocated such as timers.

    Parameters
    None

    Returns
    Nothing
===============================================================================]]
function OnDriverDestroyed()
	C4:ErrorLog("INIT_CODE: OnDriverDestroyed()")
	
	-- Call all ON_DRIVER_DESTROYED functions
	for k, v in pairs(ON_DRIVER_DESTROYED) do
		if (ON_DRIVER_DESTROYED[k] ~= nil and type(ON_DRIVER_DESTROYED[k]) == "function") then
			C4:ErrorLog("INIT_CODE: ON_DRIVER_DESTROYED." .. k .. "()")
			ON_DRIVER_DESTROYED[k]()
		end
	end
end

 end)
package.preload['common.c4_ir_connection'] = (function (...)
--[[=============================================================================
    Base for an IR connection driver

    Copyright 2016 Control4 Corporation. All Rights Reserved.
===============================================================================]]
require "common.c4_driver_declarations"
require "common.c4_device_connection_base"
require "lib.c4_log"
require "common.c4_common"

-- Set template version for this file
if (TEMPLATE_VERSION ~= nil) then
	TEMPLATE_VERSION.c4_ir_connection = "2016.01.08"
end

IRConnectionBase = inheritsFrom(DeviceConnectionBase)

function IRConnectionBase:construct(BindingID)
	self.superClass():construct()
	self._BindingID = BindingID
end

function IRConnectionBase:Initialize(ExpectAck, DelayInterval, WaitInterval)
	LogTrace("tSerConBase:Initialize")
	gControlMethod = "IR"
	self:superClass():Initialize(ExpectAck, DelayInterval, WaitInterval, self)
end

function IRConnectionBase:ControlMethod()
	return "IR"
end

function IRConnectionBase:SendCommand(sCommand, ...)
	if(self._IsConnected) then
		local command_delay = select(1, ...)
		local delay_units = select(2, ...)
		local command_name = select(3, ...)

		C4:SendIR(self._BindingID, sCommand)
		self:StartCommandTimer(command_delay, delay_units, command_name)
	else
		LogWarn("IR connection is not bound. Command not sent.")
	end
end
 end)
package.preload['common.c4_networkserver_connection'] = (function (...)
--[[=============================================================================
    Base for a network server connection driver

    Copyright 2016 Control4 Corporation. All Rights Reserved.
===============================================================================]]
require "common.c4_device_connection_base"
require "lib.c4_log"

-- Set template version for this file
if (TEMPLATE_VERSION ~= nil) then
	TEMPLATE_VERSION.c4_networkserver_connection = "2016.01.08"
end

DEFAULT_POLLING_INTERVAL_SECONDS = 30

gNetworkKeepAliveInterval = DEFAULT_POLLING_INTERVAL_SECONDS

JK_NETWORK_BINDING_ID = 6001
JK_IP_ADDRESS = "192.168.0.169"
JK_PORT = 0x0C00


NetworkServerConnectionBase = inheritsFrom(DeviceConnectionBase)

function NetworkServerConnectionBase:construct()
	self.superClass():construct()

	self._Port = JK_PORT
	self._Handle = 0
end

function NetworkServerConnectionBase:Initialize(ExpectAck, DelayInterval, WaitInterval)
	LogTrace("NetworkServerConnectionBase:Initialize")
	gControlMethod = "NetworkServer"
	self:superClass():Initialize(ExpectAck, DelayInterval, WaitInterval, self)

end

function NetworkServerConnectionBase:ControlMethod()
	return "NetworkServer"
end

function NetworkServerConnectionBase:SendCommand(sCommand, ...)
	if(self._IsConnected) then
		if(self._IsOnline) then
			local command_delay = select(1, ...)
			local delay_units = select(2, ...)
			local command_name = select(3, ...)

			C4:SendToNetwork(self._BindingID, self._Port, sCommand)
			self:StartCommandTimer(command_delay, delay_units, command_name)
		else
			self:CheckNetworkConnectionStatus()
		end
	else
		LogWarn("Not connected to network. Command not sent.")
	end
end


function NetworkServerConnectionBase:SendRaw(sData)
--	LogTrace("Sending raw: %s", HexToString(sData))
	C4:ServerSend(self._Handle, sData, #sData)
end


function NetworkServerConnectionBase:ReceivedFromNetworkServer(nHandle, sData)
	self._Handle = nHandle
	self:ReceivedFromCom(sData)
end


function NetworkServerConnectionBase:StartListening()
	LogTrace("Creating Listener on Port %d", self._Port)
	C4:CreateServer(self._Port)
end


function NetworkServerConnectionBase:StopListening()
	LogTrace("Closing Listener on Port %d", self._Port)
	C4:DestroyServer()
end



-- function NetworkServerConnectionBase:CheckNetworkConnectionStatus()
	-- if (self._IsConnected and (not self._IsOnline)) then
		-- LogWarn("Network status is OFFLINE. Trying to reconnect to the device's Control port...")
		-- C4:NetDisconnect(self._BindingID, self._Port)
		-- C4:NetConnect(self._BindingID, self._Port)
	-- end
-- end

-- function NetworkServerConnectionBase.OnKeepAliveTimerExpired(Instance)
	-- Instance._LastCheckin = Instance._LastCheckin + 1

	-- if(Instance._LastCheckin > 2) then
		-- if(not Instance._IsOnline) then
			-- C4:NetDisconnect(Instance._BindingID, Instance._Port)
			-- C4:NetConnect(Instance._BindingID, Instance._Port)
		-- else
			-- C4:NetDisconnect(Instance._BindingID, Instance._Port)
			-- LogWarn("Failed to receive poll responses... Disconnecting...")
		-- end
	-- end

	-- if (SendKeepAlivePollingCommand ~= nil and type(SendKeepAlivePollingCommand) == "function") then
		-- SendKeepAlivePollingCommand()
	-- end

	-- Instance._KeepAliveTimer:StartTimer(gNetworkKeepAliveInterval)
-- end

-- function NetworkServerConnectionBase:SetOnlineStatus(IsOnline)
	-- self._IsOnline = IsOnline

	-- if(IsOnline) then
		-- self._KeepAliveTimer:StartTimer()
		-- self._LastCheckin = 0
		-- if (UpdateProperty ~= nil and type(UpdateProperty) == "function") then
			-- UpdateProperty("Connected To Network", "true")
		-- end

		-- self:SendNextCommand()
	-- else
		-- self._KeepAliveTimer:KillTimer()
		-- if (UpdateProperty ~= nil and type(UpdateProperty) == "function") then
			-- UpdateProperty("Connected To Network", "false")
		-- end
	-- end
-- end

 end)
package.preload['common.c4_network_connection'] = (function (...)
--[[=============================================================================
    Base for a network connection driver

    Copyright 2016 Control4 Corporation. All Rights Reserved.
===============================================================================]]
require "common.c4_device_connection_base"
require "lib.c4_log"

-- Set template version for this file
if (TEMPLATE_VERSION ~= nil) then
	TEMPLATE_VERSION.c4_network_connection = "2016.01.08"
end

DEFAULT_POLLING_INTERVAL_SECONDS = 30
DEFAULT_RECONNECT_INTERVAL_SECONDS = 5

gNetworkKeepAliveInterval = DEFAULT_POLLING_INTERVAL_SECONDS
gNetworkReconnectInterval = DEFAULT_RECONNECT_INTERVAL_SECONDS

NetworkConnectionBase = inheritsFrom(DeviceConnectionBase)

function NetworkConnectionBase:construct(BindingID, Port)
	self.superClass():construct()

	self._BindingID = BindingID
	self._Port = Port
	self._LastCheckin = 0
	self._IsOnline = false
	self._KeepAliveTimer = nil
end

function NetworkConnectionBase:Initialize(ExpectAck, DelayInterval, WaitInterval)
	LogTrace("NetConBase:Initialize")
	gControlMethod = "Network"
	self:superClass():Initialize(ExpectAck, DelayInterval, WaitInterval, self)
	self._KeepAliveTimer = c4_timer:new("PollingTimer", gNetworkKeepAliveInterval, "SECONDS", NetworkConnectionBase.OnKeepAliveTimerExpired, false, self)
	self._NetworkReconnectTimer = c4_timer:new("NetworkReconnectTimer", gNetworkReconnectInterval, "SECONDS", NetworkConnectionBase.OnNetworkReconnectTimerExpired, false, self)
end

function NetworkConnectionBase:ControlMethod()
	return "Network"
end

function NetworkConnectionBase:SendCommand(sCommand, ...)
	if(self._IsConnected) then
		if(self._IsOnline) then
			local command_delay = select(1, ...)
			local delay_units = select(2, ...)
			local command_name = select(3, ...)

			C4:SendToNetwork(self._BindingID, self._Port, sCommand)
			self:StartCommandTimer(command_delay, delay_units, command_name)
		else
			self:CheckNetworkConnectionStatus()
		end
	else
		LogWarn("Not connected to network. Command not sent.")
	end
end

function NetworkConnectionBase:ReceivedFromNetwork(idBinding, nPort, sData)
	self._LastCheckin = 0
	self:ReceivedFromCom(sData)
end

function NetworkConnectionBase:CheckNetworkConnectionStatus()
	if (self._IsConnected and (not self._IsOnline)) then
		LogWarn("Network status is OFFLINE. Trying to reconnect to the device's Control port...")
		C4:NetDisconnect(self._BindingID, self._Port)
		--C4:NetConnect(self._BindingID, self._Port)
		self._NetworkReconnectTimer:StartTimer(gNetworkReconnectInterval)
	end
end

function NetworkConnectionBase.OnKeepAliveTimerExpired(Instance)
	Instance._LastCheckin = Instance._LastCheckin + 1

	if(Instance._LastCheckin == 3) then
		LogWarn("Failed to receive poll responses... initiating network recovery mode...")
		C4:NetDisconnect(Instance._BindingID, Instance._Port)
		Instance._NetworkReconnectTimer:StartTimer(gNetworkReconnectInterval)
		return
	elseif(Instance._LastCheckin > 4) then	
		Instance._LastCheckin = 4
	end

	if (SendKeepAlivePollingCommand ~= nil and type(SendKeepAlivePollingCommand) == "function" and Instance._IsOnline) then
		SendKeepAlivePollingCommand()
	end

	Instance._KeepAliveTimer:StartTimer(gNetworkKeepAliveInterval)
end

function NetworkConnectionBase.OnNetworkReconnectTimerExpired(Instance)
	if (Instance._IsConnected) then
		LogWarn("OnNetworkReconnectTimerExpired: Attempting to reactivate network connection...")
		C4:NetDisconnect(Instance._BindingID, Instance._Port)
		C4:NetConnect(Instance._BindingID, Instance._Port)
		--Instance._NetworkReconnectTimer:StartTimer(gNetworkReconnectInterval)
	else
		LogWarn("Cannot attempt to reactivate, the network connection is not bound")
	end
end

function NetworkConnectionBase:SetOnlineStatus(IsOnline)
	self._IsOnline = IsOnline

	if(IsOnline) then
		self._KeepAliveTimer:StartTimer(gNetworkKeepAliveInterval)
		self._NetworkReconnectTimer:KillTimer()
		self._LastCheckin = 0
		if (UpdateProperty ~= nil and type(UpdateProperty) == "function") then
			UpdateProperty("Connected To Network", "true")
		end

		self:SendNextCommand()
	else
		self._KeepAliveTimer:KillTimer()
		self._NetworkReconnectTimer:StartTimer(gNetworkReconnectInterval)
		if (UpdateProperty ~= nil and type(UpdateProperty) == "function") then
			UpdateProperty("Connected To Network", "false")
		end
	end
end

function ON_DRIVER_LATEINIT.c4_network_connection()
	-- Ensure existing connection is taken into consideration (useful on Driver Update)
	if (gCon ~= nil) then
		local tmp = C4:GetBindingAddress(gCon._BindingID)
		if (tmp ~= nil and string.len(tmp) > 0) then OnNetworkBindingChanged(gCon._BindingID, true) end
	end
end
 end)
package.preload['common.c4_notify'] = (function (...)
--[[=============================================================================
    Notification Functions

    Copyright 2016 Control4 Corporation. All Rights Reserved.
===============================================================================]]
require "common.c4_driver_declarations"

-- Set template version for this file
if (TEMPLATE_VERSION ~= nil) then
	TEMPLATE_VERSION.c4_notify = "2016.01.08"
end

--[[=============================================================================
    SendNotify(notifyText, tParams, bindingID)

    Description
    Forwards a notification to the proxy with a list of parameters

    Parameters
    notifyText(string) - The function identifier for the proxy
    tParams(table)     - Table of key value pairs that hold the the parameters
                         and their values used in the proxy function
    bindingID(int)     - The requests binding id

    Returns
    Nothing
===============================================================================]]
function SendNotify(notifyText, tParams, bindingID)
	C4:SendToProxy(bindingID, notifyText, tParams, "NOTIFY")
end

--[[=============================================================================
    SendSimpleNotify(notifyText, ...)

    Description
    Forwards a notification to the proxy with no parameters

    Parameters
    notifyText(string) - The function identifier for the proxy
    bindingID(int)     - Optional parameter containing the requests binding id,
                         if not specified then the DEFAULT_PROXY_ID is given.

    Returns
    Nothing
===============================================================================]]
function SendSimpleNotify(notifyText, ...)
	bindingID = select(1, ...) or DEFAULT_PROXY_BINDINGID
	C4:SendToProxy(bindingID, notifyText, {}, "NOTIFY")
end end)
package.preload['common.c4_property'] = (function (...)
--[[=============================================================================
    Function for changing properties

    Copyright 2016 Control4 Corporation. All Rights Reserved.
===============================================================================]]
require "common.c4_driver_declarations"

-- Set template version for this file
if (TEMPLATE_VERSION ~= nil) then
	TEMPLATE_VERSION.c4_property = "2016.01.08"
end

--[[=============================================================================
    OnPropertyChanged(sProperty)

    Description
    Function called by Director when a property changes value. The value of the
    property that has changed can be found with: Properties[sName]. Note that
    OnPropertyChanged is not called when the Property has been changed by the
    driver calling the UpdateProperty command, only when the Property is changed
    by the user from the Properties Page. This function is called by Director
    when a property changes value.

    Parameters
    sProperty(string) - Name of property that has changed.

    Returns
    Nothing
===============================================================================]]
function OnPropertyChanged(sProperty)

	local propertyValue = Properties[sProperty]
	
	--if gInitializingDriver == false then KsGetProperty(sProperty) end

	if (LOG ~= nil and type(LOG) == "table") then
		LogTrace("OnPropertyChanged(" .. sProperty .. ") changed to: " .. Properties[sProperty])
	end

    LICENSE_MGR:OnPropertyChanged(sProperty)

	-- Remove any spaces (trim the property)
	local trimmedProperty = string.gsub(sProperty, " ", "")
	local status = true
	local err = ""

	if (ON_PROPERTY_CHANGED[sProperty] ~= nil and type(ON_PROPERTY_CHANGED[sProperty]) == "function") then
		status, err = pcall(ON_PROPERTY_CHANGED[sProperty], propertyValue)
	elseif (ON_PROPERTY_CHANGED[trimmedProperty] ~= nil and type(ON_PROPERTY_CHANGED[trimmedProperty]) == "function") then
		status, err = pcall(ON_PROPERTY_CHANGED[trimmedProperty], propertyValue)
	end

	if (not status) then
		LogError("LUA_ERROR: " .. err)
    end
    
    --GL20191119
    local value = Properties[sProperty]
    LICENSE_MGR:OnPropertyChanged(sProperty, value)

end

--[[=============================================================================
    UpdateProperty(propertyName, propertyValue)
  
    Description:
    Sets the value of the given property in the driver
  
    Parameters:
    propertyName(string)  - The name of the property to change
    propertyValue(string) - The value of the property being changed
  
    Returns:
    None
===============================================================================]]
function UpdateProperty(propertyName, propertyValue)
	if (Properties[propertyName] ~= nil) then
		C4:UpdateProperty(propertyName, propertyValue)
	end
end
 end)
package.preload['common.c4_serial_connection'] = (function (...)
--[[=============================================================================
    Base for a serial connection driver

    Copyright 2016 Control4 Corporation. All Rights Reserved.
===============================================================================]]
require "common.c4_driver_declarations"
require "common.c4_device_connection_base"
require "lib.c4_log"
require "common.c4_common"

-- Set template version for this file
if (TEMPLATE_VERSION ~= nil) then
	TEMPLATE_VERSION.c4_serial_connection = "2016.01.08"
end

SerialConnectionBase = inheritsFrom(DeviceConnectionBase)

function SerialConnectionBase:construct(BindingID)
	self.superClass():construct()
	self._BindingID = BindingID
end

function SerialConnectionBase:Initialize(ExpectAck, DelayInterval, WaitInterval)
	gControlMethod = "Serial"
	self:superClass():Initialize(ExpectAck, DelayInterval, WaitInterval, self)
end

function SerialConnectionBase:ControlMethod()
	return "Serial"
end

function SerialConnectionBase:SendCommand(sCommand, ...)
	if(self._IsConnected) then
		local command_delay = select(1, ...)
		local delay_units = select(2, ...)
		local command_name = select(3, ...)

		C4:SendToSerial(self._BindingID, sCommand)
		self:StartCommandTimer(command_delay, delay_units, command_name)
	else
		LogWarn("Not connected to serial. Command not sent.")
	end
end

function SerialConnectionBase:SendRaw(sData)
	C4:SendToSerial(self._BindingID, sData)
end


function SerialConnectionBase:ReceivedFromSerial(idBinding, sData)
	self:ReceivedFromCom(sData)
end
 end)
package.preload['common.c4_url_connection'] = (function (...)
--[[=============================================================================
    Base for a url connection driver

    Copyright 2016 Control4 Corporation. All Rights Reserved.
===============================================================================]]
require "common.c4_device_connection_base"

-- Set template version for this file
if (TEMPLATE_VERSION ~= nil) then
	TEMPLATE_VERSION.c4_url_connection = "2016.01.08"
end

UrlConnectionBase = inheritsFrom(DeviceConnectionBase)

function UrlConnectionBase:construct(Url)
	self.superClass():construct()
	self._Url = Url
end

function UrlConnectionBase:Initialize(ExpectAck, DelayInterval, WaitInterval)
	gControlMethod = "URL"
	self:superClass():Initialize(ExpectAck, DelayInterval, WaitInterval, self)
	OnURLConnectionChanged()
end

function UrlConnectionBase:ControlMethod()
	return "URL"
end

function UrlConnectionBase:SetUrl(Url)
	self._Url = Url
end

function UrlConnectionBase:SendCommand(sCommand, sHeader, ignoreConnect)
	ignoreConnect = ignoreConnect or false

	local ticketId
	if(self._IsConnected or ignoreConnect) then
		if (sHeader ~= nil) then
			ticketId = C4:urlPost(self._Url, sCommand, sHeader)
		else
			ticketId = C4:urlPost(self._Url, sCommand)
		end
	else
		LogWarn("Not connected. Command not sent.")
	end
	
	return ticketId
end

function UrlConnectionBase:SendCommandUrl(sCommand, url, sHeader, ignoreConnect)
	ignoreConnect = ignoreConnect or false

	local ticketId
	if(self._IsConnected or ignoreConnect) then
		if (sHeader ~= nil) then
			ticketId = C4:urlPost(url, sCommand, sHeader)
		else
			ticketId = C4:urlPost(url, sCommand)
		end
	else
		LogWarn("Not connected. Command not sent.")
	end
	
	return ticketId
end

function UrlConnectionBase:UrlPost(sCommand, url, sHeader, ignoreConnect)
	ignoreConnect = ignoreConnect or false

	local ticketId
	if(self._IsConnected or ignoreConnect) then
		if (sHeader ~= nil) then
			ticketId = C4:urlPost(url, sCommand, sHeader)
		else
			ticketId = C4:urlPost(url, sCommand)
		end
	else
		LogWarn("Not connected. Command not sent.")
	end
	
	return ticketId
end

function UrlConnectionBase:UrlGet(url, sHeader, ignoreConnect)
	ignoreConnect = ignoreConnect or false
	--LogTrace("UrlConnectionBase:UrlGet URL: "..url)
	local ticketId
	if(self._IsConnected or ignoreConnect) then
		if (sHeader ~= nil) then
			ticketId = C4:urlGet(url, sHeader, false)
		else
			
		ticketId = C4:urlGet(url)
		end
	else
		LogWarn("Not connected. Command not sent.")
	end
	return ticketId
end

function UrlConnectionBase:ReceivedAsync(ticketId, sData, responseCode, tHeaders)
	--LogTrace("ReceivedAsync[" .. ticketId .. "]: Response Code: " .. responseCode .. " Length: " .. string.len(sData))
	local tMessage = {
		["ticketId"] = ticketId,
		["sData"] = sData,
		["responseCode"] = responseCode,
		["tHeaders"] = tHeaders
	}
	
	status, err = pcall(HandleMessage, sData, ticketId)
	if (not status) then
		LogError("LUA_ERROR: " .. err)
	end
end

function ConnectURL()
	gIsUrlConnected = true
	gIsSocketConnected = true
	SetControlMethod()
end

function DisconnectURL()
	gIsUrlConnected = false
	SetControlMethod()
end


function UrlConnectionBase:SetOnlineStatus(IsOnline)
	self._IsOnline = IsOnline
end
 end)
package.preload['common.c4_utils'] = (function (...)
--[[=============================================================================
    Helper functions

    Copyright 2016 Control4 Corporation. All Rights Reserved.
===============================================================================]]

-- Set template version for this file
if (TEMPLATE_VERSION ~= nil) then
	TEMPLATE_VERSION.c4_utils = "2016.01.08"
end

--[[=============================================================================
    AsciiToBCD(InString)

    Description
    Convert an ascii string to a binary coded decimal. Each decimal digit is
    stored in one byte, with the lower four bits encoding the digit in BCD form.

    Parameters
    InString(string) - Ascii string that is to be converted into bcd

    Returns
    The binary coded decimal
===============================================================================]]
function AsciiToBCD(InString)
	local WorkVal = 0
	local RetValStr = ""
	local DoingHighNybble = false
	local WorkStr = ((#InString % 2) == 0) and (InString) or ("0" .. InString)	-- make sure length is an even number

	for CharCount = 1, #WorkStr do
		local NumVal = tonumber(WorkStr:sub(CharCount, CharCount))

		WorkVal = bit.lshift(WorkVal, 4) + NumVal
		if (DoingHighNybble) then
			RetValStr = RetValStr .. string.char(WorkVal)
			WorkVal = 0
		end

		DoingHighNybble = (not DoingHighNybble)
	end

	return RetValStr
end

--[[=============================================================================
    BCDToAscii(InByte)

    Description
    Convert an BCD string to an ascii string.

    Parameters
    InByte(string) - Binary coded decimal that is to be converted into ascii

    Returns
    The ascii string
===============================================================================]]
function BCDToAscii(InByte)
	return tostring(bit.rshift(InByte, 4)) .. tostring(bit.band(InByte, 0x0F))
end

--[[=============================================================================
    MakeXMLNode(Tag, Value)

    Description
    Create an Xml element

    Parameters
    Tag(string)   - The Xml elements name
    Value(string) - The Xml elements value

    Returns
    The xml element created for the specified value
===============================================================================]]
function MakeXMLNode(Tag, Value)
	return "<" .. Tag .. ">" .. Value .. "</" .. Tag .. ">"
end

--[[=============================================================================
    MakeXMLAttrNode(Tag, Value, Attribute, AttrValue)

    Description
    Create an Xml element with an attribute

    Parameters
    Tag(string)       - The Xml elements name
    Value(string)     - The Xml elements value
    Attribute(string) - The attribute to be added to the Xml element
    AttrValue(string) - The value of the attribute to be added

    Returns
    The xml element created for the specified value
===============================================================================]]
function MakeXMLAttrNode(Tag, Value, Attribute, AttrValue)
    return "<" .. Tag .. " " .. Attribute .. "=\"" .. AttrValue .. "\">" .. Value .. "</" .. Tag .. ">"
end

--[[=============================================================================
    StringFromUnicode(UnicodeString)

    Description
    Convert a unicode string

    Parameters
    UnicodeString(string) - The unicode string to be converted to ascii

    Returns
    The ascii representation of the unicode string
===============================================================================]]
function StringFromUnicode(UnicodeString)
	local RetVal = ""

	-- extract every other byte from the unicode string
	for Index = 2, #UnicodeString, 2 do
		RetVal = RetVal .. string.sub(UnicodeString, Index, Index)
	end

	return RetVal
end

--[[=============================================================================
    StringSplit(s)

    Description
    Splits a string into multiple strings at every space character

    Parameters
    s(string) - The string that is to be split into several strings at the
                space character

    Returns
    A table of strings containing all the seperate values in the given string
===============================================================================]]
function StringSplit(s)
	local delim = " "
	local result = {}

	if s == nil or s == "" then
		return result
	end

	for match in (s..delim):gmatch("(.-)"..delim) do
		table.insert(result, match)
	end

	return result
end

--[[=============================================================================
    toboolean(s)

    Description
    Returns a boolean representation of the given string

    Parameters
    s(string) - The string to evaluate the boolean representation from

    Returns
    The value true or false based on the given string
===============================================================================]]
function toboolean(val)
	rval = false;

	if type(val) == "string" and (string.lower(val) == "true" or val == "1") then
		rval = true
	elseif type(val) == "number" and val ~= 0 then
		rval =  true
	elseif type(val) == "boolean" and val == true then
		rval = true
	end

	return rval
end

--[[=============================================================================
    Go(to, err, ...)

    Description
    Call a function with the given arguments if it exists or report the error

    Parameters
    to(string)  - The string to evaluate the boolean representation from
    err(string) - The error to report if the function does not exist
    ...         - Additional optional parameters for the function specified by
                  the "to" parameter

    Returns
    Nothing
===============================================================================]]
function Go(to, err, ...)
	if (type(to) == "function") then
		return to(...)
	else
		LogTrace(err)
	end
end

--[[=============================================================================
    IsEmpty(str)

    Description
    Identifies if the string given is nil or empty

    Parameters
    str(string) - The string to evaluate for the empty condition

    Returns
    True if the given value is empty, false otherwise
===============================================================================]]
function IsEmpty(str)
	return str == nil or str == ""
end

--[[=============================================================================
    ReverseTable(a)

    Description
    Reverse table entries (key=value, value=key)

    Parameters
    a(table) - The table to reverse

    Returns
    new reversed table
===============================================================================]]
function ReverseTable(a)
	local b = {}
	for k,v in pairs(a) do b[v] = k end
	return b
end

function tonumber_loc(str, base)
  local s = str:gsub(",", ".") -- Assume US Locale decimal separator
  local num = tonumber(s, base)
  if (num == nil) then
    s = str:gsub("%.", ",") -- Non-US Locale decimal separator
    num = tonumber(s, base)
  end
  return num
end

--[[=============================================================================
    HexToString(InString)

    Description
    Converts a string of Hex characters to a readable string of ASCII characters

    Parameters
    InString(string) - The string to be converted

    Returns
    A string showing the hex bytes of the InString
===============================================================================]]
function HexToString(InString)
	local RetVal = ""

	for Index = 1, #InString do
		RetVal = RetVal .. string.format("%02X ", InString:byte(Index))
	end
	return RetVal
end


--[[=============================================================================
    StringToHex(InString)

    Description
    Converts a string of ASCII characters to as string with the actual Hex bytes in them.
	Basically an array of hex bytes.

    Parameters
    InString(string) - The string to be converted

    Returns
    A string of hex bytes (really an array of hex values) 
===============================================================================]]
function StringToHex(InString)
	local RetVal = ""

	for HexByteString in string.gfind(InString, "%x%x") do
		RetVal = RetVal .. string.char(tonumber(HexByteString, 16))
	end
	return RetVal
end

function RecordHistory(severity, eventType, category, subcategory, description)
	C4:RecordHistory(severity, eventType, category, subcategory, description)
end

function RecordCriticalHistory(eventType, category, subcategory, description)
	RecordHistory("Critical", eventType, category, subcategory, description)
end

function RecordWarningHistory(eventType, category, subcategory, description)
	RecordHistory("Warning", eventType, category, subcategory, description)
end

function RecordInfoHistory(eventType, category, subcategory, description)
	RecordHistory("Info", eventType, category, subcategory, description)
end


 end)
package.preload['lib.c4_log'] = (function (...)
--[[=============================================================================
    c4_log Class

    Copyright 2016 Control4 Corporation. All Rights Reserved.
===============================================================================]]
require "common.c4_driver_declarations"
require "lib.c4_object"

-- Set template version for this file
if (TEMPLATE_VERSION ~= nil) then
	TEMPLATE_VERSION.c4_log = "2016.01.08"
end

c4_log = inheritsFrom(nil)

function c4_log:construct(logName)
	self._logLevel = tonumber(string.sub(Properties['Log Level'] or "", 1, 1)) or 5
	self._outputPrint = Properties['Log Mode']:find("Print") ~= nil
	self._outputC4Log = Properties['Log Mode']:find("Log") ~= nil
	self._logName = logName or ""

	-- make sure Property is up to date (no harm if absent)
	C4:UpdateProperty("Log Level", Properties['Log Level'])
end

function c4_log:SetLogLevel(level)
	self._logLevel = tonumber(string.sub(level or "", 1, 1)) or self._logLevel
end

function c4_log:LogLevel()
	return self._logLevel
end

function c4_log:OutputPrint(value)
	self._outputPrint = value
end

function c4_log:OutputC4Log(value)
	self._outputC4Log = value
end

function c4_log:SetLogName(logName)

	if (logName == nil or logName == "") then
		logName = ""
	else
		logName = logName .. ": "
	end

	self._logName = logName
end

function c4_log:LogName()
	return self._logName
end

function c4_log:Enabled()
	return (self._outputPrint or self._outputC4Log)
end

function c4_log:PrintEnabled()
	return self._outputPrint
end

function c4_log:C4LogEnabled()
	return self._outputC4Log
end

function c4_log:CreateTableText(tValue, tableText)
	tableText = tableText or ""

	if (type(tValue) == "table") then

		tableText = tableText .. "{"
		for k, v in pairs(tValue) do

			-- add key
			if (type(k) == "number") then
				tableText = tableText .. "[" .. tostring(k) .. "]="
			elseif (type(k) == "string") then
				tableText = tableText .. k .. "="
			else
				print (tostring(k) .. ": " .. tostring (v))
			end

			-- add value
			if (type(v) == "number") then
				tableText = tableText .. tostring(v) .. ","
			elseif (type(v) == "string") then
				tableText = tableText .. "'" .. v .. "',"
			elseif (type(v) == "table") then
				tableText = c4_log:CreateTableText(v, tableText)
				tableText = tableText .. ","
			elseif (type(v) == "boolean") then
				tableText = tableText .. tostring(v) .. ","
			end
		end

		tableText = tableText .. "}"
	end

	return tableText
end

function InsertIndent(indentLevel)
	local indentStr = ""

	for i=1, indentLevel do
		indentStr = indentStr .. "\t"
	end

	return indentStr
end

function c4_log:CreateTableTextFormatted(tValue, tableText, indentLevel)
	tableText = tableText or ""
	indentLevel = indentLevel or 0

	if (type(tValue) == "table") then

		indentLevel = indentLevel + 1
		tableText = tableText .. "{\n"
		for k, v in pairs(tValue) do

			-- add key
			if (type(k) == "number") then
				tableText = tableText .. InsertIndent(indentLevel) .. "[" .. tostring(k) .. "]="
			elseif (type(k) == "string") then
				tableText = tableText .. InsertIndent(indentLevel) .. k .. "="
			else
				print (tostring(k) .. ": " .. tostring (v))
			end

			-- add value
			if (type(v) == "number") then
				tableText = tableText .. tostring(v) .. ",\n"
			elseif (type(v) == "string") then
				tableText = tableText .. "'" .. v .. "',\n"
			elseif (type(v) == "table") then
				tableText = c4_log:CreateTableTextFormatted(v, tableText, indentLevel)
				tableText = tableText .. ",\n"
			elseif (type(v) == "boolean") then
				tableText = tableText .. tostring(v) .. ",\n"
			end
		end

		indentLevel = indentLevel - 1
		tableText = tableText .. InsertIndent(indentLevel) .. "}"
	end

	return tableText
end

MAX_TABLE_LEVELS = 10
function c4_log:PrintTable(tValue, tableText, sIndent, level)
	tableText = tableText or ""
	level = level + 1
	
	if (level <= MAX_TABLE_LEVELS) then
		if (type(tValue) == "table") then
			for k,v in pairs(tValue) do
				if (tableText == "") then
					tableText = sIndent .. tostring(k) .. ":  " .. tostring(v)
					if (sIndent == ".   ") then sIndent = "    " end
				else
					tableText = tableText .. "\n" .. sIndent .. tostring(k) .. ":  " .. tostring(v)
				end
				if (type(v) == "table") then
					tableText = self:PrintTable(v, tableText, sIndent .. "   ", level)
				end
			end
		else
			tableText = tableText .. "\n" .. sIndent .. tostring(tValue)
		end
	end
	
	return tableText
end

function c4_log:LogTable(tValue, sIndent, level)
	level = level + 1
	
	if (level <= MAX_TABLE_LEVELS) then
		if (type(tValue) == "table") then
			for k,v in pairs(tValue) do
				C4:ErrorLog(self._logName .. sIndent .. tostring(k) .. ":  " .. tostring(v))
				if (type(v) == "table") then
					self:LogTable(v, sIndent .. "   ", level)
				end
			end
		else
			C4:ErrorLog(self._logName .. sIndent .. tValue)
		end
	end
end

function c4_log:Print(logLevel, sLogText)

	if (self._logLevel >= logLevel) then
		if (type(sLogText) == "table") then
			if (self._outputPrint) then
				print (self:PrintTable(sLogText, tableText, ".   ", 0))
			end

			if (self._outputC4Log) then
				self:LogTable(sLogText, "   ", 0)
			end

			return
		end

		if (self._outputPrint) then
			print (sLogText)
		end

		if (self._outputC4Log) then
			C4:ErrorLog(self._logName .. tostring(sLogText))
		end
	end
end

function c4_log:Fatal(sLogText, ...)
	self:LogOutput(0, sLogText, ...)
end

function c4_log:Error(sLogText, ...)
	self:LogOutput(1, sLogText, ...)
end

function c4_log:Warn(sLogText, ...)
	self:LogOutput(2, sLogText, ...)
end

function c4_log:Info(sLogText, ...)
	self:LogOutput(3, sLogText, ...)
end

function c4_log:Debug(sLogText, ...)
	self:LogOutput(4, sLogText, ...)
end

function c4_log:Trace(sLogText, ...)
	self:LogOutput(5, sLogText, ...)
end

function c4_log:LogOutput(level, sLogText, ...)
	if (LogEnabled()) then
		if (type(sLogText) == "string") then
			sLogText = string.format(sLogText, ...)
		end

		self:Print(level, sLogText)
	end
end

--[[=============================================================================
    c4_log wrapper functions
===============================================================================]]
function TryLog(level, sLogText, ...)
	LOG:LogOutput(level, sLogText, ...)
end

--[[=============================================================================
    SetLogLevel(level)

    Description: 
    Sets the desired log level to view

    Parameters:
    level(int) - The logging level to set the message to
                 0 = Fatal
                 1 = Error
                 2 = Warn
                 3 = Info
                 4 = Debug
                 5 = Trace

    Returns:
    None
===============================================================================]]
function SetLogLevel(level)
	LOG:SetLogLevel(level)
end

--[[=============================================================================
    LogLevel()

    Description: 
    Returns the currently set log level

    Parameters:
    None

    Returns:
    The current log level
        0 = Fatal
        1 = Error
        2 = Warn
        3 = Info
        4 = Debug
        5 = Trace
===============================================================================]]
function LogLevel()
	return LOG:LogLevel()
end

--[[=============================================================================
    OutputPrint(value)

    Description: 
    Specifies whether to output log messages or not

    Parameters:
    value(bool) - true to enable logging output, false otherwise

    Returns:
    None
===============================================================================]]
function OutputPrint(value)
	LOG:OutputPrint(value)
end

--[[=============================================================================
    OutputPrint(value)

    Description: 
    Specifies whether to output log messages to file or not

    Parameters:
    value(bool) - true to enable logging output, false otherwise

    Returns:
    None
===============================================================================]]
function OutputC4Log(value)
	LOG:OutputC4Log(value)
end

--[[=============================================================================
    SetLogName(logName)

    Description: 
    Sets the name of the log file where the messages will be written to

    Parameters:
    logName(string) - Sets the name of the log to write messages to

    Returns:
    None
===============================================================================]]
function SetLogName(logName)
	LOG:SetLogName(logName)
end

--[[=============================================================================
    LogName(logName)

    Description: 
    Gets the name of the log file where the messages will be written to

    Parameters:
    None

    Returns:
    The value of the log file that has been set
===============================================================================]]
function LogName()
	return LOG:LogName()
end

--[[=============================================================================
    LogEnabled()

    Description: 
    Identifies if logging or print has been enabled

    Parameters:
    None

    Returns:
    true if either logging or print has been enabled, false otherwise
===============================================================================]]
function LogEnabled()
	return LOG:Enabled()
end

--[[=============================================================================
    PrintEnabled()

    Description: 
    Gets the state of print output

    Parameters:
    None

    Returns:
    true if print has been enabled, false otherwise
===============================================================================]]
function PrintEnabled()
	return LOG:PrintEnabled()
end

--[[=============================================================================
    C4LogEnabled()

    Description: 
    Gets the state of logging

    Parameters:
    None

    Returns:
    true if logging has been enabled, false otherwise
===============================================================================]]
function C4LogEnabled()
	return LOG:C4LogEnabled()
end

--[[=============================================================================
    LogFatal(sLogText, ...)

    Description: 
    Formats and prints a series of characters and values to the enabled outputs
    when the set logging level is Fatal(0) or higher

    Parameters:
    sLogText(string) - Format control string
    ...              - Optional arguments which will replace all the format
                       specifiers contained in the format string

    Returns:
    None
===============================================================================]]
function LogFatal(sLogText, ...)
	local status, err = pcall(TryLog, 0, sLogText, ...)
	if (not status) then
		LOG:Print(1, "LUA_ERROR - LogFatal failed: " .. err)
	end
end

--[[=============================================================================
    LogError(sLogText, ...)

    Description: 
    Formats and prints a series of characters and values to the enabled outputs
    when the set logging level is Error(1) or higher

    Parameters:
    sLogText(string) - Format control string
    ...              - Optional arguments which will replace all the format
                       specifiers contained in the format string

    Returns:
    None
===============================================================================]]
function LogError(sLogText, ...)
	local status, err = pcall(TryLog, 1, sLogText, ...)
	if (not status) then
		LOG:Print(1, "LUA_ERROR - LogError failed: " .. err)
	end
end

--[[=============================================================================
    LogWarn(sLogText, ...)

    Description: 
    Formats and prints a series of characters and values to the enabled outputs
    when the set logging level is Warn(2) or higher

    Parameters:
    sLogText(string) - Format control string
    ...              - Optional arguments which will replace all the format
                       specifiers contained in the format string

    Returns:
    None
===============================================================================]]
function LogWarn(sLogText, ...)
	local status, err = pcall(TryLog, 2, sLogText, ...)
	if (not status) then
		LOG:Print(1, "LUA_ERROR - LogWarn failed: " .. err)
	end
end

--[[=============================================================================
    LogInfo(sLogText, ...)

    Description: 
    Formats and prints a series of characters and values to the enabled outputs
    when the set logging level is Info(3) or higher

    Parameters:
    sLogText(string) - Format control string
    ...              - Optional arguments which will replace all the format
                       specifiers contained in the format string

    Returns:
    None
===============================================================================]]
function LogInfo(sLogText, ...)
	local status, err = pcall(TryLog, 3, sLogText, ...)
	if (not status) then
		LOG:Print(1, "LUA_ERROR - LogInfo failed: " .. err)
	end
end

--[[=============================================================================
    LogDebug(sLogText, ...)

    Description: 
    Formats and prints a series of characters and values to the enabled outputs
    when the set logging level is Debug(4) or higher

    Parameters:
    sLogText(string) - Format control string
    ...              - Optional arguments which will replace all the format
                       specifiers contained in the format string

    Returns:
    None
===============================================================================]]
function LogDebug(sLogText, ...)
	local status, err = pcall(TryLog, 4, sLogText, ...)
	if (not status) then
		LOG:Print(1, "LUA_ERROR - LogDebug failed: " .. err)
	end
end

--[[=============================================================================
    LogTrace(sLogText, ...)

    Description: 
    Formats and prints a series of characters and values to the enabled outputs
    when the set logging level is Trace(5) or higher

    Parameters:
    sLogText(string) - Format control string
    ...              - Optional arguments which will replace all the format
                       specifiers contained in the format string

    Returns:
    None
===============================================================================]]
function LogTrace(sLogText, ...)
	local status, err = pcall(TryLog, 5, sLogText, ...)
	if (not status) then
		LOG:Print(1, "LUA_ERROR - LogTrace failed: " .. err)
	end
end

function dbgPrint(buf)
	if (LOG:PrintEnabled()) then
		print (buf)
	end
end

function dbgHexdump(buf)
	hexdump(buf, dbgPrint)
end

--[[=============================================================================
    c4_log unit tests
===============================================================================]]
function __test_c4_log()
	require "test.C4Virtual"
	
	local LOG = c4_log:new("test_c4_log")
	assert(LOG:LogName() == "test_c4_log", "_logName is not equal to 'test_c4_log' it is: " .. LOG:LogName())

	-- Test setting log level
	LOG:SetLogLevel("2 - Warning")
	assert(LOG:LogLevel() == 2, "_logLevel is not equal to '2' it is: " .. LOG:LogLevel())

	LOG:SetLogLevel(3)
	assert(LOG:LogLevel() == 3, "_logLevel is not equal to '3' it is: " .. LOG:LogLevel())

	-- Test enabling logs
	LOG:OutputPrint(false)
	assert(LOG:PrintEnabled() == false, "_outputPrint is not equal to 'false' it is: " .. tostring(LOG:PrintEnabled()))

	LOG:OutputC4Log(true)
	assert(LOG:C4LogEnabled() == true, "_outputC4Log is not equal to 'true' it is: " .. tostring(LOG:C4LogEnabled()))

	LOG:SetLogLevel(4)
	LogTrace("***** This is a test *****")
end

function __test_CreatTableText()
	local tTest = {}

	tTest[1] = {}
	tTest[2] = {}
	tTest[3] = 30
	tTest[4] = "Forty"
	
	LogTrace("----- tText -----")
	LogTrace(tTest)

	local tTest2 = { One = {},
					 Two = {},
					 Three = 30,
					 Four = "Forty" }
	LogTrace("----- tText2 -----")
	LogTrace(tTest2)
	
	local tTest3 = { [1] = {},
					 [2] = {},
					 [3] = 30,
					 [4] = "Forty" }
	LogTrace("----- tText3 -----")
	LogTrace(tTest3)

	local tTest4 = { [1] = {},
					 Two = {},
					 [3] = 30,
					 [4] = "Forty",
					 Five = "Fifty" }
	LogTrace("----- tText4 -----")
	LogTrace(tTest4)

	local tableText = LOG:CreateTableText(tTest4)
	LogTrace("----- tableText -----")
	LogTrace(tableText)
	
	--local tNew = {[1] = {},[3] = 30,[4] = 'Forty',Five = 'Fifty',Two = {},}
	--LogTrace(tNew)
end

function __TestCreateTableTextFormatted()
	require "test.C4Virtual"
	
	local LOG = c4_log:new("test_c4_log")
	local tButtons = {
		Name = 'heat',
		Attributes = {},
		ChildNodes = {
			[1] = {
				Name = 'button',
				Attributes = {},
				ChildNodes = {
					[1] = {
						Value = '51',
						Attributes = {},
						Name = 'id',
						ChildNodes = {},
					},
					[2] = {
						Value = 'Pool Heater',
						Attributes = {},
						Name = 'button_text',
						ChildNodes = {},
					},
					[3] = {
						Value = 'POOLHT',
						Attributes = {},
						Name = 'button_name',
						ChildNodes = {},
					},
				},
			},
			[2] = {
				Name = 'button',
				Attributes = {},
				ChildNodes = {
					[1] = {
						Value = '53',
						Attributes = {},
						Name = 'id',
						ChildNodes = {},
					},
					[2] = {
						Value = 'Spa Heater',
						Attributes = {},
						Name = 'button_text',
						ChildNodes = {},
					},
					[3] = {
						Value = 'SPAHT',
						Attributes = {},
						Name = 'button_name',
						ChildNodes = {},
					},
				},
			},
			[3] = {
				Name = 'button',
				Attributes = {},
				ChildNodes = {
					[1] = {
						Value = '54',
						Attributes = {},
						Name = 'id',
						ChildNodes = {},
					},
					[2] = {Value = 'Pool Solar Heater',
						Attributes = {},
						Name = 'button_text',
						ChildNodes = {}
					},
					[3] = {
						Value = 'SOLHT',
						Attributes = {},
						Name = 'button_name',
						ChildNodes = {},
					},
				}
			}
		}
	}

	print(LOG:CreateTableTextFormatted(tButtons))
end end)
package.preload['lib.c4_object'] = (function (...)
--[[=============================================================================
    c4_object Class

    Copyright 2016 Control4 Corporation. All Rights Reserved.
===============================================================================]]

-- Set template version for this file
if (TEMPLATE_VERSION ~= nil) then
	TEMPLATE_VERSION.c4_object = "2016.01.08"
end

function inheritsFrom( baseClass )
	local new_class = {}
	local class_mt = { __index = new_class }

	function new_class:create(...)
		local newinst = {}

		setmetatable( newinst, class_mt )

		-- Call the constructor when we create this class
		if newinst.construct then
			-- Allow returning a different obj than self. This allows for readonly tables etc...
			newinst = newinst:construct(...) or newinst
		end

		return newinst
	end

	if nil ~= baseClass then
		setmetatable( new_class, { __index = baseClass } )
	end

	--[[=============================================================================
	    Implementation of additional OO properties starts here 
	===============================================================================]]
	
	-- Return the class object of the instance
	function new_class:class()
		return new_class
	end

	--[[=============================================================================
	    Return the super class object of the instance. 

	    Note Calling methods on the base class itself will modify
	    the base table's static properties. In order to have call
	    the base class' methods and have them modify the current object
	    use super() or superAsSelf(). 
	===============================================================================]]
	function new_class:superClass()
		return baseClass
	end

	--[[=============================================================================
	    Returns a table that allows calling of the base class's method
	    while maintaining the objects state as the modified state of the base
	    class' methods. For example consider the following statements (order matters):

	    -- The child sees the parents property if the child hasn't overriden the property
	       obj:superClass().id = "parent"
	       obj.id == "parent" -- true

	    -- Setting the property on the child overrides (hides) the parents property
	       obj.id = "child"
	       obj.id == "child" -- true

	    -- The super() method pass
	       obj:super().id == "parent" -- true
	       obj:super().id = "child"
	       obj:super().id == "parent" -- still true
	       obj.id == "child" -- still true
	===============================================================================]]
	function new_class:super()
		local holder = {}

		holder.child = self
		holder.parent = baseClass

		local mt = {}
		mt.__index = function(table, index)
			if table.parent[index] then
				return table.parent[index]
			else 
				return table.child[index]
			end
		end

		-- Only set the new values to the child.
		mt.__newindex = function(table, key, value)
			table.child[key] = value
		end

		mt.__tostring = function(table)
			return tostring(table.child)
		end

		setmetatable(holder, mt)
		return holder
	end

	new_class.new = new_class.create

	--[[=============================================================================
	    Return true if the caller is an instance of theClass
	===============================================================================]]
	function new_class:isa( theClass )
		local b_isa = false
		local cur_class = new_class

		while ( nil ~= cur_class ) and ( false == b_isa ) do
			if cur_class == theClass then
				b_isa = true
			else
				cur_class = cur_class:superClass()
			end
		end

		return b_isa
	end

	return new_class
end

--[[=============================================================================
    Inheritance unit tests
===============================================================================]]
function __test_inheritance()
	local b = inheritsFrom(nil)

	b.construct = function(self, msg)
		self._msg = msg
	end

	local t = inheritsFrom(b)
	t.construct = function(self, msg)
		self:super():construct(msg)
	end

	t1 = t:new("t1")
	t2 = t:new("t2")
	assert(t1._msg == "t1", "t1 message is not equal to 't1' it''s: " .. t1._msg)
	assert(t2._msg == "t2", "t2 message is not equal to 't2' it''s: " .. t2._msg)    
	assert(tostring(t1:super()) ==  tostring(t1), "tostrings don't match");
	assert(t1:superClass() == b, "superClass and baseClass should be the same. They are not.")

	t1:superClass().id = "parent"
	assert(t1.id == "parent", "obect''s super class has invalid property value: ", t1.id)

	-- Setting the property on the child overrides (hides) the parents property
	t1.id = "child"
	assert(t1.id == "child", "object instance variable has invalid property value: " .. t1.id)

	-- The super() method maintains the self pointer to the child and not to the base
	assert(t1:super().id == "parent", "superAsSelf found invalid value for base class variable")
	t1:super().id = "child1"
	assert(t1:super().id == "parent", "Setting of instance variable hid base classes variable from itself");
	assert(t1.id == "child1", "Settings of instance variable did not change child instance variable")
end end)
package.preload['lib.c4_queue'] = (function (...)
--[[=============================================================================
    c4_queue Class

    Copyright 2016 Control4 Corporation. All Rights Reserved.
===============================================================================]]
require "common.c4_driver_declarations"
require "lib.c4_object"

-- Set template version for this file
if (TEMPLATE_VERSION ~= nil) then
	TEMPLATE_VERSION.c4_queue = "2016.01.08"
end

c4_queue = inheritsFrom(nil)

function c4_queue:construct()
	-- entry table
	self._et = {first = 0, last = -1}
	self._maxSize = 0	-- no size limit
	self._name = ""

	local mt = getmetatable(self)
	if (mt ~= nil) then
		mt.__tostring = self.__tostring
	end
end

function c4_queue:__tostring()
	local tOutputString = {}
	table.insert(tOutputString, "--- Queue ---")
	if (not IsEmpty(self._name)) then
		table.insert(tOutputString, "  name = " .. tostring(self._name))
	end
	table.insert(tOutputString, "  first = " .. tostring(self._et.first))
	table.insert(tOutputString, "  last = " .. tostring(self._et.last))
	table.insert(tOutputString, "  number in queue = " .. tostring(self._et.last - self._et.first + 1))
	table.insert(tOutputString, "  maximum size = " .. self._maxSize)
	table.insert(tOutputString, "  next value = " .. tostring(self:value()))
	return table.concat(tOutputString, "\n")
end


-- push a value on the queue
function c4_queue:push(value, ...)
	local numItems = self._et.last - self._et.first + 1

	if ((self._maxSize <= 0) or (numItems < self._maxSize) ) then
		local last = self._et.last + 1
		self._et.last = last
		
		local interval = select(1, ...)
		local units = select(2, ...)
		local command_name = select(3, ...)
		self._et[last] = {["command"] = value, ["command_delay"] = interval, ["delay_units"] = units, ["command_name"] = command_name}		
		--LogTrace ("Queue:push(), first = " .. tostring(self._et.first) .. ", last = " .. tostring(self._et.last) .. ", number in queue = " .. tostring(self._et.last - self._et.first + 1) .. ", value = " .. value)
	else
		-- if addToQueue == true then push value to queue
		if (self:OnMaxSizeReached()) then
			local last = self._et.last + 1
			self._et.last = last
			self._et[last] = {["command"] = value, ["command_delay"] = interval, ["delay_units"] = units, ["command_name"] = command_name}
			--LogTrace ("Queue:push(), first = " .. tostring(self._et.first) .. ", last = " .. tostring(self._et.last) .. ", number in queue = " .. tostring(self._et.last - self._et.first + 1) .. ", value = " .. value)
		end
	end
end

function c4_queue:OnMaxSizeReached()
	--LogTrace ("Max Size Reached - clear queue and push value to the queue (default).")
	local addToQueue = true

	self:clear()
	return (addToQueue)
end

-- pop a value from the queue
function c4_queue:pop()
	local first = self._et.first

	if first > self._et.last then
		--LogTrace("Queue:pop(), queue is empty")
		return ""
	end

	local value = self._et[first]
	self._et[first] = nil        -- to allow garbage collection
	self._et.first = first + 1
	--LogTrace ("Queue:pop(), first = " .. tostring(self._et.first) .. ", last = " .. tostring(self._et.last) .. ", number in queue = " .. tostring(self._et.last - self._et.first + 1) .. ", value = " .. value)

	return value
end

-- clear queue
function c4_queue:clear()
	local first = self._et.first

	if first > self._et.last then
		--LogTrace ("Queue:clear(), queue is empty")
		return ""
	end

	self._et = {first = 0, last = -1}
	--LogTrace ("Queue:clear(), first = " .. tostring(self._et.first) .. ", last = " .. tostring(self._et.last) .. ", number in queue = " .. tostring(self._et.last - self._et.first + 1))
	--LogTrace (self._et)
end

-- return value of first item
function c4_queue:value()
	local first = self._et.first

	if (first > self._et.last) then
		return ""
	else
		return self._et[first]
	end
end

-- return queue's maximum size
function c4_queue:MaxSize()
	return self._maxSize
end

-- return queue's maximum size
function c4_queue:SetMaxSize(size)
	self._maxSize = size
end

function c4_queue:SetName(name)
	self._name = name
end

-- return the queue's current size
function c4_queue:Size()
	return self._et.last - self._et.first + 1
end

-- is queue empty?
function c4_queue:empty()
	if (self._et.first > self._et.last) then
		return true
	else
		return false
	end
end

--[[
    c4_queue unit tests
--]]
function __test_c4_queue()
	require "test.C4Virtual"
	require "lib.c4_log"

	local LOG = c4_log:new("test_c4_queue")
	LOG:SetLogLevel(5)
	LOG:OutputPrint(true)

	-- create an instance of the queue
	local c4Queue = c4_queue:new()

	c4Queue:SetMaxSize(3)
	assert(c4Queue:MaxSize() == 3, "_maxSize is not equal to '3' it is: " .. c4Queue:MaxSize())

	c4Queue:push("Item #1 in Queue")
	c4Queue:push("Item #2 in Queue")
	c4Queue:push("Item #3 in Queue")
	c4Queue:push("Item #4 in Queue")  -- this should cause OnMaxSizeReached() to be called and clear the queue
	assert(c4Queue:Size() == 1, "queue size is not equal to '1' it is: " .. c4Queue:Size())


	-- Test inheritance overriding OnMaxSizeReached
	-- Create a new class
	c4_queue_new = inheritsFrom(c4_queue)

	-- override construct()
	function c4_queue_new:construct()
		self.superClass():construct()  -- call base class
		self._maxSizeOption = 1

		local mt = getmetatable(self)
		if (mt ~= nil) then
			mt.__tostring = self.__tostring
		end
	end

	-- override OnMaxSizeReached()
	function c4_queue_new:OnMaxSizeReached()
		--Default: clear queue and push value to the queue. (No need to overload,

		-- Option 1: Do Nothing, new item is not added to queue
		if (self._maxSizeOption == 1) then
			
			LogInfo("Max Size Reached - do nothing, new item not added to queue (option 1)")
			return (false)
		-- Option 2: pop value, and push new value on queue
		elseif(self._maxSizeOption == 2) then
			LogInfo("Max Size Reached - pop value, and push new value on queue (option 2)")
			self:pop()
			return (true)
		-- Option 3: clear queue and DO NOT push new value onto queue
		elseif(self._maxSizeOption == 3) then
			LogInfo("Max Size Reached - clear queue and DO NOT push new value onto queue")
			self:clear()
			return (false)
		end
	end

	-- create an instance of the new queue
	local c4QueueNew = c4_queue_new:new()
	c4QueueNew:SetMaxSize(3)
	c4QueueNew:push("Item #1 in Queue")
	c4QueueNew:push("Item #2 in Queue")
	c4QueueNew:push("Item #3 in Queue")
	c4QueueNew:push("Item #4 in Queue")  -- this should cause OnMaxSizeReached() to be called and clear the queue
	assert(c4QueueNew:Size() == 3, "queue size is not equal to '3' it is: " .. c4QueueNew:Size())

	print(c4QueueNew)
	print ("done...")
end end)
package.preload['lib.c4_timer'] = (function (...)
--[[=============================================================================
    c4_timer Class

    Copyright 2016 Control4 Corporation. All Rights Reserved.
===============================================================================]]
require "common.c4_driver_declarations"
require "lib.c4_object"

-- Set template version for this file
if (TEMPLATE_VERSION ~= nil) then
	TEMPLATE_VERSION.c4_timer = "2016.01.08"
end

c4_timer = inheritsFrom(nil)

function c4_timer:construct(name, interval, units, Callback, repeating, CallbackParam)
	self._name = name
	self._timerID = TimerLibGetNextTimerID()
	self._interval = interval
	self._units = units
	self._repeating = repeating or false
	self._Callback = Callback
	self._CallbackParam = CallbackParam or ""
	self._id = 0

	gTimerLibTimers[self._timerID] = self
	if (LOG ~= nil and type(LOG) == "table") then
		LogTrace("Created timer " .. self._name)
	end
end


function c4_timer:StartTimer(...)
	if (timerTable == nil) then timerTable ={} end
	self:KillTimer()
	-- optional parameters (interval, units, repeating)
	if ... then
		local interval = select(1, ...)
		local units = select(2, ...)
		local repeating = select(3, ...)

		self._interval = interval or self._interval
		self._units = units or self._units
		self._repeating = repeating or self._repeating
	end
	if ((tonumber(self._interval) or 0) > 0) then
		if (LOG ~= nil and type(LOG) == "table") then
		end
		self._id = C4:AddTimer(self._interval, self._units, self._repeating)
	end
	timerTable[self._id] = {}
	timerTable[self._id]["name"] = self._name
end

function c4_timer:KillTimer()
	if (self._id) then
		if (timerTable  ~= nil and timerTable[self._id]  ~= nil) then timerTable[self._id] = nil end
		self._id = C4:KillTimer(self._id)
	end
end

function c4_timer:TimerStarted()
	return (self._id ~= 0)
end

function c4_timer:TimerStopped()
	return (self._id == 0)
end

function c4_timer:GetTimerInterval()
	return (self._interval)
end

function c4_timer:StartTimerToAPartition(...)
	local partition 
	if ... then
		local interval = select(1, ...)
		partition = select(2, ...)
		self._interval = interval or self._interval
	end
	self._id = C4:AddTimer(self._interval, self._units, self._repeating)
  if timerTable == nil then timerTable = {} end
	if timerTable[self._id] == nil then 
		timerTable[self._id] = {}
		timerTable[self._id]["name"] = self._name
	end
	timerTable[self._id]["partitionID"] = partition
	
end

function c4_timer:StartTimerWithCallbackParams(...)
	local params 
	if ... then
		params = select(1, ...)
		self._CallbackParam = params or self._CallbackParam
	end
	self._id = C4:AddTimer(self._interval, self._units, self._repeating)
    if timerTable == nil then timerTable = {} end
	if timerTable[self._id] == nil then 
		timerTable[self._id] = {} 
		timerTable[self._id]["name"] = self._name
	end
end

function TimerLibGetNextTimerID()
	if (gTimerLibTimerCurID == nil) then gTimerLibTimerCurID =0 end
	gTimerLibTimerCurID = gTimerLibTimerCurID + 1
	return gTimerLibTimerCurID
end

function ON_DRIVER_EARLY_INIT.c4_timer()
	gTimerLibTimers = {}
	gTimerLibTimerCurID = 0
end

function ON_DRIVER_DESTROYED.c4_timer()
	-- Kill open timers
	for k,v in pairs(gTimerLibTimers) do
		v:KillTimer()
	end
end

--[[=============================================================================
    OnTimerExpired(idTimer)

    Description:
    Function called by Director when the specified Control4 timer expires.

    Parameters:
    idTimer(string) - Timer ID of expired timer.
===============================================================================]]
function OnTimerExpired(idTimer)
	for k,v in pairs(gTimerLibTimers) do
		if (idTimer == v._id) then
			if v._repeating == false then
				v:KillTimer()
			end 
			if (v._Callback) then
				v._Callback(v._CallbackParam, idTimer)
			end
		end
	end
	if (timerTable  ~= nil and timerTable[idTimer]  ~= nil) then timerTable[idTimer] = nil end
end

--[[=============================================================================
    CreateTimer(name, interval, units, callback, repeating, callbackParam)

    Description: 
    Creates a named timer with the given attributes

    Parameters:
    name(string)       - The name of the timer being created
    interval(int)      - The amount of the given time between calls to the
                         timers callback function
    units(string)      - The time of time interval used (e.g. SECONDS, MINUTES, ...)
    callback(string)   - The function to call when the timer expires
    repeating(bool)    - Parameter indicating whether the timer should be
                         called repeatedly until cancelled
    callbackParam(...) - Parameters to be passed to the callback function

    Returns:
    A handle to the timer
===============================================================================]]
function CreateTimer(name, interval, units, callback, repeating, callbackParam)
	timer = c4_timer:new(name, interval, units, callback, repeating, callbackParam)
	return timer
end

--[[=============================================================================
    StartTimer(handle, ...)

    Description: 
    Starts the timer created by calling the CreateTimer functions

    Parameters:
    handle(timer)   - Handle to a created timer selfect
    interval(int)   - The amount of the given time between calls to the
                      timers callback function
    units(string)   - The time of time interval used (e.g. SECONDS, MINUTES, ...)
    repeating(bool) - Parameter indicating whether the timer should be
                      called repeatedly until cancelled

    Returns:
    None
===============================================================================]]
function StartTimer(handle, ...)
	handle:StartTimer(...)
end

--[[=============================================================================
    KillTimer(handle)

    Description: 
    Starts the timer created by calling the CreateTimer functions

    Parameters:
    handle(timer) - Handle to a created timer selfect

    Returns:
    None
===============================================================================]]
function KillTimer(handle)
	handle:KillTimer()
end

--[[=============================================================================
    TimerStarted(handle)

    Description: 
    Identifies whether a timer has been started or not

    Parameters:
    handle(timer) - Handle to a created timer selfect

    Returns:
    Returns true if a the given timer handle has been started, or false otherwise
===============================================================================]]
function TimerStarted(handle)
	return handle:TimerStarted()
end

--[[=============================================================================
    TimerStopped(handle)

    Description: 
    Identifies whether a timer has been stopped or not

    Parameters:
    handle(timer) - Handle to a created timer selfect

    Returns:
    Returns true if a the given timer handle has been stopped, or false otherwise
===============================================================================]]
function TimerStopped(handle)
	return handle:TimerStopped()
end

--[[=============================================================================
    GetTimerInterval(handle)

    Description: 
    Gets the interval setting of the given timer

    Parameters:
    handle(timer) - Handle to a created timer selfect

    Returns:
    Returns the interval setting of the given timer
===============================================================================]]
function GetTimerInterval(handle)
	return handle:GetTimerInterval()
end

--[[=============================================================================
    c4_timer Unit Tests
===============================================================================]]
function __test_c4_timer()
	require "test.C4Virtual"
	require "lib.c4_log"
	require "common.c4_init"

	OnDriverInit()

	local LOG = c4_log:new("test_c4_timer")
	LOG:SetLogLevel(5)
	LOG:OutputPrint(true)

	function OnTestTimerExpired()
		c4Timer:KillTimer()
	end

	-- create an instance of the timer
	c4Timer = c4_timer:new("Test", 45, "MINUTES", OnTestTimerExpired)

	assert(c4Timer._id == 0, "_id is not equal to '0' it is: " .. c4Timer._id)
	c4Timer:StartTimer()
	assert(c4Timer._id == 10001, "_id is not equal to '10001' it is: " .. c4Timer._id)
	assert(c4Timer:TimerStarted() == true, "TimerStarted is not equal to true it is: " .. tostring(c4Timer:TimerStarted()))
	assert(c4Timer:TimerStopped() == false, "TimerStopped is not equal to false it is: " .. tostring(c4Timer:TimerStopped()))
	OnTimerExpired(c4Timer._id)
	assert(c4Timer:TimerStarted() == false, "TimerStarted is not equal to false it is: " .. tostring(c4Timer:TimerStarted()))
	assert(c4Timer:TimerStopped() == true, "TimerStopped is not equal to true it is: " .. tostring(c4Timer:TimerStopped()))
end end)
package.preload['lib.c4_xml'] = (function (...)
--[[=============================================================================
    Functions for parsing and managing xml

    Copyright 2016 Control4 Corporation. All Rights Reserved.
===============================================================================]]

if (TEMPLATE_VERSION ~= nil) then
	TEMPLATE_VERSION.c4_xml = "2016.01.08"
end

--[[=============================================================================
    GetParsedXmlNode(tXml, node)

    Description: 
    Find the specified node within the given table

    Parameters:
    tXml(table)  - Xml fragment containing the node we are looking for
    node(string) - The name of the node

    Returns:
    nil or the specified node within the table
===============================================================================]]
function GetParsedXmlNode(tXml, node)
	for k, v in pairs(tXml["ChildNodes"]) do
		if (v["Name"] == node) then
			return v["ChildNodes"]
		end
	end

	return nil
end

--[[=============================================================================
    GetParsedXmlValuesByKey(tXml, node, key, keyIsNumber)

    Description: 
    Find the specified node element within the given table

    Parameters:
    tXml(table)       - Xml fragment to find the value in
    node(string)      - The name of the node
    key(string)       - The name of the key
    keyIsNumber(bool) - Indicates whether the table index is a number or a string

    Returns:
    nil or a table of the found values within the Xml
===============================================================================]]
function GetParsedXmlValuesByKey(tXml, node, key, keyIsNumber)
	local tParams = {}

	keyIsNumber = keyIsNumber or false
	for k,v in pairs(tXml) do
		if (v["Name"] == node) then
			local keyValue
			
			-- get the key
			for nodeKey, nodeValue in pairs(v["ChildNodes"]) do
				if (nodeValue["Name"] == key) then
					if (keyIsNumber == true) then
						keyValue = tonumber(nodeValue.Value)
					else
						keyValue = tostring(nodeValue.Value)
					end
					break
				end
			end

			-- get other tags
			tParams[keyValue] = {}
			for nodeKey, nodeValue in pairs(v["ChildNodes"]) do
				if (nodeValue["Name"] ~= key) then
					tParams[keyValue][nodeValue.Name] = nodeValue.Value
				end
			end
		end
	end

	return tParams
end

--[[=============================================================================
    GetParsedXmlVaulesByKeyAttribute(tXml, node, key, keyIsNumber)

    Description: 
    Find the specified node attribute within the given table

    Parameters:
    tXml(table)       - Xml fragment to find the value in
    node(string)      - The name of the node
    key(string)       - The name of the key
    keyIsNumber(bool) - Indicates whether the table index is a number or a string

    Returns:
    nil or a table of the found values within the Xml
===============================================================================]]
function GetParsedXmlVaulesByKeyAttribute(tXml, node, key, keyIsNumber)
	local tParams = {}

	keyIsNumber = keyIsNumber or false
	for k,v in pairs(tXml["ChildNodes"]) do
		if (v["Name"] == node) then
			local keyValue

			if (keyIsNumber == true) then
				keyValue = tonumber(v["Attributes"][key])
			else
				keyValue = v["Attributes"][key]
			end
			
			tParams[keyValue] = v["Value"]
		end
	end

	return tParams
end

--[[=============================================================================
    BuildSimpleXml(tag, tData, escapeValue)

    Description: 
    Find the specified node within the given table

    Parameters:
    tag(string)       - Xml tag name to create
    tData(table)      - key value pairs that will be added as elements under tag
    escapeValue(bool) - Indicates whether the values should be escaped or not

    Returns:
    nil or an Xml fragment the specified node within the table
===============================================================================]]
function BuildSimpleXml(tag, tData, escapeValue)
	local xml = ""
	
	if (tag ~= nil) then
		xml = "<" .. tag .. ">"
	end
	
	for k,v in pairs(tData) do
		xml = xml .. "<" .. k
		if (type(v) == "table") then
			-- handle attributes
			for kAttrib, vAttrib in pairs(v.attributes) do
				xml = xml .. ' ' .. kAttrib .. '=\"' .. vAttrib .. '\"'
			end
			xml = xml .. ">" .. InsertValue(v.value, escapeValue) .. "</" .. k .. ">"
		else
			xml = xml .. ">" .. InsertValue(v, escapeValue) .. "</" .. k .. ">"
		end
	end
	
	if (tag ~= nil) then
		xml = xml .. "</" .. tag .. ">"
	end

	--DbgTrace("BuildSimpleXml(): " .. xml)

	return xml
end

--[[=============================================================================
    InsertValue(value, escapeValue)

    Description: 
    Return the given value if escapeValue is true it will escape any special
    characters in the value

    Parameters:
    value(string)     - value to be manipulated
    escapeValue(bool) - Indicates whether the values should be escaped or not

    Returns:
    The value given or an escaped value if specified
===============================================================================]]
function InsertValue(value, escapeValue)

	if (escapeValue) then
		value = C4:XmlEscapeString(tostring(value))
	end

	return value
end

--[[=============================================================================
    StartElement(tag)

    Description: 
    Wrap the given tag as an Xml element (i.e. <tag>)

    Parameters:
    tag(string) - The name of the item to be wrapped as a starting Xml element

    Returns:
    The value wrapped as Xml tag
===============================================================================]]
function StartElement(tag)
	return "<" .. tag .. ">"
end

--[[=============================================================================
    EndElement(tag)

    Description: 
    Wrap the given tag as an Xml end element (i.e. </tag>)

    Parameters:
    tag(string) - The name of the item to be wrapped as a ending Xml element

    Returns:
    The value wrapped as ending Xml tag
===============================================================================]]
function EndElement(tag)
	return "</" .. tag .. ">"
end

--[[=============================================================================
    AddElement(tag, data)

    Description: 
    Wrap the given tag and value as an Xml element (i.e. <tag>data</tag>)

    Parameters:
    tag(string)  - The name of the item to be wrapped as an Xml element
    data(string) - The value of the Xml element being created

    Returns:
    The value wrapped as Xml tag and value
===============================================================================]]
function AddElement(tag, data)
	LogTrace("tag = " .. tag)
	LogTrace("data = " .. data)
	
	return "<" .. tag .. ">" .. data .. "</" .. tag .. ">"
end
 end)
package.preload['panel_proxy.pgm_info'] = (function (...)
--[[=============================================================================
    PgmInformation Class

    Copyright 2015 Control4 Corporation. All Rights Reserved.
===============================================================================]]
require "lib.c4_object"
require "panel_proxy.relay_notifies"

TEMPLATE_VERSION.securitypanel = "6"

PgmInfoList = {}
PgmInformation = inheritsFrom(nil)

--[[=============================================================================
    Functions that are meant to be private to the class
===============================================================================]]
function PgmInformation:construct(PgmID)

	self._PgmID = PgmID
	self._IsOpen = false
	self._NeedToSendInitialInfo = true

	PgmInfoList[PgmID] = self
	NOTIFY.PANEL_ADD_PGM(self._PgmID, TheSecurityPanel._BindingID)
end

function PgmInformation:destruct()
	NOTIFY.PANEL_REMOVE_PGM(self._PgmID, TheSecurityPanel._BindingID)
	PgmInfoList[self._PgmID] = nil
end

function PgmInformation:PgmXML()
	local PgmXMLInfo = {}

	table.insert(PgmXMLInfo, MakeXMLNode("id", tostring(self._PgmID)))
	table.insert(PgmXMLInfo, MakeXMLNode("is_open", tostring(self:GetPgmState())))

	return MakeXMLNode("pgm", table.concat(PgmXMLInfo, "\n"))
end

--[[=============================================================================
    Functions that are wrappered and meant to be exposed to the driver
===============================================================================]]
function PgmInformation:SetPgmState(IsOpen, Initializing)
	local JustInitializing = Initializing or false

	if ((self._IsOpen ~= IsOpen) or self._NeedToSendInitialInfo or JustInitializing) then
		self._IsOpen = IsOpen
		LogDebug("!!!!!!   Pgm %d %s  !!!!!!", tonumber(self._PgmID), tostring(self:GetPgmState()))
		NOTIFY.PANEL_PGM_STATE(self._PgmID, self._IsOpen, self._NeedToSendInitialInfo, TheSecurityPanel._BindingID)
		self._NeedToSendInitialInfo = false
	end
end

function PgmInformation:GetPgmState()
	return self._IsOpen
end end)
package.preload['panel_proxy.relay_commands'] = (function (...)
--[[=============================================================================
    Pgm Relay Proxy Command Functions

    Copyright 2015 Control4 Corporation. All Rights Reserved.
===============================================================================]]
require "common.c4_command"
require "common.c4_utils"
require "panel_proxy.pgm_info"

TEMPLATE_VERSION.securitypanel = "6"

-- Ksenia Relay commands
function PRX_CMD.OPEN(idBinding, tParams)
	LogTrace("Ksenia Relay PRX_CMD.OPEN: "..idBinding)
    outID = findOutput(idBinding)
	changeOutStatus(outID, "OFF", idBinding) -- LR cambiato da ON a OFF 2020-06-30
end

function changeOutStatus(outID,sta, idb)
	local outValue = ""
	if sta == "OFF" then -- chiuso, OKIO gestione ANALOG
		--outValue = "ON"
		KSENIAData['ksenia']['outputs'][outID].STA = sta 
		--OUTPUT C4:SendToProxy(idb, "OPENED",  "", "NOTIFY")
	elseif sta == "ON" then
		--outValue = "OFF"
		KSENIAData['ksenia']['outputs'][outID].STA = sta 
		--OUTPUT C4:SendToProxy(idb, "CLOSED",  "", "NOTIFY")
	elseif sta == "TGL" then
		local oldval = KSENIAData['ksenia']['outputs'][outID].STA
		if oldval == "OFF" then
			KSENIAData['ksenia']['outputs'][outID].STA = "ON" 
			--OUTPUT C4:SendToProxy(idb, "CLOSED",  "", "NOTIFY")
		elseif oldval == "ON" then
			KSENIAData['ksenia']['outputs'][outID].STA = "OFF"
			--OUTPUT C4:SendToProxy(idb, "OPENED",  "", "NOTIFY")
		end
	end
	outValue = KSENIAData['ksenia']['outputs'][outID].STA
	local ksOutID = tonumber(KSENIAData['ksenia']['outputs'][outID].ID)
	local ks_function = "Output"

	LogTrace("ks_function: "..ks_function.." KS out ID: "..ksOutID.." value: "..outValue)
	setOutStatus(outID, false)
	--actions.openCmdSocket(TMP_USER_PIN, socket_type.output, ksOutID, sta)
	actions.exeM2Mcommand(socket_type.installer, "OUTPUT",  outValue, outID)

end

function PRX_CMD.CLOSE(idBinding, tParams)
	LogTrace("Ksenia Relay PRX_CMD.CLOSE: "..idBinding)
    outID = findOutput(idBinding)
	changeOutStatus(outID, "ON", idBinding) -- LR cambiato da OFF a ON 2020-06-30
end

function PRX_CMD.TOGGLE(idBinding, tParams)
	LogTrace("Ksenia Relay PRX_CMD.TOOGLE: "..idBinding)
	
	outID = findOutput(idBinding)
	outID = tonumber(outID)
	local value = KSENIAData['ksenia']['outputs'][outID].STA

	-- if value ~= "OFF" then 
	-- 	changeOutStatus(outID, "TGL", idBinding)
	-- else
	-- 	changeOutStatus(outID, "TGL", idBinding)
	-- end
	-- secondo Matteo equivale a:
	changeOutStatus(outID, "TGL", idBinding)
end
function PRX_CMD.TRIGGER(idBinding, tParams)
	LogTrace("Ksenia Relay PRX_CMD.TRIGGER: "..idBinding)
    local outID = findOutput(idBinding)
	local TriggerTime = tParams["TIME"]
	
	changeOutStatus(outID, "ON", idBinding)
	
	local t = C4:SetTimer(TriggerTime, function(timer)
					changeOutStatus(outID, "OFF", idBinding)
				 end)
end	
	

function OutTriggerTimerExpire(expOutID)
	changeOutStatus(timerTable[OutTriggerTimer._id]["outID"], "ON", idBinding)
end

function findOutput(idBinding)
    for index,output in pairs(KSENIAData['ksenia']['outputs']) do
	   if KSENIAData['ksenia']['outputs'][index].contacts == idBinding then
			--out_nr = KSENIAData['ksenia']['outputs'][index].output_number
			return index
	   end
    end
end

-- PGM Relay commands
function PRX_CMD.PGM_OPEN(idBinding, tParams)
	if (TheSecurityPanel) then
		TheSecurityPanel:PrxSendPgmCommand(tonumber(tParams.PGM_ID), "Open", 0)
	end
end

function PRX_CMD.PGM_CLOSE(idBinding, tParams)
	if (TheSecurityPanel) then
		TheSecurityPanel:PrxSendPgmCommand(tonumber(tParams.PGM_ID), "Close", 0)
	end
end

function PRX_CMD.PGM_TOGGLE(idBinding, tParams)
	if (TheSecurityPanel) then
		TheSecurityPanel:PrxSendPgmCommand(tonumber(tParams.PGM_ID), "Toggle", 0)
	end
end

function PRX_CMD.PGM_TRIGGER(idBinding, tParams)
	local TargPgm = PgmInfoList[tonumber(tParams.PGM_ID)]
	local TriggerTime = tParams["TIME"]

	if (TheSecurityPanel and TargPgm) then
		TheSecurityPanel:PrxSendPgmCommand(tonumber(tParams.PGM_ID), "Trigger", TriggerTime)
	end
end
 end)
package.preload['panel_proxy.relay_notifies'] = (function (...)
--[[=============================================================================
    Notifications for the Relays (Pgms) on a security panel

    Copyright 2015 Control4 Corporation. All Rights Reserved.
===============================================================================]]
require "common.c4_notify"

TEMPLATE_VERSION.securitypanel = "6"

function NOTIFY.INITIAL_RELAY_STATE(IsOpen, BindingID)
	LogTrace("Sending Initial Relay State on Binding %d : %s", tonumber(BindingID), tostring((IsOpen and "Open" or "Closed")))
	SendSimpleNotify(IsOpen and "STATE_OPENED" or "STATE_CLOSED", BindingID)
end

function NOTIFY.RELAY_STATE(IsOpen, BindingID)
	LogTrace("Sending Relay State on Binding %d : %s", tonumber(BindingID), tostring((IsOpen and "Open" or "Closed")))
	SendSimpleNotify(IsOpen and "OPENED" or "CLOSED", BindingID)
end end)
package.preload['panel_proxy.securitypanel'] = (function (...)
--[[=============================================================================
    SecurityPanel Class

    Copyright 2016 Control4 Corporation. All Rights Reserved.
===============================================================================]]
require "lib.c4_object"
require "panel_proxy.zone_info"
require "panel_proxy.pgm_info"
require "panel_proxy.securitypanel_commands"
require "panel_proxy.securitypanel_notifies"
require "panel_proxy.securitypanel_functions"
require "panel_proxy.relay_commands"

TEMPLATE_VERSION.securitypanel = "2016.07.29"

TheSecurityPanel = nil
SecurityPanel = inheritsFrom(nil)

--[[=============================================================================
    Functions that are meant to be private to the class
===============================================================================]]
function SecurityPanel:construct(BindingID)
	self._BindingID = BindingID
end

function SecurityPanel:Initialize()
	self:InitializeVariables()
	SecCom_GetPersistBypassData()
end

function SecurityPanel:InitializeVariables()
	self._NextTroubleIndex = 0
	self._TroubleTable = {}
end

function SecurityPanel:GetNextTroubleID()

	if (self._NextTroubleIndex == nil) then
		return 0
	end

	self._NextTroubleIndex = self._NextTroubleIndex + 1
	return self._NextTroubleIndex
end

--[[=============================================================================
    Functions for handling request from the Panel Proxy
===============================================================================]]
function SecurityPanel:PrxReadPanelInfo()

	-- Force each zone remove the data guard so the value
	-- from the panel will be used.
	for _, CurZone in pairs(ZoneInfoList) do
		CurZone:SetDataGuardFlag(false)
	end

	SecCom_ReadPanelInfo()
end

function SecurityPanel:PrxGetPanelSetup()
	self:PrxGetAllPartitionsInfo()
end

function SecurityPanel:PrxGetAllPartitionsInfo()
	local AllPartitionsInfos = {}

	LogTrace("SecurityPanel.GetAllPartitionsInfo")
	for k, v in pairs(SecurityPartitionIndexList) do
		table.insert(AllPartitionsInfos, v:PartitionXML())
	end

	NOTIFY.ALL_PARTITIONS_INFO(MakeXMLNode("partitions", table.concat(AllPartitionsInfos, "\n")), self._BindingID)
end

function SecurityPanel:PrxGetAllZonesInfo()
	local AllZoneInfos = {}

	LogTrace("SecurityPanel.GetAllZonesInfo")
	for k, v in pairs(ZoneInfoList) do
		table.insert(AllZoneInfos, v:ZonePanelXML())
	end

	NOTIFY.ALL_ZONES_INFO(MakeXMLNode("zones", table.concat(AllZoneInfos, "\n")), self._BindingID)
end

function SecurityPanel:PrxGetAllPgmsInfo()
	local AllPgmInfos = {}

	LogTrace("SecurityPanel.GetAllPgmsInfo")
	for k, v in pairs(PgmInfoList) do
		table.insert(AllPgmInfos, v:PgmXML())
	end

	NOTIFY.ALL_PGMS_INFO(MakeXMLNode("pgms", table.concat(AllPgmInfos, "\n")), self._BindingID)
end

function SecurityPanel:PrxSetTimeDate(TargYear, TargMonth, TargDay, TargHour, TargMinute, TargSecond, InterfaceID)
	LogTrace("SecurityPanel.SetTimeDate  Date is: %02d/%02d/%d  Time is: %02d:%02d:%02d", tonumber(TargMonth), tonumber(TargDay), tonumber(TargYear), tonumber(TargHour), tonumber(TargMinute), tonumber(TargSecond))
	SecCom_SendDateAndTime(TargYear, TargMonth, TargDay, TargHour, TargMinute, TargSecond, InterfaceID)
end

function SecurityPanel:PrxSetPartitionEnabled(PartitionID, Enabled, InterfaceID)
	SecCom_SendPartitionEnabled(PartitionID, Enabled, InterfaceID)
end

function SecurityPanel:PrxSendPgmCommand(PgmID, Command, Time)
	if (Command == "Open") then
		SecCom_SendPgmControlOpen(PgmID)
	elseif (Command == "Close") then
		SecCom_SendPgmControlClose(PgmID)
	elseif (Command == "Toggle") then
		SecCom_SendPgmControlToggle(PgmID)
	elseif (Command == "Trigger") then
		SecCom_SendPgmControlTrigger(PgmID, Time)
	end
end

function SecurityPanel:PrxSetZoneInfo(ZoneID, ZoneName, ZoneTypeID, DataGuardFlag, InterfaceID)
	LogTrace("SecurityPanel.PrxSetZoneInfo  Params are %d %s %s", tonumber(ZoneID), tostring(ZoneName), tostring(ZoneTypeID))

	local TargZone = ZoneInfoList[ZoneID]
	if (TargZone ~= nil) then
		TargZone:SetDataGuardFlag(false)
		SecCom_SendSetZoneInfo(ZoneID, ZoneName, ZoneTypeID, InterfaceID)
		TargZone:SetDataGuardFlag(DataGuardFlag)
	else
		-- If the proxy is trying to tell us about a zone that we don't have, tell the proxy to get rid of it.
		kwLogTrace(6, "#unknow #Zone #Status","ERROR: SecurityPanel:PrxSetZoneInfo call a non existing zone: "..ZoneID)
		-- NOTIFY.PANEL_REMOVE_ZONE(ZoneID, self._BindingID)
	end
end

function SecurityPanel:PrxGetZoneInfo(TargZoneID)
	LogTrace("SecurityPanel.PrxGetZoneInfo ZoneID[%d]", tonumber(TargZoneID))
	return ZoneInfoList[TargZoneID]:ZonePanelXML()
end

function SecurityPanel:PrxGetPgmState(TargPgmID)
	return PgmInfoList[TargPgmID]:PgmXML()
end

function SecurityPanel:PrxGetAllPgmStates()
	local AllPgmInfos = {}

	LogTrace("SecurityPanel.GetAllPgmStates")
	for k, v in pairs(PgmInfoList) do
		table.insert(AllPgmInfos, v:PgmXML())
	end

	NOTIFY.ALL_PGMS_INFO(MakeXMLNode("pgms", table.concat(AllPgmInfos, "\n")), self._BindingID)
end

--[[=============================================================================
    Functions that are wrappered and meant to be exposed to the driver
===============================================================================]]
function SecurityPanel:TroubleStart(TroubleStr)
	local TroubleID = TroubleStr or self:GetNextTroubleID()

	if (TroubleID ~= nil) then
		self._TroubleTable[TroubleID] = TroubleStr
		LogTrace("SecurityPanel: TroubleStart String is: %s %s", tostring(TroubleStr), tostring(TroubleID))
		NOTIFY.TROUBLE_START(TroubleStr, TroubleID, self._BindingID)
	end

	return TroubleID
end

function SecurityPanel:TroubleClear(Identifier)

	if (Identifier ~= nil) then

		if (self._TroubleTable ~= nil) then
			self._TroubleTable[Identifier] = nil
		end

		NOTIFY.TROUBLE_CLEAR(Identifier, self._BindingID)
	end
end

function SecurityPanel:AddZone(ZoneID)
	local nZoneID = tonumber(ZoneID)

	LogTrace("SecurityPanel.AddZone %d", nZoneID)
	if (ZoneInfoList[nZoneID] == nil) then
		ZoneInformation:new(nZoneID)
	end
end

function SecurityPanel:RemoveZone(ZoneID)
	local nZoneID = tonumber(ZoneID)

	LogTrace("SecurityPanel.RemovePanel %d", tonumber(nZoneID))
	for k, v in pairs(SecurityPartitionIndexList) do
		v:RemoveZone(ZoneID)
	end

	if (ZoneInfoList[nZoneID] ~= nil) then
		ZoneInfoList[nZoneID]:destruct()
	end
end

function SecurityPanel:AddPgm(PgmID)
	local nPgmID = tonumber(PgmID)

	LogTrace("SecurityPanel.AddPgm %d", nPgmID)
	if (PgmInfoList[nPgmID] == nil) then
		PgmInformation:new(PgmID)
	end
end

function SecurityPanel:RemovePgm(PgmID)
	local nPgmID = tonumber(PgmID)

	LogTrace("SecurityPanel.RemovePgm %d", nPgmID)
	if (PgmInfoList[nPgmID] ~= nil) then
		PgmInfoList[nPgmID]:destruct()
	end
end

function SecurityPanel:RequestAdditionalInfo(Prompt, CurrentInfoStr, FunctionName, MaskData, InterfaceID)
	LogTrace("SecurityPanel.RequestAdditionalInfo")
	NOTIFY.REQUEST_ADDITIONAL_PANEL_INFO(Prompt, CurrentInfoStr, FunctionName, MaskData, InterfaceID, self._BindingID)
end

function SecurityPanel:HandleAdditionalInfo(InfoString, NewInfo, FunctionName, InterfaceID)
	LogTrace("SecurityPanel.HandleAdditionalInfo")
	SecCom_ProcessAdditionalPanelInfo(InfoString, NewInfo, FunctionName, InterfaceID)
end

function SecurityPanel:SynchronizePanelInfo()
	LogTrace("SecurityPanel: SynchronizePanelInfo")
	NOTIFY.SYNC_PANEL_INFO(self._BindingID)
end

function SecurityPanel:ReportPanelInitialized()
	LogTrace("SecurityPanel: ReportPanelInitialized")
	NOTIFY.PANEL_INITIALIZED(self._BindingID)
end end)
package.preload['panel_proxy.securitypanel_commands'] = (function (...)
--[[=============================================================================
    Commands for the SecurityPanel Proxy

    Copyright 2016 Control4 Corporation. All Rights Reserved.
===============================================================================]]
require "common.c4_command"
require "common.c4_utils"

TEMPLATE_VERSION.securitypanel = "2016.08.01"

function PRX_CMD.READ_PANEL_INFO(idBinding, tParams)
	if (TheSecurityPanel) then
		TheSecurityPanel:PrxReadPanelInfo()
	end
end

function PRX_CMD.GET_PANEL_SETUP(idBinding, tParams)
	if (TheSecurityPanel) then
		TheSecurityPanel:PrxGetPanelSetup()
	end
end

function PRX_CMD.GET_ALL_PARTITION_INFO(idBinding, tParams)
	if (TheSecurityPanel) then
		TheSecurityPanel:PrxGetAllPartitionsInfo()
	end
end

function PRX_CMD.GET_ALL_ZONE_INFO(idBinding, tParams)
	if (TheSecurityPanel) then
		TheSecurityPanel:PrxGetAllZonesInfo()
	end
end

function PRX_CMD.GET_ALL_PGM_INFO(idBinding, tParams)
	if (TheSecurityPanel) then
		TheSecurityPanel:PrxGetAllPgmsInfo()
	end
end

function PRX_CMD.SET_PANEL_TIME_DATE(idBinding, tParams)
	local CurYear = tonumber(tParams.YEAR)
	local CurMonth = tonumber(tParams.MONTH)
	local CurDay = tonumber(tParams.DAY)
	local CurHour = tonumber(tParams.HOUR)
	local CurMinute = tonumber(tParams.MINUTE)
	local CurSecond = tonumber(tParams.SECOND)
	local InterfaceID = tostring(tParams.INTERFACE_ID)
	
	if (TheSecurityPanel) then
		TheSecurityPanel:PrxSetTimeDate(CurYear, CurMonth, CurDay, CurHour, CurMinute, CurSecond, InterfaceID)
	end
end

function PRX_CMD.SET_PARTITION_ENABLED(idBinding, tParams)
	local PartitionID = tonumber(tParams.PARTITION_ID)
	local PartitionEnabled = tParams.ENABLED
	local InterfaceID = tParams.INTERFACE_ID

	if (TheSecurityPanel) then
		TheSecurityPanel:PrxSetPartitionEnabled(PartitionID, PartitionEnabled, InterfaceID)
	end
end

function PRX_CMD.SEND_PGM_COMMAND(idBinding, tParams)
	local PgmID = tonumber(tParams.PGM_ID)
	local PgmCommand = tParams.COMMAND

	if (TheSecurityPanel) then
		TheSecurityPanel:PrxSendPgmCommand(PgmID, PgmCommand)
	end
end

function PRX_CMD.SET_ZONE_INFO(idBinding, tParams)
	local ZoneID = tonumber(tParams.ZONE_ID)
	local ZoneName = tParams.NAME
	local ZoneTypeID = tonumber(tParams.TYPE_ID)
	local DataGuarded = toboolean(tParams.DATA_GUARDED)
	local InterfaceID = tParams.INTERFACE_ID

	if (TheSecurityPanel) then
		TheSecurityPanel:PrxSetZoneInfo(ZoneID, ZoneName, ZoneTypeID, DataGuarded, InterfaceID)
	end
end

function PRX_CMD.ADDITIONAL_PANEL_INFO(idBinding, tParams)
	local InfoString = tParams.INFO_STRING
	local NewInfo = tParams.NEW_INFO
	local FunctionName = tParams.FUNCTION_NAME
	local InterfaceID = tParams.INTERFACE_ID

	if (TheSecurityPanel) then
		TheSecurityPanel:HandleAdditionalInfo(InfoString, NewInfo, FunctionName, InterfaceID)
	end
end
 end)
package.preload['panel_proxy.securitypanel_functions'] = (function (...)
--[[=============================================================================
    Functions dealing with the management of panel information, zones and their
    states, as well as pgms and their states

    Copyright 2015 Control4 Corporation. All Rights Reserved.
===============================================================================]]
TEMPLATE_VERSION.securitypanel = "6"

--[[=============================================================================
    IsPgmValid(PgmID)

    Description: 
    Identifies whether or not the given PgmID has been added to the system

    Parameters:
    PgmID(int) - The number for the pgm in question

    Returns:
    A boolean indicating the validity of the specified pgm
===============================================================================]]
function IsPgmValid(PgmID)
	return (PgmInfoList[tonumber(PgmID)] ~= nil)
end

--[[=============================================================================
    SetPgmState(PgmID, IsOpen, Initializing)

    Description: 
    Sets the state of the specified pgm

    Parameters:
    PgmID(int)         - The number for the pgm whose state is being set
    IsOpen(bool)       - Indicates the state of the specified pgm
    Initializing(bool) - Indicates whether this is the initialization of the
                         pgm. If true then the programming events within the 
                         system will not be fired.

    Returns:
    None
===============================================================================]]
function SetPgmState(PgmID, IsOpen, Initializing)
	if (not IsPgmValid(PgmID)) then
		AddPgm(PgmID)
	end

	PgmInfoList[PgmID]:SetPgmState(IsOpen, Initializing)
end

--[[=============================================================================
    IsPgmOpen(PgmID)

    Description: 
    Identifies whether or not the specified zone is open

    Parameters:
    PgmID(int) - The number for the pgm whose open state is in question

    Returns:
    A boolean indicating the open state of the given pgm
===============================================================================]]
function IsPgmOpen(PgmID)
	if (not IsPgmValid(PgmID)) then
		return false
	end
	
	return PgmInfoList[PgmID]:GetPgmState()
end

--[[=============================================================================
    AddPgm(PgmID)

    Description: 
    Adds the specified Pgm to the managed list

    Parameters:
    PgmID(int) - The number of the pgm that is being added
===============================================================================]]
function AddPgm(PgmID)
	TheSecurityPanel:AddPgm(PgmID)
end

--[[=============================================================================
    RemovePgm(PgmID)

    Description: 
    Removes the specified Pgm from the managed list

    Parameters:
    PgmID(int) - The number of the pgm that is being removed
===============================================================================]]
function RemovePgm(PgmID)
	TheSecurityPanel:RemovePgm(PgmID)
end

--[[=============================================================================
    SetDefaultZoneName(ZoneName)

    Description: 
    Set the default label for the zone in the system, when no label is given

    Parameters:
    ZoneName(string) - The label to use for unnamed zones

    Returns:
    None
===============================================================================]]
function SetDefaultZoneName(ZoneName)
	DefaultZoneName = tostring(ZoneName)
end

--[[=============================================================================
    IsZoneValid(ZoneID)

    Description: 
    Identifies whether or not the given ZoneID has been added to the system

    Parameters:
    ZoneID(int) - The number for the zone in question

    Returns:
    A boolean indicating the validity of the specified zone
===============================================================================]]
function IsZoneValid(ZoneID)
	return (ZoneInfoList[tonumber(ZoneID)] ~= nil)
end

--[[=============================================================================
    GetTotalPgmCount()

    Description: 
    Gets the current number of PGMs that have been created by the driver

    Returns:
    Returns the current number of PGMs that have been created by the driver
===============================================================================]]
function GetTotalPgmCount()
	return #PgmInfoList
end

--[[=============================================================================
    GetTotalZoneCount()

    Description: 
    Gets the current number of zones that have been created by the driver

    Returns:
    Returns the current number of zones that havee been created by the driver
===============================================================================]]
function GetTotalZoneCount()
	return #ZoneInfoList
end

--[[=============================================================================
    IsZoneBypassed(ZoneID)

    Description: 
    Identifies whether or not the specified zone id has been bypassed

    Parameters:
    ZoneID(int) - The number for the zone whose bypass state is in question

    Returns:
    A boolean indicating the bypass state of the given zone
===============================================================================]]
function IsZoneBypassed(ZoneID)
	if (IsZoneValid(ZoneID)) then
		return ZoneInfoList[tonumber(ZoneID)]:IsBypassed()
	else
		return false
	end
end

--[[=============================================================================
    IsZoneOpen(ZoneID)

    Description: 
    Identifies whether or not the specified zone is open

    Parameters:
    ZoneID(int) - The number for the zone whose open state is in question

    Returns:
    A boolean indicating the open state of the given zone
===============================================================================]]
function IsZoneOpen(ZoneID)
	if (IsZoneValid(ZoneID)) then
		return ZoneInfoList[tonumber(ZoneID)]:IsOpen()
	else
		return false
	end
end

--[[=============================================================================
    GetZoneType(ZoneID)

    Description: 
    Identifies the type of the zone specified

    Parameters:
    ZoneID(int) - The number for the zone whose type is in question

    Returns:
    The panels zone type
===============================================================================]]
function GetZoneType(ZoneID)
	if (IsZoneValid(ZoneID)) then
		return ZoneInfoList[tonumber(ZoneID)]:GetZoneType()
	else
		return 0
	end
end

--[[=============================================================================
    SetZoneInfo(ZoneID, ZoneName, ZoneTypeID, ZoneTypeID_C4)

    Description: 
    Set the details for the specified zones

    Parameters:
    ZoneID(int)       - The number for the zone whose state is being set
    ZoneName(string)  - The identifying label of the zone
    ZoneTypeID(int)   - The zone type from the perspective of the vendor
    C4ZoneTypeID(int) - The control4 zone type that maps the vendor specific 
                        type with the control4 sensor types.

    Control4 Zone Types
    ==========================
    Unknown         = 0
    Contact Sensor  = 1
    Exterior Door   = 2
    Exterior Window = 3
    Interior Door   = 4
    Motion Sensor   = 5
    Fire            = 6
    Gas             = 7
    Carbon Monoxide = 8
    Heat            = 9
    Water           = 10
    Smoke           = 11
    Pressure        = 12
    Glass Break     = 13
    Gate            = 14
    Garage Door     = 15
===============================================================================]]
function SetZoneInfo(ZoneID, ZoneName, ZoneTypeID, ZoneTypeID_C4)
	local nZoneID = tonumber(ZoneID)
    if (not IsZoneValid(nZoneID)) then
		AddZone(nZoneID)
	end

	return ZoneInfoList[nZoneID]:SetZoneInfo(ZoneName, ZoneTypeID, ZoneTypeID_C4)
end

--[[=============================================================================
    AddZone(ZoneID)

    Description:
    Adds the specified zone number to the list of managed/monitored zones

    Parameters:
    ZoneID(int) - The number for the zone that is being added
===============================================================================]]
function AddZone(ZoneID)
	TheSecurityPanel:AddZone(ZoneID)
end

--[[=============================================================================
    RemoveZone(ZoneID)

    Description:
    Removes the specified zone number from the list of managed/monitored zones

    Parameters:
    ZoneID(int) - The number for the zone that is being removed
===============================================================================]]
function RemoveZone(ZoneID)
	TheSecurityPanel:RemoveZone(ZoneID)
end

--[[=============================================================================
    SetZoneState(ZoneID, IsOpen, Initializing)

    Description: 
    Sets the specified zones state with the system

    Parameters:
    ZoneID(int)        - The number for the zone whose state is being set
    IsOpen(bool)       - Indicates the state of the specified zone
    Initializing(bool) - Indicates whether this is the initialization of the
                         zone. If true then the programming events within the 
                         system will not be fired.

    Returns:
    True if something changed, otherwise False
===============================================================================]]
function SetZoneState(ZoneID, IsOpen, Initializing)
    if (ZoneInfoList[tonumber(ZoneID)] ~= nil) then
		return ZoneInfoList[tonumber(ZoneID)]:SetZoneState(IsOpen, Initializing)
	else
		return false
	end
end

--[[=============================================================================
    SetZoneBypassState(ZoneID, IsBypassed, Initializing)

    Description: 
    Sets the specified zones bypass state with the system

    Parameters:
    ZoneID(int)        - The number for the zone whose state is being set
    IsBypassed(bool)   - Indicates whether the zone has been bypassed for the
                         specified zone
    Initializing(bool) - Indicates whether this is the initialization of the
                         zone. If true then the programming events within the 
                         system will not be fired.

    Returns:
    True if something changed, otherwise False
===============================================================================]]
function SetZoneBypassState(ZoneID, IsBypassed, Initializing)
	if (ZoneInfoList[tonumber(ZoneID)] ~= nil) then
		return ZoneInfoList[tonumber(ZoneID)]:SetBypassState(IsBypassed, Initializing)
	else
		return false
	end
end

--[[=============================================================================
    StartTroubleCondition(TroubleMessage)

    Description: 
    Sets the given string as a trouble condition with the panel

    Parameters:
    TroubleMessage(string) - The trouble condition to set for the panel

    Returns:
    An identifier to uniquely identify this trouble condition with the panel.
===============================================================================]]
function StartTroubleCondition(TroubleMessage)
	return TheSecurityPanel:TroubleStart(TroubleMessage)
end

--[[=============================================================================
    ClearTroubleCondition(Identifier)

    Description: 
    Clears the trouble condition with the panel

    Parameters:
    Identifier(string) - An identifier to uniquely identify this trouble
                         condition with the panel.
===============================================================================]]
function ClearTroubleCondition(Identifier)
	TheSecurityPanel:TroubleClear(Identifier)
end

--[[=============================================================================
    function PanelRequestAdditionalInfo(Prompt, CurrentInfoStr, FunctionName, MaskData, InterfaceID)

    Description: 
    Provides a mechanism to ask the UI for the security panel to provide more
    info, the most common use case would be if a user code or an installers code
    would be required to complete a desired action.

    Parameters:
    Prompt(string)            - The prompt that the UI will display when asking
                                for the additional information
    CurrentInfoString(string) - A string of current information that will be
                                passed along as the new information is requested
                                as to what the driver should do with the new
                                information.  Usually it would indicate which
                                routine should be called and what parameters
                                should be passed to that routine.
    FunctionName(string)      - Optional name of a function that the handling
                                routine should call when the additional info
                                is provided
    MaskData(boolean)         - Indicates whether or not the UI should hide the
                                data (i.e. just print asterisks for letters) as
                                the requested data is entered
    InterfaceID(string)       - Unique id of the interface that originally made
                                the request
===============================================================================]]
function PanelRequestAdditionalInfo(Prompt, CurrentInfoStr, FunctionName, MaskData, InterfaceID)
	TheSecurityPanel:RequestAdditionalInfo(Prompt, CurrentInfoStr, FunctionName, MaskData, InterfaceID)
end

--[[=============================================================================
    SynchronizePanelInfo()

    Description: 
    Notifies the proxy that the driver would like to resynch the panels zone
    information with that retained by the proxy. This allows to identify when the
    proxy is out of synch with the driver and do some house cleaning
===============================================================================]]
function SynchronizePanelInfo()
	TheSecurityPanel:SynchronizePanelInfo()
end

--[[=============================================================================
    ReportPanelInitialized()

    Description: 
    Notifies the proxy that the driver is fully initialized and ready to receive
    information and synchronize if needed.
===============================================================================]]
function ReportPanelInitialized()
	TheSecurityPanel:ReportPanelInitialized()
end

 end)
package.preload['panel_proxy.securitypanel_notifies'] = (function (...)
--[[=============================================================================
    Notifies for the SecurityPanel Proxy

    Copyright 2015 Control4 Corporation. All Rights Reserved.
===============================================================================]]
require "common.c4_notify"

TEMPLATE_VERSION.securitypanel = "6"

function NOTIFY.PANEL_ZONE_STATE(ZoneID, IsOpen, Initializing, BindingID)
	local ZoneParams = {}

	LogTrace("NOTIFY.PANEL_ZONE_STATE: %d %s %s %d", tonumber(ZoneID), tostring(IsOpen), tostring(Initializing), tonumber(BindingID))
	ZoneParams["ZONE_ID"] = ZoneID
	ZoneParams["ZONE_OPEN"] = IsOpen
	ZoneParams["INITIALIZING"] = Initializing

	SendNotify("PANEL_ZONE_STATE", ZoneParams, BindingID)
end

function NOTIFY.PANEL_PGM_STATE(PgmID, IsOpen, Initializing, BindingID)
	local PgmParams = {}

	LogTrace("NOTIFY.PANEL_PGM_STATE: %d %s %d", tonumber(PgmID), tostring(IsOpen), tonumber(BindingID))
	PgmParams["PGM_ID"] = PgmID
	PgmParams["PGM_OPEN"] = IsOpen
	PgmParams["INITIALIZING"] = Initializing

	SendNotify("PANEL_PGM_STATE", PgmParams, BindingID)
end

function NOTIFY.PANEL_ADD_PGM(PgmID, BindingID)
	local AddPgmParams = {}

	LogTrace("NOTIFY.PANEL_ADD_PGM: %d %d", tonumber(PgmID), tonumber(BindingID))
	AddPgmParams["ID"] = PgmID

	SendNotify("PANEL_ADD_PGM", AddPgmParams, BindingID)
end

function NOTIFY.PANEL_REMOVE_PGM(PgmID, BindingID)
	local RemovePgmParams = {}
	
	LogTrace("NOTIFY.PANEL_REMOVE_PGM: %d %d", tonumber(PgmID), tonumber(BindingID))
	RemovePgmParams["ID"] = PgmID
	
	SendNotify("PANEL_REMOVE_PGM", RemovePgmParams, BindingID)
end

function NOTIFY.PANEL_PARTITION_STATE(PartitionID, PartitionState, StateType, BindingID)
	local PartitionParams = {}

	LogTrace("NOTIFY.PANEL_PARTITION_STATE: %d %s %s %d", tonumber(PartitionID), tostring(PartitionState), tostring(StateType), tonumber(BindingID))
	PartitionParams["PARTITION_ID"] = PartitionID
	PartitionParams["STATE"] = PartitionState
	PartitionParams["TYPE"] = StateType

	SendNotify("PANEL_PARTITION_STATE", PartitionParams, BindingID)
end

function NOTIFY.PANEL_ZONE_INFO(ZoneID, ZoneName, ZoneTypeID, Partitions, IsOpen, BindingID)
	local ZoneInfoParams = {}

	LogTrace("NOTIFY.PANEL_ZONE_INFO: %d %s %d %d", tonumber(ZoneID), tostring(ZoneName), tonumber(ZoneTypeID), tonumber(BindingID))
	ZoneInfoParams["ID"] = ZoneID
	ZoneInfoParams["NAME"] = ZoneName
	ZoneInfoParams["TYPE_ID"] = ZoneTypeID
	ZoneInfoParams["PARTITIONS"] = Partitions
	ZoneInfoParams["IS_OPEN"] = tostring(IsOpen)

	SendNotify("PANEL_ZONE_INFO", ZoneInfoParams, BindingID)
end

function NOTIFY.PANEL_REMOVE_ZONE(ZoneID, BindingID)
	local RemoveZoneParams = {}
	
	LogTrace("NOTIFY.PANEL_REMOVE_ZONE: %d %d", tonumber(ZoneID), tonumber(BindingID))
	RemoveZoneParams["ID"] = ZoneID
	
	SendNotify("PANEL_REMOVE_ZONE", RemoveZoneParams, BindingID)
end

function NOTIFY.TROUBLE_START(TroubleText, Identifier, BindingID)
	local TroubleParams = {}

	LogTrace("NOTIFY.TROUBLE_START: %s %s %d", tostring(TroubleText), tostring(Identifier), tonumber(BindingID))
	TroubleParams["TROUBLE_TEXT"] = TroubleText
	TroubleParams["IDENTIFIER"] = Identifier

	SendNotify("TROUBLE_START", TroubleParams, BindingID)
end

function NOTIFY.TROUBLE_CLEAR(Identifier, BindingID)
	local TroubleParams = {}

	LogTrace("NOTIFY.TROUBLE_CLEAR: %s %d", tostring(Identifier), tonumber(BindingID))
	TroubleParams["IDENTIFIER"] = Identifier

	SendNotify("TROUBLE_CLEAR", TroubleParams, BindingID)
end

function NOTIFY.ALL_PARTITIONS_INFO(InfoStr, BindingID)
	LogTrace("NOTIFY.ALL_PARTITIONS_INFO: %s", InfoStr)
	SendNotify("ALL_PARTITIONS_INFO", InfoStr, BindingID)
end

function NOTIFY.ALL_ZONES_INFO(InfoStr, BindingID)
	LogTrace("NOTIFY.ALL_ZONES_INFO: %s", InfoStr)
	SendNotify("ALL_ZONES_INFO", InfoStr, BindingID)
end

function NOTIFY.ALL_PGMS_INFO(InfoStr, BindingID)
	LogTrace("NOTIFY.ALL_PGMS_INFO: %s", InfoStr)
	SendNotify("ALL_PGMS_INFO", InfoStr, BindingID)
end

function NOTIFY.REQUEST_ADDITIONAL_PANEL_INFO(Prompt, InfoString, FunctionName, MaskData, InterfaceID, BindingID)
	local ParmList = {}

	LogTrace("NOTIFY.REQUEST_ADDITIONAL_PANEL_INFO: %s %s %d", tostring(Prompt), InfoString, tonumber(BindingID))
	ParmList["PROMPT"] = Prompt
	ParmList["INFO_STRING"] = InfoString
	ParmList["FUNCTION_NAME"] = FunctionName
	ParmList["MASK_DATA"] = tostring(MaskData)
	ParmList["INTERFACE_ID"] = tostring(InterfaceID)

	SendNotify("REQUEST_ADDITIONAL_PANEL_INFO", ParmList, BindingID)
end

function NOTIFY.SYNC_PANEL_INFO(BindingID)
	LogTrace("NOTIFY.SYNC_PANEL_INFO")
	SendNotify("SYNC_PANEL_INFO", {}, BindingID)
end

function NOTIFY.PANEL_INITIALIZED(BindingID)
	LogTrace("NOTIFY.PANEL_INITIALIZED")
	SendNotify("PANEL_INITIALIZED", {}, BindingID)
end

 end)
package.preload['panel_proxy.zone_info'] = (function (...)
--[[=============================================================================
    ZoneInformation Class

    Copyright 2016 Control4 Corporation. All Rights Reserved.
===============================================================================]]
require "lib.c4_object"

TEMPLATE_VERSION.securitypanel = "2016.08.01"

-- Control4 zone type mapping
ZoneTypes = {
	-- Name to ID mappings
	UNKNOWN = 0,
	CONTACT_SENSOR = 1,
	EXTERIOR_DOOR = 2,
	EXTERIOR_WINDOW = 3,
	INTERIOR_DOOR = 4,
	MOTION_SENSOR = 5,
	FIRE = 6,
	GAS = 7,
	CARBON_MONOXIDE = 8,
	HEAT = 9,
	WATER = 10,
	SMOKE = 11,
	PRESSURE = 12,
	GLASS_BREAK = 13,
	GATE = 14,
	GARAGE_DOOR = 15,
	TYPES_COUNT = 16,        -- The number of defined values
	-- ID to Name mappings
	[0] = "UNKNOWN",
	"CONTACT_SENSOR",
	"EXTERIOR_DOOR",
	"EXTERIOR_WINDOW",
	"INTERIOR_DOOR",
	"MOTION_SENSOR",
	"FIRE",
	"GAS",
	"CARBON_MONOXIDE",
	"HEAT",
	"WATER",
	"SMOKE",
	"PRESSURE",
	"GLASS_BREAK",
	"GATE",
	"GARAGE_DOOR" }

ZoneInfoList = {}
ZoneInformation = inheritsFrom(nil)
DefaultZoneName = "Zone "

--[[=============================================================================
    Functions that are meant to be private to the class
===============================================================================]]
function ZoneInformation:construct(ZoneID)
	self._ZoneID = ZoneID
	self._IsOpen = false
	self._IsBypassed = false
	self._ZoneName = DefaultZoneName .. tostring(ZoneID)
	self._ZoneTypeID_C4 = 0     -- Control4 zone type
	self._ZoneTypeID_3P = 0     -- Security panel zone type
	self._NeedToSendInitialInfo = true
    
	self._PartitionMemberList = {}
    
	ZoneInfoList[ZoneID] = self
	
	self._DataGuarded = false
end

function ZoneInformation:destruct()
	NOTIFY.PANEL_REMOVE_ZONE(self._ZoneID, TheSecurityPanel._BindingID)
	ZoneInfoList[self._ZoneID] = nil
end

function ZoneInformation:ZonePanelXML()
	local ZoneXMLInfo = {}

	table.insert(ZoneXMLInfo, MakeXMLNode("id", tostring(self._ZoneID)))
	table.insert(ZoneXMLInfo, MakeXMLNode("name", tostring(self._ZoneName)))
	table.insert(ZoneXMLInfo, MakeXMLNode("type_id", tostring(self._ZoneTypeID_C4)))
	table.insert(ZoneXMLInfo, MakeXMLNode("partitions", self:ListPartitions()))
	table.insert(ZoneXMLInfo, MakeXMLNode("can_bypass", "true"))
	table.insert(ZoneXMLInfo, MakeXMLNode("is_open", tostring(self._IsOpen)))

	return MakeXMLNode("zone", table.concat(ZoneXMLInfo, "\n"))
end

function ZoneInformation:ZonePartitionXML()
	return MakeXMLNode("zone", MakeXMLNode("id", tostring(self._ZoneID)))
end

function ZoneInformation:ListPartitions()
	local PartitionList = ""

	for i, p in pairs(self._PartitionMemberList) do
		if (PartitionList ~= "") then
			PartitionList = (PartitionList .. ",")
		end

		PartitionList = PartitionList .. tostring(i)
	end

	return (PartitionList ~= "") and PartitionList or " "
end

function ZoneInformation:ZoneInfoChanged()
	LogDebug("ZoneInfoChanged => Zone %d: Name = %s, Type = %d, Type_Alt = %d", tonumber(self._ZoneID), tostring(self._ZoneName), tonumber(self._ZoneTypeID_C4), tonumber(self._ZoneTypeID_3P))
	NOTIFY.PANEL_ZONE_INFO(self._ZoneID, self._ZoneName, self._ZoneTypeID_C4, self:ListPartitions(), self._IsOpen, TheSecurityPanel._BindingID)
end

--[[=============================================================================
    Functions that are wrappered and meant to be exposed to the driver
===============================================================================]]
function ZoneInformation:IsBypassed()
	return self._IsBypassed
end

function ZoneInformation:IsOpen()
	return self._IsOpen
end

function ZoneInformation:GetZoneType()
	return self._ZoneTypeID_3P
end

function ZoneInformation:GetZoneState()
	return self._IsOpen and "OPENED" or "CLOSED"
end

function ZoneInformation:SetDataGuardFlag(GuardIt)
	self._DataGuarded = GuardIt
	LogTrace("ZoneInformation:SetDataGuardFlag for Zone %d   to %s", self._ZoneID, tostring(self._DataGuarded))
end

function ZoneInformation:SetZoneInfo(ZoneName, ZoneTypeID, ZoneTypeID_C4)
	local SomethingChanged = false

	if(not self._DataGuarded) then
		if (self._ZoneName ~= ZoneName and ZoneName ~= "") then
			LogTrace("Changing name for zone %d from %s to %s", self._ZoneID, self._ZoneName, ZoneName)
			self._ZoneName = ZoneName
			SomethingChanged = true
		end

		if (self._ZoneTypeID_C4 ~= ZoneTypeID_C4 and ZoneTypeID_C4 ~= "") then
			self._ZoneTypeID_C4 = ZoneTypeID_C4
			SomethingChanged = true
		end
	end

	if (self._ZoneTypeID_3P ~= ZoneTypeID and ZoneTypeID ~= "") then
		self._ZoneTypeID_3P = ZoneTypeID
	end

	if(SomethingChanged) then
		self:ZoneInfoChanged()
	end
end

function ZoneInformation:AddToPartition(PartitionID)
	self._PartitionMemberList[PartitionID] = SecurityPartitionIndexList[PartitionID]
end

function ZoneInformation:RemoveFromPartition(PartitionID)
	self._PartitionMemberList[PartitionID] = nil
end

function ZoneInformation:SetZoneState(IsOpen, Initializing)
	local RetVal = false     -- return true if the state changed, false if it didn't
	local JustInitializing = Initializing or false

	if ((self._IsOpen ~= IsOpen) or self._NeedToSendInitialInfo or JustInitializing) then
		self._IsOpen = IsOpen
		RetVal = true

		for k, CurPartition in pairs(self._PartitionMemberList) do
			NOTIFY.ZONE_STATE(self._ZoneID, self._IsOpen, self._IsBypassed, CurPartition._BindingID)
		end
 
		NOTIFY.PANEL_ZONE_STATE(self._ZoneID, self._IsOpen, self._NeedToSendInitialInfo or JustInitializing, TheSecurityPanel._BindingID)
		self._NeedToSendInitialInfo = false
	end

	return RetVal
end

function ZoneInformation:SetBypassState(IsBypassed, Initializing)
	local RetVal = false     -- return true if the state changed, false if it didn't
	local JustInitializing = Initializing or false

	if (self._IsBypassed ~= IsBypassed) then

		RetVal = true
		self._IsBypassed = IsBypassed

		if (not JustInitializing) then

			for k, CurPartition in pairs(self._PartitionMemberList) do
				NOTIFY.ZONE_STATE(self._ZoneID, self._IsOpen, self._IsBypassed, CurPartition._BindingID)
			end
		end
	end

	return RetVal
end end)
package.preload['partition_proxy.securitypartition'] = (function (...)
--[[=============================================================================
    SecurityPartition Class

    Copyright 2016 Control4 Corporation. All Rights Reserved.
===============================================================================]]
require "common.c4_utils"
require "lib.c4_object"
require "lib.c4_log"
require "partition_proxy.securitypartition_functions"
require "partition_proxy.securitypartition_commands"
require "partition_proxy.securitypartition_notifies"
require "panel_proxy.zone_info"

TEMPLATE_VERSION.securitypartition = "2016.06.23"

SecurityPartitionIndexList = {}
SecurityPartitionFunctions = {}
SecurityPartitionBindingList = {}

--[[=============================================================================
    ARMED STATES
===============================================================================]]
AS_ARMED = "ARMED"
AS_ALARM = "ALARM"
AS_EXIT_DELAY = "EXIT_DELAY"
AS_ENTRY_DELAY = "ENTRY_DELAY"
AS_DISARMED_READY = "DISARMED_READY"
AS_DISARMED_NOT_READY = "DISARMED_NOT_READY"
AS_CONFIRMATION_REQUIRED = "CONFIRMATION_REQUIRED"
AS_OFFLINE = "OFFLINE"

SecurityPartition = inheritsFrom(nil)


function SetAllPartitionsOffline()
	LogTrace("SetAllPartitionsOffline")
	for _, CurPartition in pairs(SecurityPartitionIndexList) do
		if(CurPartition:IsEnabled()) then
			CurPartition:SetPartitionState(AS_OFFLINE, "")
		end
	end
end


--[[=============================================================================
    Functions that are meant to be private to the class
===============================================================================]]
function SecurityPartition:construct(PartitionNumber, BindingID)

	self._IsEnabled = true
	self._PartitionNumber = PartitionNumber
	self._BindingID = BindingID
	self._CurrentPartitionState = "Unknown"
	self._InitializingStatus = false
	self._MyZoneList = {}

	self._DelayTimeTotal = 0
	self._DelayTimeRemaining = 0
	self._OpenZoneCount = 0

	self._CodeRequiredToArm = false
	self._CodeRequiredToClear = true
	self._InAlarm = false
	self._CurrentStateType = ""
	
	self._DefaultUserCode = ""

	SecurityPartitionIndexList[PartitionNumber] = self
	SecurityPartitionBindingList[BindingID] = self
end

function SecurityPartition:InitialSetup()
end

function SecurityPartition:SetInitializingFlag(FlagValue)
	self._InitializingStatus = FlagValue
end

function SecurityPartition:EntryExitDelay(DelayType, DelayActive, TotalTime, RemainingTime)
	local DelayMessage = DelayType .. " Delay"
	local OldTotalTime = self._DelayTimeTotal
	local OldRemainingTime = self._DelayTimeRemaining

	if (DelayActive) then
		-- Delay On
		if (TotalTime == 0) then
			TotalTime = OldTotalTime
		end

		self._DelayTimeTotal = (TotalTime > RemainingTime) and TotalTime or RemainingTime
		self._DelayTimeRemaining = RemainingTime
		DelayMessage = DelayMessage .. " On"
	else
		-- Delay Off
		self._DelayTimeTotal = 0
		self._DelayTimeRemaining = 0
		DelayMessage = DelayMessage .. " Off"
	end

	LogDebug("EntryExitDelay: %s", DelayMessage)
end

function SecurityPartition:PartitionXML()
	local PartitionXMLInfo = {}

	table.insert(PartitionXMLInfo, MakeXMLNode("id", tostring(self._PartitionNumber)))
	table.insert(PartitionXMLInfo, MakeXMLNode("enabled", tostring(self._IsEnabled)))
	table.insert(PartitionXMLInfo, MakeXMLNode("binding_id", tostring(self._BindingID)))
	table.insert(PartitionXMLInfo, MakeXMLAttrNode("state", tostring(self._CurrentPartitionState), "type", tostring(self._CurrentStateType)))

	return MakeXMLNode("partition", table.concat(PartitionXMLInfo, "\n"))
end

function SecurityPartition:NotifyPartitionState()

	LogTrace("Partition %d set to partition state %s : %s Alarm is %s", tonumber(self._PartitionNumber), tostring(self._CurrentPartitionState), tostring(self._CurrentStateType), tostring(self._InAlarm))
	if (self._InitializingStatus) then
		NOTIFY.PARTITION_STATE_INIT(self._CurrentPartitionState, self._CurrentStateType, self._DelayTimeTotal, self._DelayTimeRemaining, self._CodeRequiredToClear, self._BindingID)
	else
		NOTIFY.PARTITION_STATE(self._CurrentPartitionState, self._CurrentStateType, self._DelayTimeTotal, self._DelayTimeRemaining, self._CodeRequiredToClear, self._BindingID)
	end

	NOTIFY.PANEL_PARTITION_STATE(self._PartitionNumber, self._CurrentPartitionState, self._CurrentStateType, PANEL_PROXY_BINDINGID)
end

function SecurityPartition:ClearDisplayText()
	NOTIFY.DISPLAY_TEXT("", self._BindingID)
end

--[[=============================================================================
    Functions for handling request from the Partition Proxy
===============================================================================]]

function SecurityPartition:PrxPartitionArm(tParams)
	local ArmType = tParams["ArmType"]
	local UserCode = tParams["UserCode"]
	local Bypass = toboolean(tParams["Bypass"])
	local InterfaceID = tParams["InterfaceID"] or ""

	if (InterfaceID == "DirectorProgramming") then
		UserCode = self:GetDefaultUserCode()
	end

	LogTrace("PrxPartitionArm %d %s %s %s", tonumber(self._PartitionNumber), tostring(ArmType), tostring(UserCode), tostring(Bypass))
	SecCom_SendArmPartition(self._PartitionNumber, ArmType, UserCode, Bypass, InterfaceID)
end

function SecurityPartition:PrxPartitionDisarm(tParams)
	local UserCode = tParams["UserCode"]
	local InterfaceID = tParams["InterfaceID"] or ""

	if (InterfaceID == "DirectorProgramming") then
		UserCode = self:GetDefaultUserCode()
	end

	LogTrace("PartitionDisarm")
	SecCom_SendDisarmPartition(self._PartitionNumber, UserCode, InterfaceID)
end

function SecurityPartition:PrxArmCancel(tParams)
	local InterfaceID = tParams["InterfaceID"] or ""

	LogTrace("ArmCancel")
	SecCom_ArmCancel(self._PartitionNumber, InterfaceID)
end

function SecurityPartition:PrxExecuteEmergency(tParams)
	local EmergencyType = tParams["EmergencyType"]
	local InterfaceID = tParams["InterfaceID"] or ""

	LogTrace("ExecuteEmergency")
	SecCom_SendExecuteEmergency(self._PartitionNumber, EmergencyType, InterfaceID)
end

function SecurityPartition:PrxExecuteFunction(tParams)
	local FunctionName = tParams["Function"]
	local InterfaceID = tParams["InterfaceID"]
	local trimmedCommand = string.gsub(FunctionName, " ", "")

	LogTrace("Execute Function (%s) from InterfaceID: %s", tostring(FunctionName), tostring(InterfaceID))
	if (SecurityPartitionFunctions[FunctionName] ~= nil and type(SecurityPartitionFunctions[FunctionName]) == "function") then
		SecurityPartitionFunctions[FunctionName](self._PartitionNumber, InterfaceID)
	elseif (SecurityPartitionFunctions[trimmedCommand] ~= nil and type(SecurityPartitionFunctions[trimmedCommand]) == "function") then
		SecurityPartitionFunctions[trimmedCommand](self._PartitionNumber, InterfaceID)
	else
		LogInfo("ID specified is null or not a function name[%s]", tostring(FunctionName))
	end
end

function SecurityPartition:PrxKeyPress(tParams)
	local KeyName = tParams["KeyName"]
	local InterfaceID = tParams["InterfaceID"] or ""

	LogTrace("PrxKeyPress")
	SecCom_SendKeyPress(self._PartitionNumber, KeyName, InterfaceID)
end

function SecurityPartition:PrxAdditionalInfo(tParams)
	local NewInfo = tParams["NewInfo"]
	local InfoString = tParams["InfoString"]
	local InterfaceID = tParams["InterfaceID"] or "" -- BOGUSFUNID su iOS!?!
	local FunctionName = tParams["FunctionName"]

	SecCom_ProcessAdditionalInfo(self._PartitionNumber, InfoString, NewInfo, FunctionName, InterfaceID)
end

function SecurityPartition:PrxSetDefaultUserCode(tParams)
	local NewUserCode = tParams["Code"]

	LogTrace("PrxSetDefaultUserCode  Code is >>%s<<", NewUserCode)
	self:SetDefaultUserCode(NewUserCode)
end

function SecurityPartition:PrxSendConfirmation(tParams)
	local InterfaceID = tParams["InterfaceID"] or ""
	SecCom_SendConfirmation(self._PartitionNumber, InterfaceID)
end

--[[=============================================================================
    Functions that are wrappered and meant to be exposed to the driver
===============================================================================]]
function SecurityPartition:RequestAdditionalInfo(Prompt, InfoStr, FunctionName, MaskData, InterfaceID)
	NOTIFY.REQUEST_ADDITIONAL_INFO(Prompt, InfoStr, FunctionName, MaskData, InterfaceID, self._BindingID)
end

function SecurityPartition:ArmFailed(Action, InterfaceID)
	NOTIFY.ARM_FAILED(Action, InterfaceID, self._BindingID)
end

function SecurityPartition:DisarmFailed(InterfaceID)
	NOTIFY.DISARM_FAILED(InterfaceID, self._BindingID)
end

function SecurityPartition:GetZoneIDs()
	local i = 1
	local s = {}

	for k, _ in pairs(self._MyZoneList) do
		s[i] = k
		i = i + 1
	end

	return s
end

function SecurityPartition:GetZoneCount()
	local i = 0

	for _, _ in pairs(self._MyZoneList) do
		i = i + 1
	end

	return i
end

function SecurityPartition:ContainsZone(ZoneID)
	for _, v in pairs(self._MyZoneList) do
		if (v._ZoneID == ZoneID) then
			return true
		end
	end

	return false
end

function SecurityPartition:AddZone(ZoneID)
	local nZoneID = tonumber(ZoneID)
	local TargZone = ZoneInfoList[nZoneID]

	if (TargZone == nil) then
		ZoneInformation:new(nZoneID)
		TargZone = ZoneInfoList[nZoneID]

		-- force a notification to the panel driver
		TargZone:ZoneInfoChanged()
	end

	self._MyZoneList[ZoneID] = TargZone
	NOTIFY.HAS_ZONE(ZoneID, self._BindingID)
end

function SecurityPartition:RemoveZone(ZoneID)
	local TargZone = ZoneInfoList[tonumber(ZoneID)]

	if (TargZone ~= nil) then
		self._MyZoneList[ZoneID] = nil
		NOTIFY.REMOVE_ZONE(ZoneID, self._BindingID)
	end
end

function SecurityPartition:SetEnabled(Enabled)
	LogTrace("Setting Enabled flag for partition %d to %s, %s", self._PartitionNumber, tostring(Enabled),tostring( self._IsEnabled))

	self._IsEnabled = Enabled
	if (not Enabled) then
		self._CurrentPartitionState = "Unknown"
	end
	
	NOTIFY.PARTITION_ENABLED(self._IsEnabled, self._BindingID)

	--only display properties for partition if it is enabled
	local index = tostring( self._PartitionNumber )
	local attrib = 1
	if self._IsEnabled == "True" then
		attrib = 0
	end
	C4:SetPropertyAttribs( KS_PROP["PANIC"..index], attrib )
	C4:SetPropertyAttribs( KS_PROP["HOME"..index], attrib )
	C4:SetPropertyAttribs( KS_PROP["AWAY"..index], attrib )
	C4:SetPropertyAttribs( KS_PROP["STAY"..index], attrib )
	C4:SetPropertyAttribs( KS_PROP["DISARM"..index], attrib )
	C4:SetPropertyAttribs( KS_PROP["ARM"..index], attrib )
	C4:SetPropertyAttribs( KS_PROP["CUSTOM_A"..index], attrib )
	C4:SetPropertyAttribs( KS_PROP["CUSTOM_B"..index], attrib )
end

function SecurityPartition:IsEnabled()
	return self._IsEnabled
end

function SecurityPartition:SetPartitionState(NewState, NewStateType, TotalDelayTime, RemainingDelayTime, CodeRequiredToClear)
	local previousState = self._CurrentPartitionState
	local previousStateType = self._CurrentStateType
	local SendChange = ((previousState ~= NewState) or (previousStateType ~= NewStateType))
	local TotDelayTime = TotalDelayTime or 0
	local RemDelayTime = RemainingDelayTime or 0

	LogTrace("Partition %d changed state to %s : %s From %s", tonumber(self._PartitionNumber), tostring(NewState), tostring(NewStateType), tostring(self._CurrentPartitionState))
	self._CurrentPartitionState = NewState
	self._CurrentStateType = NewStateType

	if (self._CurrentPartitionState == AS_ALARM) then
		self._InAlarm = true
		self._CodeRequiredToClear = CodeRequiredToClear or false
	else
		self._InAlarm = false
		self._CodeRequiredToClear = true
	end

	if ((NewState == AS_EXIT_DELAY) or (NewState == AS_ENTRY_DELAY) or (previousState == AS_EXIT_DELAY) or (previousState == AS_ENTRY_DELAY)) then
		local DelayType = ((NewState == AS_EXIT_DELAY) or (previousState == AS_EXIT_DELAY)) and "Exit" or "Entry"
		local DelayActive = ((NewState == AS_EXIT_DELAY) or (NewState == AS_ENTRY_DELAY))

		self:EntryExitDelay(DelayType, DelayActive, TotDelayTime, RemDelayTime)
		SendChange = true
	end

	if (SendChange) then
		self:NotifyPartitionState()
	end
end

function SecurityPartition:HaveEmergency(EmergencyType)
	NOTIFY.EMERGENCY_TRIGGERED(EmergencyType, self._BindingID)
end

function SecurityPartition:DisplayText(Message)
	NOTIFY.DISPLAY_TEXT(Message, self._BindingID)
end

function SecurityPartition:SetCodeRequiredToArm(CodeRequired)
	self._CodeRequiredToArm = CodeRequired
	NOTIFY.CODE_REQUIRED(self._CodeRequiredToArm, self._BindingID)
end

function SecurityPartition:IsCodeRequiredToArm()
	return self._CodeRequiredToArm
end

function SecurityPartition:GetPartitionState()
	return self._CurrentPartitionState
end

function SecurityPartition:GetPartitionStateType()
	return self._CurrentStateType
end

function SecurityPartition:IsArmed()
	return ((self._CurrentPartitionState == AS_ARMED) or
	        (self._CurrentPartitionState == AS_ENTRY_DELAY) or
	        (self._CurrentPartitionState == AS_ALARM))
end

function SecurityPartition:IsInDelay()
	return ((self._CurrentPartitionState == AS_EXIT_DELAY) or
	        (self._CurrentPartitionState == AS_ENTRY_DELAY))
end

function SecurityPartition:SetDefaultUserCode(NewCode)
	if (NewCode ~= nil) then
		LogTrace("Setting Default User Code for partition %d  to >>%s<<", self._PartitionNumber, NewCode)
		self._DefaultUserCode = NewCode
	end
end

function SecurityPartition:GetDefaultUserCode()
	return self._DefaultUserCode
end end)
package.preload['partition_proxy.securitypartition_commands'] = (function (...)
--[[=============================================================================
    Commands for the SecurityPartition Proxy

    Copyright 2015 Control4 Corporation. All Rights Reserved.
===============================================================================]]
require "lib.c4_log"

    TEMPLATE_VERSION.securitypartition = "9"

function PRX_CMD.KEY_PRESS(idBinding, tParams)
	LogTrace("PRX_CMD.KEY_PRESS")
	if (SecurityPartitionBindingList[idBinding]) then
		SecurityPartitionBindingList[idBinding]:PrxKeyPress(tParams)
	end
	LogTrace(tParams)
	
end



function PRX_CMD.PARTITION_ARM(idBinding, tParams)
	--PartitionRequestAdditionalInfo(1, "Enter Pin# #", tostring(Parameters), "", false, tParams.InterfaceID)
	LogTrace( tstring(tParams))

	LogTrace("PRX_CMD.PARTITION_ARM")
	if (SecurityPartitionBindingList[idBinding]) then
		SecurityPartitionBindingList[idBinding]:PrxPartitionArm(tParams)		
	end
end

function PRX_CMD.PARTITION_DISARM(idBinding, tParams)
	LogTrace("PRX_CMD.PARTITION_DISARM")
	if (SecurityPartitionBindingList[idBinding]) then
		SecurityPartitionBindingList[idBinding]:PrxPartitionDisarm(tParams)
	end
end

function PRX_CMD.ARM_CANCEL(idBinding, tParams)
	LogTrace("PRX_CMD.ARM_CANCEL")
	if (SecurityPartitionBindingList[idBinding]) then
		SecurityPartitionBindingList[idBinding]:PrxArmCancel(tParams)
	end
end

function PRX_CMD.EXECUTE_EMERGENCY(idBinding, tParams)
	LogTrace("PRX_CMD.EXECUTE_EMERGENCY")
	if (SecurityPartitionBindingList[idBinding]) then
		SecurityPartitionBindingList[idBinding]:PrxExecuteEmergency(tParams)
	end
end

function PRX_CMD.EXECUTE_FUNCTION(idBinding, tParams)
	LogTrace("PRX_CMD.EXECUTE_FUNCTION")
	if (SecurityPartitionBindingList[idBinding]) then
		SecurityPartitionBindingList[idBinding]:PrxExecuteFunction(tParams)
	end
end

function PRX_CMD.ADDITIONAL_INFO(idBinding, tParams)
	LogTrace("PRX_CMD.ADDITIONAL_INFO")
	if (SecurityPartitionBindingList[idBinding]) then
		SecurityPartitionBindingList[idBinding]:PrxAdditionalInfo(tParams)
	end
end

function PRX_CMD.SET_DEFAULT_USER_CODE(idBinding, tParams)
	LogTrace("PRX_CMD.SET_DEFAULT_USER_CODE")
	if (SecurityPartitionBindingList[idBinding]) then
		SecurityPartitionBindingList[idBinding]:PrxSetDefaultUserCode(tParams)
	end
end

function PRX_CMD.SEND_CONFIRMATION(idBinding, tParams)
	LogTrace("PRX_CMD.SEND_CONFIRMATION")
	if (SecurityPartitionBindingList[idBinding]) then
		SecurityPartitionBindingList[idBinding]:PrxSendConfirmation(tParams)
	end
end

 end)
package.preload['partition_proxy.securitypartition_functions'] = (function (...)
--[[=============================================================================
    Functions dealing with the management of partitions and their states

    Copyright 2015 Control4 Corporation. All Rights Reserved.
===============================================================================]]
require "common.c4_utils"

TEMPLATE_VERSION.securitypartition = "9"

--[[=============================================================================
    ArmPartitionFailed(PartitionID, Action, InterfaceID)

    Description: 
    Notifies the system that an arm partition has failed, and tells the UI what
    action if any needs to be taken in order to proceed.

    Parameters:
    PartitionID(int)    - The index of the partition we are arming
    Action(string)      - Indicates the action that the UI should take to help 
                          rectify. Following is a list of actions that can be
                          taken keypad(if a keycode is needed), bypass, or
                          NA(general failure)
    InterfaceID(string) - The unique identifier string of the UI which requested
                          the arming action.  We only want that UI to respond to
                          the failed message.

    Returns:
    None
===============================================================================]]
function ArmPartitionFailed(PartitionID, Action, InterfaceID)
	if (SecurityPartitionIndexList[tonumber(PartitionID)] ~= nil) then
		SecurityPartitionIndexList[tonumber(PartitionID)]:ArmFailed(Action, InterfaceID)
	end
end

--[[=============================================================================
    DisarmPartitionFailed(PartitionID, InterfaceID)

    Description: 
    Notifies the system that a disarm partition has failed.

    Parameters:
    PartitionID(int)    - The index of the partition we are disarming
    InterfaceID(string) - The unique identifier string of the UI which requested
                          the disarming action. 
                          We only want that UI to respond to the failed message.

    Returns:
    None
===============================================================================]]
function DisarmPartitionFailed(PartitionID, InterfaceID)
	if (SecurityPartitionIndexList[tonumber(PartitionID)] ~= nil) then
		SecurityPartitionIndexList[tonumber(PartitionID)]:DisarmFailed(InterfaceID)
	end
end

--[[=============================================================================
    GetPartitionZoneIDs(PartitionID)

    Description: 
    Get the list of zone IDs that are associated with the specified partition

    Parameters:
    PartitionID(int) - The index of the partition we are getting the list from

    Returns:
    A table containing a list of the zone numbers for the specified partition
===============================================================================]]
function GetPartitionZoneIDs(PartitionID)
	if (SecurityPartitionIndexList[tonumber(PartitionID)] ~= nil) then
		return SecurityPartitionIndexList[tonumber(PartitionID)]:GetZoneIDs()
	else
		return nil
	end
end

--[[=============================================================================
    GetPartitionZoneCount(PartitionID)

    Description: 
    Get the count of the zones that are associated with the zone

    Parameters:
    PartitionID(int) - The index of the partition we are getting the count from

    Returns:
    The zone count for the associated partition
===============================================================================]]
function GetPartitionZoneCount(PartitionID)
	if (SecurityPartitionIndexList[tonumber(PartitionID)] ~= nil) then
		return SecurityPartitionIndexList[tonumber(PartitionID)]:GetZoneCount()
	else
		return 0
	end
end

--[[=============================================================================
    AddZoneToPartition(PartitionID, ZoneID)

    Description: 
    Adds the given zone to the specified partition
    Note: SetZoneInfo must be called before this function in order for the call
          to succeed

    Parameters:
    PartitionID(int) - The index of the partition we are adding the zone to
    ZoneID(int)      - The zone id that is being added to the partition

    Returns:
    None
===============================================================================]]
function AddZoneToPartition(PartitionID, ZoneID)
	local TargPartition = SecurityPartitionIndexList[tonumber(PartitionID)]

	if(TargPartition ~= nil) then
		if(not TargPartition:ContainsZone(ZoneID)) then
			TargPartition:AddZone(tonumber(ZoneID))
			ZoneInfoList[tonumber(ZoneID)]:AddToPartition(tonumber(PartitionID))
		end
	end
end

--[[=============================================================================
    RemoveZoneFromPartition(PartitionID, ZoneID)

    Description: 
    Removes the given zone from the specified partition

    Parameters:
    PartitionID(int) - The index of the partition we are adding the zone to
    ZoneID(int)      - The zone id that is being added to the partition

    Returns:
    None
===============================================================================]]
function RemoveZoneFromPartition(PartitionID, ZoneID)
	local TargPartition = SecurityPartitionIndexList[tonumber(PartitionID)]

	if(TargPartition ~= nil) then
		if(TargPartition:ContainsZone(ZoneID)) then
			TargPartition:RemoveZone(tonumber(ZoneID))
			ZoneInfoList[tonumber(ZoneID)]:RemoveFromPartition(tonumber(PartitionID))
		end
	end
end

--[[=============================================================================
    PartitionContainsZone(PartitionID, ZoneID)

    Description: 
    Tells if the given zone is a member of the given partition

    Parameters:
    PartitionID(int) - The index of the partition we are checking
    ZoneID(int)      - The id of the zone we are checking

    Returns:
    True if the partition contains the zone; False if it doesn't
===============================================================================]]
function PartitionContainsZone(PartitionID, ZoneID)
	local TargPartition = SecurityPartitionIndexList[tonumber(PartitionID)]

	if(TargPartition ~= nil) then
		return TargPartition:ContainsZone(ZoneID)
	else
		return false
	end
end

--[[=============================================================================
    SetPartitionEnabled(PartitionID, Enabled)

    Description: 
    Marks the specified partition as enabled within the system. If set to false
    the partition will not be visible to the UI.

    Parameters:
    PartitionID(int) - The index of the partition we are enabling or disabling
    Enabled(bool)    - The state of the partition

    Returns:
    None
===============================================================================]]
function SetPartitionEnabled(PartitionID, Enabled)
	--LogTrace("SetPartitionEnabled("..PartitionID..", ".. tostring(Enabled))
	if (SecurityPartitionIndexList[tonumber(PartitionID)] ~= nil) then
		SecurityPartitionIndexList[tonumber(PartitionID)]:SetEnabled(Enabled)
	end
end

--[[=============================================================================
    SetPartitionInitializingFlag(PartitionID, InitializingFlag)

    Description: 
    Marks the specified partition as currently being initialized. Some behaviours
    are different if a setting is happening for the first time

    Parameters:
    PartitionID(int)       - The index of the partition we are enabling or disabling
    InitializingFlag(bool) - True if the partition is currently being initialized

    Returns:
    None
===============================================================================]]
function SetPartitionInitializingFlag(PartitionID, InitializingFlag)
	if (SecurityPartitionIndexList[tonumber(PartitionID)] ~= nil) then
		SecurityPartitionIndexList[tonumber(PartitionID)]:SetInitializingFlag(InitializingFlag)
	end
end

--[[=============================================================================
    IsPartitionEnabled(PartitionID)

    Description: 
    Identifies whether or not the specified partition is enabled

    Parameters:
    PartitionID(int) - The index of the partition we are checking

    Returns:
    True if the partition is enabled
===============================================================================]]
function IsPartitionEnabled(PartitionID)
	if (SecurityPartitionIndexList[tonumber(PartitionID)] ~= nil) then
		return SecurityPartitionIndexList[tonumber(PartitionID)]:IsEnabled()
	else
		return false
	end
end

--[[=============================================================================
    SetPartitionState(PartitionID, State, StateType, TotalDelayTime, RemainingDelayTime, CodeRequiredToClear)

    Description: 
    Sets the specified partitions current state in the system

    Parameters:
    PartitionID(int)             - The number for the partition whose state is being set
    State(string)                - The state of the partition indicated by PartitionID
                                   Following are a list of valid states(ARMED, ALARM, 
                                   DISARMED_NOT_READY, DISARMED_READY, EXIT_DELAY,
                                   and ENTRY_DELAY)
    StateType(string)            - Some description to further clarify the partition
                                   state. If the state is ARMED, the state type might
                                   be "Home" or "Away".  If the state is ALARM, the
                                   state type might be "FIRE" or "BURGLARY". This
                                   may also be an empty string for other states.
    TotalDelayTime(int)          - An optional parameter that is to be used when
                                   the state being specified is either (ENTRY_DELAY
                                   or EXIT_DELAY)
    RemainingDelayTime(int)      - An optional parameter that is to be used when
                                   the state being specified is either (ENTRY_DELAY
                                   or EXIT_DELAY)
    CodeRequiredToClear(boolean) - An optional parameter that is defaulted to true.
                                   Identifies whether or not a code is required to
                                   clear the alarm event

    Returns:
    None
===============================================================================]]
function SetPartitionState(PartitionID, State, StateType, TotalDelayTime, RemainingDelayTime, CodeRequiredToClear)
	if (SecurityPartitionIndexList[tonumber(PartitionID)] ~= nil) then
		ArmType = ArmType or ""
		TotalDelayTime = tonumber(TotalDelayTime) or 0
		RemainingDelayTime = tonumber(RemainingDelayTime) or 0

		if (CodeRequiredToClear == nil) then 
			CodeRequiredToClear = true 
		end

		SecurityPartitionIndexList[tonumber(PartitionID)]:SetPartitionState(State, StateType, TotalDelayTime, RemainingDelayTime, CodeRequiredToClear)
	end
end

--[[=============================================================================
    GetPartitionState(PartitionID)

    Description:
    Get the state of the partition that was specified by the given PartitionID

    Parameters:
    PartitionID(int) - The index of the partition we are getting the state from

    Returns:
    The state of the partition specified by the PartitionID
    Following are a list of states that should be returned (ARMED, ALARM, 
    DISARMED_NOT_READY, DISARMED_READY, EXIT_DELAY, and ENTRY_DELAY)
===============================================================================]]
function GetPartitionState(PartitionID)
	if (SecurityPartitionIndexList[tonumber(PartitionID)] ~= nil) then
		return SecurityPartitionIndexList[tonumber(PartitionID)]:GetPartitionState()
	else
		return AS_DISARMED_READY
	end
end

--[[=============================================================================
    GetPartitionStateType(PartitionID)

    Description: 
    Get the state type of the partition that was specified by the given PartitionID

    Parameters:
    PartitionID(int) - The index of the partition we are getting the state type from

    Returns:
    The description of the state for the partition specified by the PartitionID
===============================================================================]]
function GetPartitionStateType(PartitionID)
	if (SecurityPartitionIndexList[tonumber(PartitionID)] ~= nil) then
		return SecurityPartitionIndexList[tonumber(PartitionID)]:GetPartitionStateType()
	else
		return "UNKNOWN"
	end
end

--[[=============================================================================
    SetCodeRequiredToArm(PartitionID, CodeRequired)

    Description: 
    Tells the system that the given partition requires a code to arm.

    Parameters:
    PartitionID(int)   - The index of the partition we are specifiying the status
    CodeRequired(bool) - True if a code is required to arm the partition, and
                         false otherwise.

    Returns:
    None
===============================================================================]]
function SetCodeRequiredToArm(PartitionID, CodeRequired)
    if (SecurityPartitionIndexList[tonumber(PartitionID)] ~= nil) then
		SecurityPartitionIndexList[tonumber(PartitionID)]:SetCodeRequiredToArm(CodeRequired)
	end
end

--[[=============================================================================
    IsCodeRequiredToArm(PartitionID)

    Description: 
    Reports if currently a code is required to am the specified partition

    Parameters:
    PartitionID(int) - The index of the partition we are asking about

    Returns:
    True if a code is required to arm the partition, and false otherwise.
===============================================================================]]
function IsCodeRequiredToArm(PartitionID)

    if (SecurityPartitionIndexList[tonumber(PartitionID)] ~= nil) then
		return SecurityPartitionIndexList[tonumber(PartitionID)]:IsCodeRequiredToArm()
	else
		return false
	end
end

--[[=============================================================================
    IsPartitionArmed(PartitionID)

    Description: 
    Returns the armed state of the partition indicated by PartitionID

    Parameters:
    PartitionID(int) - The index of the partition we are getting the armed
                       status for

    Returns:
    The armed state of the partition specified
===============================================================================]]
function IsPartitionArmed(PartitionID)
	if (SecurityPartitionIndexList[tonumber(PartitionID)] ~= nil) then
		return SecurityPartitionIndexList[tonumber(PartitionID)]:IsArmed()
	else
		return false
	end
end

--[[=============================================================================
    IsPartitionInDelay(PartitionID)

    Description: 
    Returns the delay information for the partition indicated by PartitionID

    Parameters:
    PartitionID(int) - The index of the partition we are getting delay
                       information for

    Returns:
    True if the Partition is currently in a delay state, false otherwise
===============================================================================]]
function IsPartitionInDelay(PartitionID)
	if (SecurityPartitionIndexList[tonumber(PartitionID)] ~= nil) then
		return SecurityPartitionIndexList[tonumber(PartitionID)]:IsInDelay()
	else
		return false
	end
end

--[[=============================================================================
    DisplayPartitionText(PartitionID, Message)

    Description: 
    Writes the given message to the specified partition

    Parameters:
    PartitionID(int) - The index of the partition we are writing the message to
    Message(string)  - The message to be written to the UI

    Returns:
    Writes the given message to the display field of the UI
===============================================================================]]
function DisplayPartitionText(PartitionID, Message)
    LogTrace("DisplayPartitionText", "PartitionID: "..PartitionID, "Message: "..Message)
    if (SecurityPartitionIndexList[tonumber(PartitionID)] ~= nil) then
		SecurityPartitionIndexList[tonumber(PartitionID)]:DisplayText(Message)
	end
end

--[[=============================================================================
    HaveEmergency(EmergencyName)

    Description: 
    Notifies all partitions that an emergency has been triggered.

    Parameters:
    EmergencyName(string) - The type of emergency that is being triggered.
                            Current Emergency Types: 
                            Fire, Medical, Police, and Panic.
                            However other strings could be sent if desired. The
                            UI just may not have icons for them

    Returns:
    None
===============================================================================]]
function HaveEmergency(EmergencyName)
	for _, v in pairs(SecurityPartitionIndexList) do
		v:HaveEmergency(EmergencyName)
	end
end

--[[=============================================================================
    PartitionRequestAdditionalInfo(PartitionID, Prompt, ParmList, FunctionName, MaskData, InterfaceID)

    Description: 
    Provides a mechanism to ask the UI for the given partition to provide more
    info, the most common use case would be if a user code or an installers code
    would be required to complete a desired action.

    Parameters:
    PartitionID(int)      - The index of the partition to provide the new information.
    Prompt(string)       - The prompt that the UI will display when asking for the
                           additional information.
    ParmList(string)     - A string of current information that will be passed
                           along as the new information is requested and then passed
                           back to this driver. This string would contain information
                           as to what the driver should do with the new information.
                           Usually it would indicate which routine should be called
                           and what parameters should be passed to that routine.
    FunctionName(string) - The name of the function to be called on return.
    MaskData(boolean)    - True the input off the keypad will be obscured when 
                           entering data, False the input will be visiable
    InterfaceId(string)  - A unique string identifying which interface this
                           request is being sent to. Usually this would be the
                           InterfaceId paramater given to the command that is
                           requesting more info.  An empty string is also legal
                           the command will be acted upon by all navigator 
                           interfaces.
===============================================================================]]
function PartitionRequestAdditionalInfo(PartitionID, Prompt, ParmList, FunctionName, MaskData, InterfaceId)
    if (SecurityPartitionIndexList[tonumber(PartitionID)] ~= nil) then

		SecurityPartitionIndexList[tonumber(PartitionID)]:RequestAdditionalInfo(tostring(Prompt), ParmList, tostring(FunctionName), toboolean(MaskData), tostring(InterfaceId))
	end
end

--[[=============================================================================
    SetDefaultUserCode(PartitionID, NewCode)

    Description: 
    Provides a mechanism to store a default user code for times when the user
    will be unavailable(i.e. Composer programming events)

    Parameters:
    PartitionID(int) - The index of the partition to provide the new information.
    NewCode(string)  - The default user code that will be provided when there is 
                       no user to provide the input.
===============================================================================]]
function SetDefaultUserCode(PartitionID, NewCode)
	if (SecurityPartitionIndexList[tonumber(PartitionID)] ~= nil) then
		SecurityPartitionIndexList[tonumber(PartitionID)]:SetDefaultUserCode(NewCode)
	end
end

--[[=============================================================================
    SetDefaultUserCode(PartitionID, NewCode)

    Description: 
    Returns the stored default user code

    Parameters:
    PartitionID(int) - The index of the partition to provide the new information.
===============================================================================]]
function GetDefaultUserCode(PartitionID)
	if (SecurityPartitionIndexList[tonumber(PartitionID)] ~= nil) then
		return SecurityPartitionIndexList[tonumber(PartitionID)]:GetDefaultUserCode()
	else
		return ""
	end
end
 end)
package.preload['partition_proxy.securitypartition_notifies'] = (function (...)
--[[=============================================================================
    Notifications for the SecurityPartition Proxy

    Copyright 2015 Control4 Corporation. All Rights Reserved.
===============================================================================]]
require "common.c4_notify"

TEMPLATE_VERSION.securitypartition = "9"

function NOTIFY.DISPLAY_TEXT(DispText, BindingID)
	local DisplayTextParams = {}

	--LogTrace("Sending Display Text on Binding %s: %s", tostring(BindingID), tostring(DispText))
	C4:SendToProxy(BindingID, "DISPLAY_TEXT", "-")
	C4:SendToProxy(BindingID, "DISPLAY_TEXT", DispText)
	-- SendNotify("DISPLAY_TEXT", DispText, BindingID)
end

function NOTIFY.PARTITION_STATE(NewPartitionState, StateType, DelayTotal, DelayRemaining, CodeRequiredToClear, BindingID)
	local StateParams = {}

	LogTrace("NOTIFY.PARTITION_STATE  %s  >>%s<<  %d %d %d", tostring(NewPartitionState), tostring(StateType), tonumber(DelayTotal), tonumber(DelayRemaining), tonumber(BindingID))
	StateParams["STATE"] = NewPartitionState
	StateParams["TYPE"] = StateType
	StateParams["DELAY_TIME_TOTAL"] = DelayTotal
	StateParams["DELAY_TIME_REMAINING"] = DelayRemaining
	StateParams["CODE_REQUIRED_TO_CLEAR"] = CodeRequiredToClear

	SendNotify("PARTITION_STATE", StateParams, BindingID)
end

function NOTIFY.PARTITION_STATE_INIT(NewPartitionState, StateType, DelayTotal, DelayRemaining, CodeRequiredToClear, BindingID)
	local StateParams = {}

	LogTrace("NOTIFY.PARTITION_STATE_INIT: %s %s %d %d %d", tostring(NewPartitionState), tostring(StateType), tonumber(DelayTotal), tonumber(DelayRemaining), tonumber(BindingID))
	StateParams["STATE"] = NewPartitionState
	StateParams["TYPE"] = StateType
	StateParams["DELAY_TIME_TOTAL"] = DelayTotal
	StateParams["DELAY_TIME_REMAINING"] = DelayRemaining
	StateParams["CODE_REQUIRED_TO_CLEAR"] = CodeRequiredToClear

	SendNotify("PARTITION_STATE_INIT", StateParams, BindingID)
end

function NOTIFY.PARTITION_ENABLED(IsEnabled, BindingID)
	local EnabledParams = {}

	LogTrace("NOTIFY.PARTITION_ENABLED: %s %d", tostring(IsEnabled), tonumber(BindingID))
	EnabledParams["ENABLED"] = tostring(IsEnabled)

	SendNotify("PARTITION_ENABLED", EnabledParams, BindingID)
end

function NOTIFY.ZONE_STATE(ZoneID, IsOpen, IsBypassed, BindingID)
	local StateParams = {}

	LogTrace("NOTIFY.ZONE_STATE: %d %s %s %d", tonumber(ZoneID), tostring(IsOpen), tostring(IsBypassed), tonumber(BindingID))
	StateParams["ZONE_ID"] = tostring(ZoneID)
	StateParams["ZONE_OPEN"] = tostring(IsOpen)
	StateParams["ZONE_BYPASSED"] = tostring(IsBypassed)

	SendNotify("ZONE_STATE", StateParams, BindingID)
end

function NOTIFY.EMERGENCY_TRIGGERED(EmergencyType, BindingID)
	local TriggerParams = {}

	LogTrace("Sending EMERGENCY_TRIGGERED: >>%s<< on binding: %d", tostring(EmergencyType), tonumber(BindingID))
	TriggerParams["TYPE"] = EmergencyType

	SendNotify("EMERGENCY_TRIGGERED", TriggerParams, BindingID)
end

function NOTIFY.DISARM_FAILED(InterfaceID, BindingID)
	local DisarmFailedParams = {}
	DisarmFailedParams["INTERFACE_ID"] = InterfaceID

	LogTrace("NOTIFY.DISARM_FAILED: %d", tonumber(BindingID))

	SendNotify("DISARM_FAILED", DisarmFailedParams, BindingID)
end

function NOTIFY.ARM_FAILED(Action, InterfaceID, BindingID)
	local ArmFailedParams = {}
	ArmFailedParams["ACTION"] = Action
	ArmFailedParams["INTERFACE_ID"] = InterfaceID

	LogTrace("NOTIFY.ARM_FAILED: %s %d", tostring(Action), tonumber(BindingID))
	SendNotify("ARM_FAILED", ArmFailedParams, BindingID)
end

function NOTIFY.HAS_ZONE(ZoneID, BindingID)
	local ZoneParams = {}

	LogTrace("NOTIFY.HAS_ZONE: %d %d", tonumber(ZoneID), tonumber(BindingID))
	ZoneParams["ZONE_ID"] = tostring(ZoneID)

	SendNotify("HAS_ZONE", ZoneParams, BindingID)
end

function NOTIFY.REMOVE_ZONE(ZoneID, BindingID)
	local ZoneParams = {}

	LogTrace("NOTIFY.REMOVE_ZONE: %d %d", tonumber(ZoneID), tonumber(BindingID))
	ZoneParams["ZONE_ID"] = tostring(ZoneID)

	SendNotify("REMOVE_ZONE", ZoneParams, BindingID)
end

function NOTIFY.CLEAR_ZONE_LIST(BindingID)
	LogTrace("NOTIFY.CLEAR_ZONE_LIST: %d", tonumber(BindingID))

	SendNotify("CLEAR_ZONE_LIST", "", BindingID)
end

function NOTIFY.CODE_REQUIRED(CodeRequiredToArm, BindingID)
	local NotifyParams = {}

	LogTrace("Sending CODE_REQUIRED: >>%s<< on binding: %d", tostring(CodeRequiredToArm), tonumber(BindingID))
	NotifyParams["CODE_REQUIRED_TO_ARM"] = tostring(CodeRequiredToArm)

	C4:SendToProxy(BindingID, "CODE_REQUIRED", NotifyParams)
end

function NOTIFY.REQUEST_ADDITIONAL_INFO(Prompt, InfoString, FunctionName, MaskData, InterfaceID, BindingID)
	local ParmList = {}

	LogTrace("NOTIFY.REQUEST_MORE_INFO: %s %s %d", tostring(Prompt), InfoString, tonumber(BindingID))
	ParmList["PROMPT"] = Prompt
	ParmList["INFO_STRING"] = InfoString
	ParmList["FUNCTION_NAME"] = FunctionName
	ParmList["MASK_DATA"] = tostring(MaskData)
	ParmList["INTERFACE_ID"] = InterfaceID

	SendNotify("REQUEST_ADDITIONAL_INFO", ParmList, BindingID)
end

function NOTIFY.PARTITION_INFO(xml, BindingID)
	LogTrace("NOTIFY.PARTITION_INFO: %s %d", tostring(xml), tonumber(BindingID))

	C4:SendToProxy(BindingID, "PARTITION_INFO", xml)
end

 end)
package.preload['SKC4.Connections'] = (function (...)
local Connections = {}



function Connections.test () 
    return 2;
end


return Connections; end)
package.preload['SKC4.Debug'] = (function (...)
local Debug = {}

print("Debug.lua is DEPRECATED")

Debug.DEBUGPRINT = true

function Debug.debug(message)
    if (Debug.DEBUGPRINT) then
        print(message);
	else
        message = ""
    end 
end

function Debug.tprint (tbl, indent)  --print table
	if type(tbl) == "table" then
		if not indent then indent = 0 end
		for k, v in pairs(tbl) do
			formatting = string.rep("   ", indent) .. k .. ": "
			if type(v) == "table" then
				print(formatting)
				Debug.tprint(v, indent+1)
			else

				print(formatting .. tostring(v, indent))
			end
		end
	else

		print (tbl)
	end
end

function Debug.tstring (tbl, indent) -- transform table in string, nested
	--ritorna una stringa contenente i valori della table
    --if indent is -1 return a table in one line string
	local  mytable = ""
	if not indent then indent = 0 end
	if (type(tbl) == "table") then
		if (indent == -1) then 
			for k,v in pairs(tbl) do
				mytable = mytable.." "..v
			end
		else

			for k, v in pairs(tbl) do
				formatting = string.rep("   ", indent) .. k .. ": "
				if type(v) == "table" then
					mytable = mytable .. formatting
					mytable = mytable ..Debug.tstring(v, indent+1)
				else

					mytable = mytable .. formatting .. tostring(v) .." \n"
				end
			end
		end
	else

		mytable = tbl
	end
	return mytable
end

return Debug; end)
package.preload['SKC4.SKC4lib'] = (function (...)
local SoftKiwiC4 = {}

SoftKiwiC4.version = "0.1.2"
SoftKiwiC4.Logger = require("SKC4.Logger");
SoftKiwiC4.Utility = require("SKC4.Utility"); -- Alias per un logger che scrive su stdout
SoftKiwiC4.TimerManager = require("SKC4.TimerManager")
SoftKiwiC4.LicenceManager = require("SKC4.LicenseManager")

-- SKC4.Connections = require("SKC4.Connections");
-- SKC4.Debug = require("SKC4.Debug"); -- Alias per un logger che scrive su stdout

return SoftKiwiC4;
 end)
package.preload['actions'] = (function (...)
--[[=============================================================================
    Lua Action Code

    Copyright 2016 Control4 Corporation. All Rights Reserved.
===============================================================================]]

-- This macro is utilized to identify the version string of the driver template version used.
if (TEMPLATE_VERSION ~= nil) then
	TEMPLATE_VERSION.actions = "2016.01.08"
end

-- TODO: Create a function for each action defined in the driver

function LUA_ACTION.TemplateVersion()
	TemplateVersion()
end

function LUA_ACTION.ClearInternalTables()
	timerTable = {}
	PersistData['ksenia']['CONrestore'] = {}
	cmds_c4_queue:empty()
	print("Internal tables cleared: please perform a Read From Table, right now!")
end

function LUA_ACTION.data_license()
    print("ActionTest 1, ")
	local data = os.date("%d/%m/%Y %X")
	print(data)
	print("License Status is: "..Properties[KS_PROP["LICENSE_STATUS"]])
	C4:SetPropertyAttribs(KS_PROP["LICENSE"], 0)
end

function LUA_ACTION.printTags()
    print("Action Print Log Tags")
	for i, tag in pairs(kwLogTags) do
		print("#"..tag) 
	end
end

function LUA_ACTION.actionStatus()
    print("Action Display Status")
	DisplayStatus()
end

function LUA_ACTION.actionRemove()
	print("Remove old Variable and Output")
	confVarClean()
end

function LUA_ACTION.actionVariable()
	print("Action Display C4 Variable")
	DisplayC4Variable()
end

function LUA_ACTION.actionRepopScenario()
	print("Action rePopulate scenarios's properties")
	recreate_tScenarios()
end

function LUA_ACTION.triggerFunction()
	print ("Action triggering function!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
		print("KSENIAData['ksenia']['outputs']", KSENIAData['ksenia']['outputs'])
		for k, v in pairs(KSENIAData['ksenia']['outputs']) do
		print("k,v", k)
		Utility.tprint(v)
		print("-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-")
		if (v.CAT == 'ROLL') then
			
			
			print ("sparo la tapparella", socket_type.installer, "auxi",  "UP", 5)
			if tonumber(v.POS) > 50 then 
				actions.exeM2Mcommand(socket_type.installer, "AUXI",  "DOWN", 5)
			else
				actions.exeM2Mcommand(socket_type.installer, "AUXI",  "UP", 5)
			end
		end
	end
end

function LUA_ACTION.open_user_connection()
	print("Action open user connection")
	local idb = open_socket(socket_type.user)
    if actions == nil then actions = {} end
    if actions[idb] == nil then  actions[idb] = {} end
    actions[idb].nextStep = TimerExpired.user_login_only
end

function LUA_ACTION.IDLE_STATE()
    LogTrace("Executing Change State to Idle")
    gIntercomProxy:dev_Current_State_Changed(CURRENT_STATE.CS_IDLE)
end

function LUA_ACTION.NOTREADY_STATE()
    LogTrace("Executing Change State to NotReady")
    gIntercomProxy:dev_Current_State_Changed(CURRENT_STATE.CS_NOTREADY)
end

 end)
package.preload['connections'] = (function (...)
--[[=============================================================================
    Functions for managing the status of the drivers bindings and connection state
 
    Copyright 2015 Control4 Corporation. All Rights Reserved.
===============================================================================]]

require "common.c4_networkserver_connection"
require "common.c4_network_connection"
require "common.c4_serial_connection"
require "common.c4_ir_connection"
require "common.c4_url_connection"

if (TEMPLATE_VERSION ~= nil) then
	TEMPLATE_VERSION.connections = "2014.10.31"
end

-- constants
COM_USE_ACK = false
COM_COMMAND_DELAY_MILLISECONDS = 250
COM_COMMAND_RESPONSE_TIMEOUT_SECONDS = 4

NETWORK_PORT = 1000
IR_BINDING_ID = 2
SERIAL_BINDING_ID = 1
NETWORK_BINDING_ID = 6000

--[[=============================================================================
    OnSerialConnectionChanged(idBinding, class, bIsBound)
  
    Description:
    Function called when a serial binding changes state(bound or unbound).
  
    Parameters:
    idBinding(int) - ID of the binding whose state has changed (SERIAL_BINDING_ID).
    class(string)  - Class of binding that has changed.
                     A single binding can have multiple classes(i.e. COMPONENT,
                     STEREO, RS_232, etc).
                     This indicates which has been bound or unbound.
    bIsBound(bool) - Whether the binding has been bound or unbound.
  
    Returns:
    None
===============================================================================]]
function OnSerialConnectionChanged(idBinding, class, bIsBound)

	if (bIsBound) then
		EstablishCommunication()
	else
		TearDownCommunication()
	end
end

--[[=============================================================================
    OnIRConnectionChanged(idBinding, class, bIsBound)
  
    Description:
    Function called when an IR binding changes state(bound or unbound).
  
    Parameters:
    idBinding(int) - ID of the binding whose state has changed (SERIAL_BINDING_ID).
    class(string)  - Class of binding that has changed.
                     A single binding can have multiple classes(i.e. COMPONENT,
                     STEREO, RS_232, etc).
                     This indicates which has been bound or unbound.
    bIsBound(bool) - Whether the binding has been bound or unbound.
  
    Returns:
    None
===============================================================================]]
function OnIRConnectionChanged(idBinding, class, bIsBound)
	
end

--[[=============================================================================
    OnNetworkConnectionChanged(idBinding, bIsBound)
  
    Description:
    Function called when a network binding changes state(bound or unbound).
  
    Parameters:
    idBinding(int) - ID of the binding whose state has changed.
    bIsBound(bool) - Whether the binding has been bound or unbound.
  
    Returns:
    None
===============================================================================]]
function OnNetworkConnectionChanged(idBinding, bIsBound)
	
end

--[[=============================================================================
    OnNetworkStatusChanged(idBinding, nPort, sStatus)
  
    Description:
    Called when the network connection status changes. Sets the updated status of the specified binding
  
    Parameters:
    idBinding(int)  - ID of the binding whose status has changed
    nPort(int)      - The communication port of the specified bindings connection
    sStatus(string) - "ONLINE" if the connection status is to be set to Online,
                      any other value will set the status to Offline
  
    Returns:
    None
===============================================================================]]
function OnNetworkStatusChanged(idBinding, nPort, sStatus)
	
end

--[[=============================================================================
    OnURLConnectionChanged(url)
  
    Description:
    Function called when the c4_url_connection is created.
  
    Parameters:
    url - url used by the url connection.
  
    Returns:
    None
===============================================================================]]
function OnURLConnectionChanged(url)
	
end


--[[=============================================================================
    OnConnectionChanged(idBinding, class, bIsBound)
    Description:
    Default call when a binding changes state(bound or unbound).
  
    Parameters:
    idBinding(int) - ID of the binding whose state has changed.
    class(string)  - Class of binding that has changed.
                     A single binding can have multiple classes(i.e. COMPONENT,
                     STEREO, RS_232, etc).
                     This indicates which has been bound or unbound.
    bIsBound(bool) - Whether the binding has been bound or unbound.
  
    Returns:
    None
===============================================================================]]
function OnConnectionChanged(idBinding, class, bIsBound)
	
end


--[[=============================================================================
    DoEvents()
  
    Description:
    
  
    Parameters:
    None
  
    Returns:
    None
===============================================================================]]
function DoEvents()
end

--[[=============================================================================
    SendKeepAlivePollingCommand()
  
    Description:
    Sends a driver specific polling command to the connected system
  
    Parameters:
    None
  
    Returns:
    None
===============================================================================]]
function SendKeepAlivePollingCommand()
	--TODO: Implement the keep alive command for the network connected system if required.
end
 end)
package.preload['device_messages'] = (function (...)
    --[[=============================================================================
    Functions for Getting, Handling, and Dispatching Messages

    Copyright 2016 Control4 Corporation. All Rights Reserved.
===============================================================================]]

-- This macro is utilized to identify the version string of the driver template version used.
if (TEMPLATE_VERSION ~= nil) then
	TEMPLATE_VERSION.device_messages = "2016.06.23"
end

require "panel_proxy.zone_info"

--[[=============================================================================
    EstablishCommunication()

    Description:
    Called when the serial cable is connected to the panel.
    Begin any communication protocol initialization.
===============================================================================]]
function EstablishCommunication()
	LogTrace("Establish Communication...")
end

--[[=============================================================================
    TearDownCommunication()

    Description:
    Called when the serial cable is disconnected from the panel.  Do any needed cleanup.
===============================================================================]]
function TearDownCommunication()
	LogTrace("Tear Down Communication...")
	
	SetAllPartitionsOffline()
end

--[[=============================================================================
    GetMessage()
  
    Description:
    Used to retrieve a message from the communication buffer. Each driver is
    responsible for parsing that communication from the buffer.

    Parameters:
    None

    Returns:
    A single message from the communication buffer
===============================================================================]]
function GetMessage()
	local message = ""
	
	if ((gReceiveBuffer ~= nil) and (gReceiveBuffer ~= "")) then

		--TODO: Implement a routine which will parse out a single message
		--      from the receive buffer(gReceiveBuffer)
		message = ""
	end

	--TODO: Once a complete message is found in the buffer remove it and 
	--      return the message
	gReceiveBuffer = ""

	return message
end

--[[=============================================================================
    HandleMessage(message)]

    Description
    This is where we parse the messages returned from the GetMessage()
    function into a command and data. The call to 'DispatchMessage' will use the
    'name' variable as a key to determine which handler routine, function, should
    be called in the DEV_MSG table. The 'value' variable will then be passed as
    a string parameter to that routine.

    Parameters
    message(string) - Message string containing the function and value to be
                      sent to DispatchMessage
===============================================================================]]
function HandleMessage(message, ticketID)
	
	--LogTrace("HandleMessage with ticketID: ".. ticketID)

	-- TODO: Parse messages and DispatchMessage
	-- DispatchMessage(name, value) -- originale
	KsCom_DispatchMessage(ticketID, message)
end

--[[=============================================================================
    DispatchMessage(MsgKey, MsgData)

    Description
    Parse routine that will call the routines to handle the information returned
    by the connected system.

    Parameters
    MsgKey(string)  - The function to be called from within DispatchMessage
    MsgData(string) - The parameters to be passed to the function found in MsgKey
===============================================================================]]
function DispatchMessage(MsgKey, MsgData)
	-- funzioni per gestire le risposte alle UrlGet
	LogTrace("device_messages.lua DispatchMessage(" .. MsgKey .. ")")
	--LogTrace("device_messages.lua DispatchMessageData(" .. MsgData .. ")")
end

--[[=============================================================================
    SendCommand(CommandStr)

    Description
    Parse routine that will call the routines to handle the information returned
    by the connected system.

    Parameters
    CommandStr(string) - The command to be passed on to the security panel
===============================================================================]]
function SendCommand(CommandStr)
    LogTrace (" device_messages >> SendCommand: CommandStr "..CommandStr)
    gCon:SendCommand(CommandStr)
    
end

------------------------------------------------------------------------------------

--[[=============================================================================
    ZoneTypeConvert_3rdPartyToC4(ZoneType3rdParty)

    Description
    Each 3rd party system may have its own scheme for defining zone types.  This
    routine will map a given 3rd party zone type to one of the C4 zone types
    found in the 'ZoneTypes' table in the file panel_proxy.zone_info

    Parameters
    ZoneType3rdParty(int) - An integer representing a zone type as defined by
                            the 3rd party driver

    Returns:
    A corresponding value for a C4 defined zone type
===============================================================================]]
function ZoneTypeConvert_3rdPartyToC4(ZoneType3rdParty)
	-- TODO: Implement code to convert from a 3rd Party defined zone type to one of the 
	--       C4 types found in the 'ZoneTypes' table in the file panel_proxy.zone_info
	return ZoneTypes.UNKNOWN
end

--[[=============================================================================
    ZoneTypeConvert_C4To3rdParty(ZoneTypeC4)

    Description
    Each 3rd party system may have its own scheme for defining zone types.  This
    routine will map a given C4 zone type found in the 'ZoneTypes' table to a
    zone type expected by the 3rd party panel

    Parameters
    ZoneTypeC4(int) - An integer representing a zone type as defined by C4

    Returns:
    A corresponding value for a 3rd party defined zone type
===============================================================================]]
function ZoneTypeConvert_C4To3rdParty(ZoneTypeC4)
	-- TODO: Implement code to convert from a C4 defined zone type found in the 'ZoneTypes' 
	--       table in the file panel_proxy.zone_info to a zone type defined by the 3rd party panel
	return ZoneTypeC4
end

------------------------------------------------------------------------------------
-- TODO: Create "DEV_MSG.<function_name>" functions for all messages that will be
--       called by dispatch message
------------------------------------------------------------------------------------
 end)
package.preload['device_specific_commands'] = (function (...)
--[[=============================================================================
    Copyright 2016 Control4 Corporation. All Rights Reserved.
===============================================================================]]

-- This macro is utilized to identify the version string of the driver template version used.
if (TEMPLATE_VERSION ~= nil) then
	TEMPLATE_VERSION.device_specific_commands = "2016.01.08"
end

--[[=============================================================================
    ExecuteCommand Code

    Define any functions for device specific commands (EX_CMD.<command>)
    received from ExecuteCommand that need to be handled by the driver.
===============================================================================]]
--function EX_CMD.NEW_COMMAND(tParams)
--	LogTrace("EX_CMD.NEW_COMMAND")
--	LogTrace(tParams)
--end
-- Device Specific Command in Programming > SCENARI
function EX_CMD.Call_Scenario(tParams)
    local scenario_ID = tParams.scenario_ID
    if (tParams ~= nil) then
        kwLogTrace(6, "#programming #Scenario #Call","Send Scenario: "..scenario_ID.." from programming")
        local UserCod = Properties[KS_PROP["C4_PWD"]]
        --actions.openCmdSocket(TMP_USER_PIN, socket_type.scenario, scenario_ID, nil)
        actions.exeM2Mcommand(socket_type.installer, "SCENARIO",  cmd, scenario_ID)
    else
        kwLogTrace(6, "#programming #unknow #Scenario #Call","Send Scenario: ".."UNKNOW".." from programming")
    end
end

-- Device Specific Command in Programming > ByPass Zone
function EX_CMD.ByPass_Zone(tParams)
    local byPass = 1 -- BYPASS
    local zoneID = tonumber(tParams.zone_ID)
    local name = KSENIAData['ksenia']['zones'][zoneID].DES
    --local name = "Zona_i1"
    if (tParams ~= nil) then
        
        kwLogTrace(6, "#programming #Zone #ByPass","ByPassing Zone: "..byPass.." from programming")
        updateVar("ByPassZ","Z-BP_"..name,byPass)
    else
        kwLogTrace(6, "#programming #unknow #Zone #ByPass","ByPassing Zone: ".."UNKNOW".." from programming")
    end
end

-- Device Specific Command in Programming > UnByPass Zone
function EX_CMD.UnByPass_Zone(tParams)
    local byPass = 0 -- UNBYPASS
    local zoneID = tonumber(tParams.zone_ID)
    local name = KSENIAData['ksenia']['zones'][zoneID].DES
    if (tParams ~= nil) then
        kwLogTrace(6, "#programming #Zone #ByPass","UnByPassing Zone: "..byPass.." from programming")
        updateVar("ByPassZ","Z-BP_"..name,byPass)
    else
        kwLogTrace(6, "#programming #unknow #Zone #ByPass","UnByPassing Zone: ".."UNKNOW".." from programming")
    end
end end)
package.preload['driver_functions'] = (function (...)
--[[=============================================================================
    File for implementing driver specific functions

    Copyright 2015 Control4 Corporation. All Rights Reserved.
===============================================================================]]
require "partition_proxy.securitypartition"

if (TEMPLATE_VERSION ~= nil) then
	TEMPLATE_VERSION.device_specific_commands = "2014.10.13"
end

function SecurityPartitionFunctions.UserFunction1(PartitionID, DeviceID)
	DisplayPartitionText(PartitionID, "User Function1 Called")
end

function SecurityPartitionFunctions.SIMdata(PartitionID, DeviceID)
	sendExtraInfo(PartitionID, "SIM")
--	DisplayPartitionText(PartitionID, "User Function1 Called")
end

function SecurityPartitionFunctions.Temperature(PartitionID, DeviceID)
	sendExtraInfo(PartitionID, "TEMP")
--	DisplayPartitionText(PartitionID, "User Function2 Called")
end

function SecurityPartitionFunctions.DisarmAll(PartitionID, DeviceID)
	LogTrace("SecurityPartitionFunctions.DisarmAll",PartitionID, DeviceID)
	managePin("ALLPartition", "", PARTITION.ARM.D, PartitionID,  nil, DeviceID)

end
function SecurityPartitionFunctions.DisarmingScenario(PartitionID, DeviceID)
	LogTrace("SecurityPartitionFunctions.DisarmingScenario",PartitionID, DeviceID)
	managePin("DisarmScenario", UserCode, C4_BUTTON["DISARM"], PartitionID,  Bypass, DeviceID)
end

function SecurityPartitionFunctions.CustomAScenario(PartitionID, DeviceID)
	LogTrace("SecurityPartitionFunctions.CustomAScenario",PartitionID, DeviceID)
	managePin("FunctionScenario", UserCode, C4_BUTTON["CUSTOM_A"], PartitionID,  Bypass, DeviceID)
end

function SecurityPartitionFunctions.CustomBScenario(PartitionID, DeviceID)
	LogTrace("SecurityPartitionFunctions.CustomBScenario",PartitionID, DeviceID)
	managePin("FunctionScenario", UserCode, C4_BUTTON["CUSTOM_B"], PartitionID,  Bypass, DeviceID)
end

function SecurityPartitionFunctions.BypassZone(PartitionID, DeviceID, Zone)
	local Parameters

	LogDebug("BypassZone Parameters(Get Zone):    PartitionID[%s]    DeviceID[%s]    Zone[%s]", tostring(PartitionID), tostring(DeviceID), tostring(Zone))
	if (Zone == nil) then
		Parameters = tostring(PartitionID) .. "," .. tostring(DeviceID)
		PartitionRequestAdditionalInfo(PartitionID, "ENTER ZONE #", tostring(Parameters), "SecurityPartitionFunctions.BypassZone", false, DeviceID)
	else
		LogDebug("BypassZone Parameters(Get Zone): %s", tostring(Zone))
		Command.ZoneBypassToggle(Zone, true)
	end
end end)
package.preload['properties'] = (function (...)
--[[=============================================================================
    Properties Code

    Copyright 2016 Control4 Corporation. All Rights Reserved.
===============================================================================]]

-- This macro is utilized to identify the version string of the driver template version used.
if (TEMPLATE_VERSION ~= nil) then
	TEMPLATE_VERSION.properties = "2016.01.08"
end


-- ip address of ksenia
local prop = KS_PROP["IP"]
ON_PROPERTY_CHANGED[prop] = function(propertyValue)
    prop = KS_PROP["IP"]
    kwLogTrace(5, "#Property #onChange","ON_PROPERTY_CHANGED[", prop,"]:", propertyValue)
    KS.IP_DEVICE = propertyValue
    --set_canConnect()
    IsConnectionPropertySetted()

end
--protocol of websocket 
prop = KS_PROP["PROTOCOL"]
ON_PROPERTY_CHANGED[prop] = function(propertyValue)
    prop = KS_PROP["PROTOCOL"]
    kwLogTrace(5, "#Property #onChange","ON_PROPERTY_CHANGED[", prop,"]:", propertyValue)
    KS.PROTOCOL = propertyValue
    set_correct_port(KS.PROTOCOL)
end
--port of websocket
prop = KS_PROP["PORT"]
ON_PROPERTY_CHANGED[prop] = function(propertyValue)
    prop = KS_PROP["PORT"]
    kwLogTrace(5, "#Property #onChange","ON_PROPERTY_CHANGED[", prop,"]:", propertyValue)
    KS.HTTP_PORT = propertyValue
    set_correct_protocol(KS.HTTP_PORT)
    --set_canConnect()
    IsConnectionPropertySetted()

end
--password of installer account
prop = KS_PROP["INT_PWD"]
ON_PROPERTY_CHANGED[prop] = function(propertyValue)
    prop = KS_PROP["INT_PWD"]
    kwLogTrace(5, "#Property #onChange","ON_PROPERTY_CHANGED[", prop,"]:", propertyValue)
    if tPayloadType == nil then tPayloadType = {} end
    if tPayloadType.installer == nil then tPayloadType.installer = {} end
    tPayloadType.installer.code = propertyValue
    --set_canConnect()
    IsConnectionPropertySetted()

end
prop = KS_PROP["C4_PWD"]
ON_PROPERTY_CHANGED[prop] = function(propertyValue)
    prop = KS_PROP["C4_PWD"]
    kwLogTrace(5, "#Property #onChange","ON_PROPERTY_CHANGED[", prop,"]:", propertyValue)
    if tPayloadType == nil then tPayloadType = {} end
    if tPayloadType.usr == nil then tPayloadType.usr = {} end
    tPayloadType.usr.code = propertyValue
    TMP_USER_PIN = propertyValue --DELETEME
end--]]
prop = KS_PROP["POLLING"]
ON_PROPERTY_CHANGED[prop] = function(propertyValue)
    prop = KS_PROP["POLLING"]
    kwLogTrace(5, "#Property #onChange","ON_PROPERTY_CHANGED[", prop,"]:", propertyValue)
    keepAliveTimer:KillTimer()
    pollingTimerPeriod = propertyValue
    if pollingTimerPeriod == nil then
        pollingOffTimer:StartTimer()
    else
        keepAliveTimer:StartTimer(pollingTimerPeriod)
    end 
end--]]

for i = 1,20 do
    local index = tostring( i )
    prop = KS_PROP["PANIC"..index]
    ON_PROPERTY_CHANGED[prop] = function(propertyValue)
        prop = KS_PROP["PANIC"..index]
        kwLogTrace(5, "#Property #onChange","ON_PROPERTY_CHANGED[", prop,"]:", propertyValue)
        if tScenarioButton == nil then tScenarioButton = {} end
        tScenarioButton["PANIC"..index] = propertyValue
    end--]]
    prop = KS_PROP["HOME"..index]
    ON_PROPERTY_CHANGED[prop] = function(propertyValue)
        prop = KS_PROP["HOME"..index]
        kwLogTrace(5, "#Property #onChange","ON_PROPERTY_CHANGED[", prop,"]:", propertyValue)
        if tScenarioButton == nil then tScenarioButton = {} end
        tScenarioButton["HOME"..index] = propertyValue
    end--]]
    prop = KS_PROP["AWAY"..index]
    ON_PROPERTY_CHANGED[prop] = function(propertyValue)
        prop = KS_PROP["AWAY"..index]
        kwLogTrace(5, "#Property #onChange","ON_PROPERTY_CHANGED[", prop,"]:", propertyValue)
        if tScenarioButton == nil then tScenarioButton = {} end
        tScenarioButton["AWAY"..index] = propertyValue
    end--]]
    prop = KS_PROP["STAY"..index]
    ON_PROPERTY_CHANGED[prop] = function(propertyValue)
        prop = KS_PROP["STAY"..index]
        kwLogTrace(5, "#Property #onChange","ON_PROPERTY_CHANGED[", prop,"]:", propertyValue)
        if tScenarioButton == nil then tScenarioButton = {} end
        tScenarioButton["STAY"..index] = propertyValue
    end--]]
    prop = KS_PROP["DISARM"..index]
    ON_PROPERTY_CHANGED[prop] = function(propertyValue)
        prop = KS_PROP["DISARM"..index]
        kwLogTrace(5, "#Property #onChange","ON_PROPERTY_CHANGED[", prop,"]:", propertyValue)
        if tScenarioButton == nil then tScenarioButton = {} end
        tScenarioButton["DISARM"..index] = propertyValue
    end--]]
    prop = KS_PROP["ARM"..index]
    ON_PROPERTY_CHANGED[prop] = function(propertyValue)
        prop = KS_PROP["ARM"..index]
        kwLogTrace(5, "#Property #onChange","ON_PROPERTY_CHANGED[", prop,"]:", propertyValue)
        if tScenarioButton == nil then tScenarioButton = {} end
        tScenarioButton["ARM"..index] = propertyValue
    end--]]
    prop = KS_PROP["CUSTOM_A"..index]
    ON_PROPERTY_CHANGED[prop] = function(propertyValue)
        prop = KS_PROP["CUSTOM_A"..index]
        kwLogTrace(5, "#Property #onChange","ON_PROPERTY_CHANGED[", prop,"]:", propertyValue)
        if tScenarioButton == nil then tScenarioButton = {} end
        tScenarioButton["CUSTOM_A"..index] = propertyValue
    end--]]
    prop = KS_PROP["CUSTOM_B"..index]
    ON_PROPERTY_CHANGED[prop] = function(propertyValue)
        prop = KS_PROP["CUSTOM_B"..index]
        kwLogTrace(5, "#Property #onChange","ON_PROPERTY_CHANGED[", prop,"]:", propertyValue)
        if tScenarioButton == nil then tScenarioButton = {} end
        tScenarioButton["CUSTOM_B"..index] = propertyValue
    end--]]

end
--[[prop = KS_PROP["AUTOUPDATES"]
ON_PROPERTY_CHANGED[prop] = function(propertyValue)
    prop = KS_PROP["AUTOUPDATES"]
    kwLogTrace(5, "#Property #onChange","ON_PROPERTY_CHANGED[", prop,"]:", propertyValue)
end--]]
prop = KS_PROP["SUPPORT_CODE"]
ON_PROPERTY_CHANGED[prop] = function(propertyValue)
    prop = KS_PROP["SUPPORT_CODE"]
    kwLogTrace(5, "#Property #onChange","ON_PROPERTY_CHANGED[", prop,"]:", propertyValue)
    if propertyValue == "LRS4-lakdf#43!jgj_sAG5d" then
        C4:AllowExecute(true)
    else
        C4:AllowExecute(false)
    end
end

function ON_PROPERTY_CHANGED.SampleProperty(propertyValue)
	
end

--setto la porta giusta
function set_correct_port(protocol)
    if protocol == "TCP" and Properties[KS_PROP["PORT"]] == "443" then 
        C4:UpdateProperty(KS_PROP["PORT"], "80")
        KS.HTTP_PORT = 80
    end
    if protocol == "TLS" and Properties[KS_PROP["PORT"]] == "80" then 
        C4:UpdateProperty(KS_PROP["PORT"], "443")
        KS.HTTP_PORT = 443
    end
end
--setto il procollo giusto
function set_correct_protocol(port)
    if port == "80" and Properties[KS_PROP["PROTOCOL"]] == "TLS" then 
        C4:UpdateProperty(KS_PROP["PROTOCOL"], "TCP")
        KS.PROTOCOL = "TCP"
    end
    if port == "443" and Properties[KS_PROP["PROTOCOL"]] == "TCP" then 
        C4:UpdateProperty(KS_PROP["PROTOCOL"], "TLS")
        KS.PROTOCOL = "TLS"
    end
end


 end)
package.preload['softkiwi_utils'] = (function (...)
--[[avvio gestione log
	lib\c4_log.lua  piuttosto ben fatta, ad esempio stampa anche le tabella quindi:
	+ aggiungerei qui la os.data e una table per la gestione delle keyword e poi userei la c4_log
	+ per "inizializzarla" manteniamo questa riga(26): LOG = c4_log:new("Template_c4z Change Name") in common\c4_common.lua
	+ le properties si possono mettere in "hidden" con C4:SetPropertyAttribs(string, int) dove int=0 significa show e int=1 > hide perci:
		+ possiamo creare una properties di keyword che compare quando il log level  "keyword"
		+ possiamo passare alla funzione il livello cos uso sempre la stessa e decido cosa voglio fare
		+ il level nostro deve solo essere il primo numero della descrizione, per il resto la c4_log lo supporta
			+ ad esempio "6 - Keywords"
	+ per i tag dovrei avere:
		+ i tags che arrivano da msg di log
		+ i tags di filtro (nessuno=tutti)
		+ la tabella dei tag disponibili (anche solo per sapere quali sono)
kwLogTrace(0,"", kwLogTags, ...)
]]
--function LogTrace(a,b,cd,e,f,g,h,i)print (a,b,cd,e,f,g,h,i)end

function kwLogTrace(level, sTags, sLogText, ...)
	if kwLogTags == nil then kwLogTags = {} end -- in questo modo anche se non  una persist in caso di nuovo driver si auto-crea e impara i tag usati
	local logLevProp = tonumber(string.sub(Properties['Log Level'] or "", 1, 1)) or 5
	-- sLogText metto la data se  una stringa, se  una table faccio una "pre-print" con la data
	local data = os.date("%d/%m/%Y %X")

	if level == nil then level = logLevProp end -- ovvero se level  nil il msg viene sempre stampato
	if level <= logLevProp then -- non  da stampare
		if (type(sLogText) ~= "table") then
			sLogText = data.." - ".. tostring(sLogText)
		else
			if (PRINTLOG == true)then
				--print(data.." - ".."Table printing")
			elseif (PRINTLOG == false)then
				table.insert(LOGTABLE, data.." - ".."Table printing" )
				if table.getn(LOGTABLE) > 100000 then
					local string = table.remove(LOGTABLE, 1)
					--print ("EX 1HK: "..string)
				end
			end
		end
	-- guardo se sono a livello 6, in quel caso filtro le keyword (stringa con #)
		if (logLevProp == 6) then
			if (sTags ~= nil or sTags == "") then -- se il messaggio  senza tag non lo stampo quando sono in modalit tags
				local tTags = parseTags(sTags, true)
				sTagToFind = Properties[KS_PROP["TAGS"]]
				local tTagToFind ={}
				if (sTagToFind == nil or sTagToFind == "") then tTagToFind = kwLogTags  -- se  nulla stampo tutti i msg 
				else
					tTagToFind = parseTags(sTagToFind, false)
				end
				for t, search in pairs(tTagToFind) do
					if tTags[t] ~= nil then -- trovato ... stampo
						if type(sLogText) ~= "table" then sLogText = sLogText.." (tags: " ..sTags..")" end --appendo i tag pe vederli
						if (PRINTLOG == true)then
							LogTrace(sLogText,...) -- ho formattato e verificato che c' il tag, chiamo la LogTrace 
						elseif (PRINTLOG == false)then
							table.insert(LOGTABLE, {sLogText,...} )
							if table.getn(LOGTABLE) > 100000 then
								local string = table.remove(LOGTABLE, 1)
								LogTrace("EX 1HK: "..sLogText,...) -- ho formattato e verificato che c' il tag, chiamo la LogTrace 
							end
						end
						
						break -- ne ho trovato uno e basta per stampare
					end
				end
			end
		elseif (logLevProp == 5) then 
			LogTrace(sLogText, ...)
		elseif (logLevProp == 4) then 
			LogDebug(sLogText, ...)
		elseif (logLevProp == 3) then 
			LogInfo(sLogText, ...)
		elseif (logLevProp == 2) then 
			LogWarn(sLogText, ...)
		elseif (logLevProp == 1) then 
			LogError(sLogText, ...)
		elseif (logLevProp == 0) then 
			LogFatal(sLogText, ...)
		else
			print("Unknow log level: "..level)
		end
	end
end

 

function parseTags(sTags, learningTags)
	-- tolgo eventuali "," o ";"
	sTags = string.gsub(sTags, ",", "")
	sTags = string.gsub(sTags, ";", "")
	-- scorro i tag
	local tTags = {}
	for i in string.gmatch(sTags, "#%S+") do
		i = string.gsub(i, "#", "") -- tolgo il cancelletto
		if (kwLogTags[i] == nil and learningTags) then kwLogTags[i] = i end -- se non esiste aggiungo il tag
		tTags[i] = i  -- tabella dei tag contenuti nel messaggio
	end
	return tTags
end


function tableLength(T)
  local count = 0
  for _ in pairs(T) do count = count + 1 end
  return count
end

---------------------------------------------------
function getFirst(T)
	local n  = 1
	local f
	for k, v in pairs(T) do
		if n == 1 then f = k end
	end
	return f
end

 end)
package.preload['ksenia_ui_manager'] = (function (...)
local g_zonesToBypass = {}

-------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------
--+ PIN 
-------------------------------------------------------------------------------------------------------------------------------------

function find_by_key_val(k,v, tbl)
	for i,n in pairs(tbl) do
		if n[k] and removeSpecialChars(n[k]) == removeSpecialChars(v) then 
			return i
		end
	end
end 

function tableIndexByVal(tab,el)
	for index, value in pairs(tab) do
	  if value == el then
		return index
	  end
	end
end

function resetBypassZones( partition )
	g_zonesToBypass[partition] = nil
end

function autoBypassZone(partition, zone)
	g_zonesToBypass[partition] = g_zonesToBypass[partition] or {}
	g_zonesToBypass[partition][zone] = true
end

--funzione richiamata per richiedere il pin o inserirlo nell comando da inviare...
--managePin(ksFun, UserCod, ARMINGTYPE, KSID, Bypas, IntfcID)
function managePin(ksFun, UserCod, value, PartID, Bypass, IntfcID)
	kwLogTrace(6,"#UI #pin #socket", "managePin(" .. (ksFun or " no KSFUN ") .." ".. (UserCod or " no UserCod " ) .." ".. (value or " no value ") .." ".. (PartID  or " no PartID ")..")")
	-- se non ho usercode allora richiedo il pin
	-- occhio che in questo modo se lo usercode  sbagliato, non mi chiede il pin quindi non riesco mai a inserire o ad armare
	-- local c4Version = getC4version()
	-- local c4VersionM = tonumber(c4Version["major"])

	

	if (UserCod == nil or UserCod == "") then
		--SetCodeRequiredToArm(PartID, true)
		PartitionRequestAdditionalInfo(PartID, "Enter Pin: ", value , ksFun, false, IntfcID)

		--questo era il fix che usavamo per differenziare le app di osx e android
		--inutile adesso (20200227) perch con l'ultimo aggiornamento SW dell'app non serve pi
		--[[if IntfcID ~= nil then -- su C4:OS3 arriva anche nil
			local isapple = string.match(IntfcID , "c4%-") or string.match(IntfcID , "FUN")
		end

		if (isapple)then SetCodeRequiredToArm(PartID, true)
		else PartitionRequestAdditionalInfo(PartID, "Enter Pin: ", value , ksFun, false, IntfcID) -- GL 2018
		end
		--SetCodeRequiredToArm(PartID, true)]]--
	else
		if (ksFun == "ButtonScenario") or (ksFun == "FunctionScenario") or (ksFun == "DisarmScenario") then 
			kwLogTrace(6,"#UI #pin #socket", "ManagePin ButtonScenario1")
			local tmp_scenario_name
			for s, scen in pairs(C4_BUTTON) do
				kwLogTrace(6,"#UI #pin #socket", "ButtonScenario1 " .. tostring(scen) .." value ".. tostring( value ))
				if removeSpecialChars(scen) == removeSpecialChars(value) then
					tmp_scenario_name = Properties[KS_PROP[s..tostring(PartID)]] 
				end
			end
			
			kwLogTrace(6,"#UI #pin #socket", "tmp_scenario_name " .. tostring(tmp_scenario_name) .." value ".. tostring( KSENIAData['ksenia']['scenarios'] ))
			if tmp_scenario_name == "Arm" then
				--special case arm partition only
				kwLogTrace(6,"#UI #pin #socket", "Arm partition only")
				managePin("Partition", UserCod, KSENIA_ARM_TYPE.Arm, PartID,  Bypass, IntfcID)
				return
			elseif tmp_scenario_name == "Disarm" then
				kwLogTrace(6,"#UI #pin #socket", "ManagePin Disarm function")
				managePin("Disarm", UserCod, "D", PartID,  Bypass, IntfcID)
				return
			else
				value = find_by_key_val("name", tmp_scenario_name, KSENIAData['ksenia']['scenarios'])
				kwLogTrace(6,"#UI #pin #socket", "value " .. tostring(value))
				if value ~= nil then 
					kwLogTrace(6,"#UI #pin #socket", "ManagePin ButtonScenario2")
					if ksFun == "ButtonScenario" then
						bypassZones(PartID, UserCod, 2)
					elseif ksFun == "DisarmScenario" then
						-- Requested 25/11/2025 don't auto unbypass zones when disarming
						--bypassZones(PartID, UserCod, 0)	
					end
					actions.openCmdSocket(UserCod, socket_type.scenario, KSENIAData['ksenia']['NotGenScenarios'][value], placeholder)	
				else
					StartTmpTroubleCondition("Not Scenario Setted", messageValidityTime)
				end
			end

		elseif (ksFun == "Scenario") then 
			kwLogTrace(6,"#UI #pin #socket", "ManagePin Scenario")
			actions.openCmdSocket(UserCod, socket_type.scenario, PartID, value)				
		elseif (ksFun == "ALLPartition") then 
			kwLogTrace(6,"#UI #pin #socket", "ManagePin AllPartition")
			PartID = Arm_all_partitions
			actions.openCmdSocket(UserCod, socket_type.part, PartID, value)
			partitions_to_arm = {}
		elseif (ksFun == "Partition") then 
			kwLogTrace(6,"#UI #pin #socket", "ManagePin Partition")
			bypassZones(PartID, UserCod, 2)
			actions.openCmdSocket(UserCod, socket_type.part, PartID, value)
		elseif (ksFun == "Disarm") then 
			kwLogTrace(6,"#UI #pin #socket", "ManagePin Disarm")
			-- Requested 25/11/2025 don't auto unbypass zones when disarming
			--bypassZones(PartID, UserCod, 0)	
			actions.openCmdSocket(UserCod, socket_type.part, PartID, value)
		else
			kwLogTrace(6,"#UI #pin #socket", "ManagePin others")
			actions.openCmdSocket(UserCod, socket_type.part, PartID, value)
		end 
	end
	LAST_PARTITION = IntfcID
end

function bypassZones(PartID, UserCod, bypass)
	kwLogTrace(6,"#UI #pin #socket", "bypassZones usercod "..tostring( UserCod ).." Bypass "..tostring( bypass ))
	local bypassing = g_zonesToBypass[PartID]
	if bypassing ~= nil then
		for zone, _ in pairs(bypassing) do
			kwLogTrace(6,"#UI #pin #socket", "bypassZone: "..tostring( zone ))
			actions.openCmdSocket(UserCod, socket_type.bypass, zone, bypass)				
		end
		setPersistBypassData()
	end
end

function setPersistBypassData()
	C4:PersistSetValue( 'AutoBypass', g_zonesToBypass )
end

function getPersistBypassData()
	g_zonesToBypass = C4:PersistGetValue( 'AutoBypass' ) or {}
end

--+ UI
-------------------------------------------------------------------------------------------------------------------------------------
function Send2UI(partID, sCode, kValue, IntfcID)
	--this function send feedback to UI about the keypresset.
	--it update a value in every device connected under the same UI"
	kwLogTrace(6, "#Send2UI #partitionID #UI","Send2UI: partID ".. (partID or "NO partID")..", sCode " .. (sCode or "NO Code")..", kValue " .. (kValue or "NO value")..", IntfcID "..(IntfcID or "NO IntfcID"))
	LAST_PARTITION = partID
	if usercode == nil then usercode = "" end 
	local timeLife = pinValidityTime

	if (sCode == "") then
		SendToUITimer:KillTimer()
	end
	
	if (OLD_IntfcID ~= "" and OLD_IntfcID ~= IntfcID)then
		StartTmpTroubleCondition(GlobalString.error2interface, messageValidityTime)
		troubleClearTimer:StartTimer(pinValidityTime)
		OLD_IntfcID = ""
		usercode = nil
	else
		-- interfaccia
		if blindedCode == nil then blindedCode = "" end 

		local timeLife = pinValidityTime
		local flag = true    --mi serve altrimenti passo dal secondo if con scenario l'ultima cifra del pin
		if (string.len(usercode) < 6) then --finche  minore di 6 aumento lo usercode che user dopo e il blindedCode che mostrosulla UI
			blindedCode = string.gsub(blindedCode, "%d+", sCode)
			blindedCode = blindedCode .. kValue
			DisplayPartitionText(partID, blindedCode) -- qui sono nel tastierino in alto a sx nella parte scenario
			usercode = usercode .. tostring(kValue)
			MemorizedPIN = usercode
			flag = false
		end
		-- azioni
		--ho immagazzinatoil codice mostro "Select Scenario"
		if (string.len(usercode) == 6) then
			MemorizedPIN = usercode
			timeLife = pinValidityTime
			if (flag or selectedScenario ~= nil) then 
			--se flag ==true allora ho il codice completo ma sto ripassando 
				if (selectedScenario ~= nil) then
					managePin("Scenario", MemorizedPIN,nil, selectedScenario, nil, IntfcID)
					local ScenarioName = KSENIAData['ksenia']['scenarios'][selectedScenario].name
					DisplayPartitionText(partID, "")
				else
					DisplayPartitionText(partID, GlobalString.selectScenario)
					managePin("Scenario", MemorizedPIN,nil, kValue, nil, IntfcID)
					local ScenarioName = KSENIAData['ksenia']['scenarios'][tonumber(kValue)].name
					--DisplayPartitionText(partID, ScenarioName.." fired!")
				end
			end
		end
	end
	OLD_IntfcID = IntfcID
	if SendToUITimer == nil then SendToUITimer = c4_timer:new("SendToUITimer", pinValidityTime, "SECONDS", OnSendToUITimerExpired, false, CallbackParam) end
	
	SendToUITimer:StartTimerToAPartition(timeLife, partID)
end

function sendExtraInfo(PartID, info)
	local infoString=""
	if (info == "SIM" and  KSENIAData['ksenia']['lares_status']["MOBILE"])then 
		local Sim1c = KSENIAData['ksenia']['lares_status']["MOBILE"].CRE
		--if ( tonumber(Sim1c) == 0xffffffff ) then Sim1c = 0 end
	    infoString = "Operator: "..KSENIAData['ksenia']['lares_status']["MOBILE"].CARRIER
		infoString = infoString .. "\n Credit SIM 1: " .. Sim1c
	end
	
	if (info == "TEMP" and  KSENIAData['ksenia']['lares_status']["TEMP"] )then 
		local temp_outdoor = KSENIAData['ksenia']['lares_status']["TEMP"].OUT
		local temp_indoor = KSENIAData['ksenia']['lares_status']["TEMP"].IN
	    infoString = "Temperature  Outdoor is: " .. temp_outdoor
		infoString = infoString .."\n" .. " Indoor is: " .. temp_indoor
	end

	kwLogTrace(6, "#ExtraInfo #UI"," sendExtraInfo : "..infoString)
	DisplayPartitionText(PartID, infoString)
	local timeLife = 5
	if sendExtraInfoTimer == nil then 	sendExtraInfoTimer = c4_timer:new("sendExtraInfoTimer", 15, "SECONDS", sendExtraInfoTimerExpired, false, CallbackParam) end
	sendExtraInfoTimer:StartTimerToAPartition(timeLife, PartID)
end

-- StartTmpTroubleCondition Messaggio di trouble temporaneo
function StartTmpTroubleCondition(troubleMsg,troubleDuration)
	StartTroubleCondition(troubleMsg)
	-- se  0 il timer ha durata infinita (il msg non viene cancellato)
	if troubleDuration ~= 0 then troubleClearTimer:StartTimer(troubleDuration) end
end


function UI_REQ.PARTITION_DISARM(tParams)
	kwLogTrace(6, "#UI_REQ #UI"," UI_REQ.PARTITION_DISARM for Apple PIN")
	appleAskPin()
end

function UI_REQ.PARTITION_ARM(tParams)
	kwLogTrace(6, "#UI_REQ #UI"," UI_REQ.PARTITION_ARM for Apple PIN")
	appleAskPin()
end

function UI_REQ.KEY_PRESS(tParams)
	local KeyName = tParams["KeyName"]
	local InterfaceID = tParams["InterfaceID"] or ""
	-- TODO in case of Apple...
end

function appleAskPin()
	for i = 1,20 do
		SetCodeRequiredToArm(i, true)
	end
end end)
package.preload['ksenia_communicator'] = (function (...)
--[[=============================================================================
    Template code for a Security Panel/Partition serial driver

    Copyright 2015 Control4 Corporation. All Rights Reserved.
===============================================================================]]
require "device_messages"
require "connections"
require "ksenia_ui_manager"

if (TEMPLATE_VERSION ~= nil) then
	TEMPLATE_VERSION.sectemplate_communicator = "2015.07.07"
end

AF_KEYPAD = "KEYPAD" -- KEYPAD (if a keycode is needed)
AF_BYPASS = "BYPASS" -- BYPASS (if a bypass is needed)
AF_NA = "NA"         -- NA (general failure).


--[[=============================================================================
    Interface routines required by the SecurityPanel code
===============================================================================]]

--[[=============================================================================
    Re-read information from the panel hardware about partitions and zones
===============================================================================]]
function SecCom_ReadPanelInfo()
	-- template
	-- local SerCmdStr = "*"
	-- -- TODO: Fill in SerCmdStr with the command to query the security panel
	-- SendCommand(SerCmdStr)
	kwLogTrace(3, "#KseniaConf", "ksenia_communicator.lua > SecCom_ReadPanelInfo > readKseniaConf()")
	LogTrace("ksenia_communicator.lua > SecCom_ReadPanelInfo > readKseniaConf()")
	-- sto chiedendo l'aggiornamento da ksenia tramite il bottone "Read Panel" in composer, quindi 
	-- voglio ri-associare zone e partizioni... svuoto la persist
	-- PersistData['ksenia']['ZoneToPartition'] = {}
	checkLicense(license_code)
	readKseniaConf()
end

--[[=============================================================================
    Input from an acknowledgement required has been given so the driver can now
    process that input so the panel can move into a DISARMER_READY state.
===============================================================================]]
function SecCom_SendAcknowledgement(PartitionIndex, Input, InterfaceID)
	local SerCmdStr = ""
	
	kwLogTrace(3, "#unsupported", "This feature is not supported by driver")
end

--[[=============================================================================
    Convert the given date/time parameters into the format required by the security panel
===============================================================================]]
function SecCom_SendDateAndTime(TargYear, TargMonth, TargDay, TargHour, TargMinute, TargSecond, InterfaceID)
	local SerCmdStr = ""
	
	kwLogTrace(3, "#unsupported", "This feature is not supported by driver")

end

--[[=============================================================================
    Convert the given zone parameters into the format required by the panel
===============================================================================]]
function SecCom_SendSetZoneInfo(ZoneID, ZoneName, ZoneType, InterfaceID)
	local SerCmdStr = ""
	
	-- kwLogTrace(3, "#Partition", "This feature is not supported by driver, change zone name with Ksenia")
  
  end
  
  --[[=============================================================================
	  Tell the panel to activate or de-activate a specific partition
	
	Note:  Not all panels will allow this
  ===============================================================================]]
  function SecCom_SendPartitionEnabled(PartitionIndex, IsEnabled, InterfaceID)
	local SerCmdStr = ""
	kwLogTrace(3, "#Partition", "Partition hide only in C4 (for real disable use Ksenia webserver)")
		-- in questo modo C4 effettua enable e disable ... ma quando fa enable deve aggiornare lo stato
	-- assumento che il real time di ksenia sia in ogni caso aggiornato basta fare un setPartition status
	SetPartitionEnabled(PartitionIndex, IsEnabled)
	-- if IsEnabled then setPartitionStatus(PartitionIndex) end
	--  se entro qui dentro  perch da Composer qualcuno ha cambiao l'Enable  della partizione e quindi lo memorizzo
	if (PersistData['ksenia']['PARTITIONSDisable'] == nil) then PersistData['ksenia']['PARTITIONSDisable'] = {} end
	local tIndex = tableIndexByVal(PersistData['ksenia']['PARTITIONSDisable'],PartitionIndex)
	if IsEnable == false then -- se viene disabilitata memorizzo
		if  tIndex == nil then
			table.insert(PersistData['ksenia']['PARTITIONSDisable'], PartitionIndex)
		else
			PersistData['ksenia']['PARTITIONSDisable'][tIndex] = PartitionIndex
		end
	else -- se viene abilitata cancello il contenuto della persist
		if  tIndex ~= nil then
			PersistData['ksenia']['PARTITIONSDisable'][tIndex] = nil
			setPartitionStatus(PartitionIndex)
		end
		-- se non rimane nessun elemento in tabella la cancello 
		if tableLength(PersistData['ksenia']['PARTITIONSDisable']) == 0 then
			PersistData['ksenia']['PARTITIONSDisable'] = nil
		end
	end
end

--[[=============================================================================
    Interface routines required by the SecurityParition code
===============================================================================]]
--[[=============================================================================
    Convert the given arm parameters into the format required by the panel
===============================================================================]]
function SecCom_SendArmPartition(PartitionIndex, ArmType, UserCode, Bypass, InterfaceID)
	local SerCmdStr = ""
    kwLogTrace(6, "#pin #arm #partition", "SecCom_SendArmPartition %s, %s, %s, %s, %s"
					,tostring(PartitionIndex)
					,tostring(ArmType)
					,tostring(UserCode)
					,tostring(Bypass)
					,tostring(InterfaceID))
					
	LogTrace("UserCode %s",tostring(UserCode))
	if (UserCode == nil or UserCode == "") then  -- aggiunto or per interfaccia myHome 
		UserCode = MemorizedPIN
	end
	
	local NarmType = removeSpecialChars(ArmType)

	kwLogTrace(6,"#pin #arm #partition", "Check Bypass")
	for index,zs in pairs(KSENIAData['ksenia']['zones']) do
		kwLogTrace(6,"#pin #arm #partition", "Check zone status")
	    if zs.STA == "ALARM" then
			if  Bypass == nil or Bypass == false then
				kwLogTrace(6,"#pin #arm #partition", "Requesting bypass")
				resetBypassZones( PartitionIndex )
				ArmPartitionFailed(PartitionIndex, AF_BYPASS, InterfaceID)
				return
			elseif Bypass == true then
				kwLogTrace(6, "#pin #arm #partition","ByPassing Zone: "..tostring( zs.DES ) .. " state " .. tostring( zs.STA ))
				autoBypassZone(PartitionIndex, index)
			else
				kwLogTrace(6,"#pin #arm #partition", "invalid bypass state")
			end
		end	
	end

	if (NarmType == C4_BUTTON["ARM"]) then 
		kwLogTrace(6, "#pin #arm #partition", "SecCom_SendArmPartition > ARM")
		managePin("ButtonScenario", UserCode, NarmType, PartitionIndex,  Bypass, InterfaceID)
	elseif (NarmType == C4_BUTTON["HOME"]) then 
		kwLogTrace(6, "#pin #arm #partition", "SecCom_SendArmPartition > HOME")
		managePin("ButtonScenario", UserCode, NarmType, PartitionIndex,  Bypass, InterfaceID)
	elseif (NarmType == C4_BUTTON["AWAY"]) then 
		kwLogTrace(6, "#pin #arm #partition", "SecCom_SendArmPartition > AWAY")
		managePin("ButtonScenario", UserCode, NarmType, PartitionIndex,  Bypass, InterfaceID)
	elseif (NarmType == C4_BUTTON["STAY"]) then 
		kwLogTrace(6, "#pin #arm #partition", "SecCom_SendArmPartition > STAY")
		managePin("ButtonScenario", UserCode, NarmType, PartitionIndex,  Bypass, InterfaceID)
	end


end


function SecCom_GetPersistBypassData( )
  kwLogTrace(6,"#pin #arm #partition", "SecCom_GetPersistBypassData")
  getPersistBypassData()
end

--[[=============================================================================
    Convert the given disarm parameters into the format required by the panel
===============================================================================]]
function SecCom_SendDisarmPartition(PartitionIndex, UserCode, InterfaceID)
	local SerCmdStr = ""
	-- managePin(PartitionIndex, "3" , UserCode, Bypass, InterfaceID)
	-- managePin(ksFun, ksID, UserCod, value, PartID, Bypas, IntfcID)
	--managePin("Partition",PartitionIndex-1,  UserCode, 3, PartitionIndex,  Bypass, InterfaceID)
	--managePin("Partition",PartitionIndex,  UserCode, "D", PartitionIndex,  Bypass, InterfaceID)
	managePin("Disarm", UserCode, "D", PartitionIndex,  Bypass, InterfaceID)
end

--[[=============================================================================
    Cancel a pending ARM command
===============================================================================]]
function SecCom_ArmCancel(PartitionIndex, InterfaceID)
	local SerCmdStr = ""
	-- OKIO non so quando si verifica ma se capita io disarmo
	SecCom_SendDisarmPartition(PartitionIndex, nil, InterfaceID)

end

--[[=============================================================================
    Convert the given emergency parameters into the format required by the panel
===============================================================================]]
function SecCom_SendExecuteEmergency(PartitionIndex, EmergencyType, InterfaceID)
	local SerCmdStr = ""
	local isFind = false
	local data = os.date("%d/%m/%Y %X")
	if Properties[KS_PROP["PANIC"..PartitionIndex]] ~= "read Ksenia Conf for list..." then
		kwLogTrace(6, "#panic #emergency", "SecCom_SendExecuteEmergency")
		HaveEmergency(data)
		kwLogTrace(3, "#panic #emergency","SecCom_SendExecuteEmergency", data)
		for s, scen in pairs(KSENIAData['ksenia']['scenarios']) do
			kwLogTrace(3, "#panic #emergency","SecCom_SendExecuteEmergency", s,scen)
			if Properties[KS_PROP["PANIC"..PartitionIndex]] == scen.name then
				kwLogTrace(3, "#panic #emergency","SecCom_SendExecuteEmergency", Properties[KS_PROP["PANIC"..PartitionIndex]])
				
				actions.exeM2Mcommand(socket_type.installer, "SCENARIO",  cmd, s)
				--local UserCod = Properties[KS_PROP["C4_PWD"]]
				--actions.openCmdSocket(UserCod, socket_type.scenario, s, value)

				local PanicString = "Activated "..KSENIAData['ksenia']['scenarios'][s].name
				DisplayPartitionText(PartitionIndex, PanicString)
				local timeLife = 5

				if sendExtraInfoTimer == nil then 	sendExtraInfoTimer = c4_timer:new("sendExtraInfoTimer", 15, "SECONDS", sendExtraInfoTimerExpired, false, CallbackParam) end
				sendExtraInfoTimer:StartTimerToAPartition(timeLife, PartitionIndex)
				
				isFind = true
				break
			end
		end
	else
		isFind = false
	end
	
	if (isFind == false) then
		StartTmpTroubleCondition("No Panic Scenario selected", messageValidityTime)
		kwLogTrace(0, "#panic #trouble #emergency", "SecCom_SendExecuteEmergency > No Panic Scenario selected")
	end
end

--[[=============================================================================
    Send a single key press from the UI keypad to the hardware
===============================================================================]]
function SecCom_SendKeyPress(PartitionIndex, KeyValue, InterfaceID)
	kwLogTrace(0, "#key #scenario #UI", "SecCom_SendKeyPress: "..(PartitionIndex or "NO PartitionIndex").." - "..(KeyValue or "NO KeyValue").." - "..(InterfaceID or "NO InterfaceID"))

	--local SerCmdStr = ""
	local SerCmdStr = KeyValue
	
	-- verifica se ho premuto un numero o un tasto
	if (tonumber(KeyValue) ~= nil) then
		-- gestione lettura PIN
		Send2UI(PartitionIndex, "*", KeyValue, InterfaceID)
	else
		-- gestione lista Scenari
		if selectedScenario == nil then selectedScenario = -1 end
		selectedScenario = DisplayScenarioList(KeyValue,PartitionIndex, InterfaceID)
	end
	-- gestione scenari da tastiera
	-- scenario
	-- TODO: Fill in SerCmdStr with the command to indicate that a single key was pressed on the keypad
	-- SendCommand(SerCmdStr)
end


--[[=============================================================================
    Process additional info that was requested from one of the partition UIs
===============================================================================]]
function SecCom_ProcessAdditionalInfo(PartitionIndex, InfoString, NewInfo, FunctionName, InterfaceID)
	kwLogTrace(0, "#panic #additional #info", "SecCom_ProcessAdditionalInfo: "..(PartitionIndex or "NO PartitionIndex").." - "..(InfoString or "NO InfoString").." - "..(NewInfo or "NO NewInfo").." - "..(FunctionName or "NO FunctionName").." - "..(InterfaceID or "NO InterfaceID"))

	-- TODO: Inspect the FunctionName variable to determine which routine should be called
	--       from here; usually this would be to complete the action that required additional
	--       info to be completed
	--managePin(FunctionName,PartitionIndex-1,  NewInfo, InfoString, PartitionIndex,  nil, InterfaceID)
	managePin(FunctionName, NewInfo, InfoString, PartitionIndex,  nil, InterfaceID)
	--if(FunctionName == "Function1Handler") then Function1Handler(PartitionIndex, InfoString, NewInfo, InterfaceID)
	--else if(FunctionName == "Function2Handler") then Function2Handler(PartitionIndex, InfoString, NewInfo, InterfaceID)
	--else
		LogWarn("Unhandled Additional Info Function: >>>%s<<<  Info: >>%s<<  New Info >>%s<<", FunctionName, InfoString, NewInfo)
	--end
end


--[[=============================================================================
    Process additional info that was requested from the panel UI
===============================================================================]]
function SecCom_ProcessAdditionalPanelInfo(InfoString, NewInfo, FunctionName, InterfaceID)
	-- TODO: Inspect the FunctionName variable to determine which routine should be called
	--       from here; usually this would be to complete the action that required additional
	--       info to be completed

	--if(FunctionName == "PanelFunction1Handler") then PanelFunction1Handler(PartitionIndex, InfoString, NewInfo, InterfaceID)
	--else if(FunctionName == "PanelFunction2Handler") then PanelFunction2Handler(PartitionIndex, InfoString, NewInfo, InterfaceID)
	--else
		LogWarn("Unhandled Panel Additional Info Function: >>>%s<<<  Info: >>%s<<  New Info >>%s<<", FunctionName, InfoString, NewInfo)
	--end
end

--[[=============================================================================
    Received a Confirmation command
===============================================================================]]
function SecCom_SendConfirmation(PartitionIndex, InterfaceID)
--	LogTrace("SecCom_SendConfirmation for Partition %d  InterfaceID: %s", tonumber(PartitionIndex), InterfaceID)
	kwLogTrace(3, "#unsupported #pgm", "SendConfirmation: This feature is not supported by driver")
end

--[[=============================================================================
    The following functions are called from the PgmInfo code 
===============================================================================]]
--[[=============================================================================
	Send the open control command to the specified zone
===============================================================================]]
function SecCom_SendPgmControlOpen(PgmID)
	local SerCmdStr = ""

	kwLogTrace(3, "#unsupported #pgm", "SendPgmControlOpen: This feature is not supported by driver on PGM:"..PgmID)
end

--[[=============================================================================
    Send the closed control command to the specified pgm
===============================================================================]]
function SecCom_SendPgmControlClose(PgmID)
	local SerCmdStr = ""

	kwLogTrace(3, "#unsupported #pgm", "SendPgmControlClose: This feature is not supported by driver on PGM:"..PgmID)
end

--[[=============================================================================
    Send the control command to toggle the current state of the specified pgm
===============================================================================]]
function SecCom_SendPgmControlToggle(PgmID)
	local SerCmdStr = ""

	kwLogTrace(3, "#unsupported #pgm", "SendPgmControlToggle: This feature is not supported by driver on PGM:"..PgmID)
end
 end)
package.preload['ksenia_general_manager'] = (function (...)
--require "wssocket"
--require "utility"  



function KsGetProperty(sProperty) --OKIO su driver update passa di qui ma non dalla KsCom:DispatchMessage(MsgKey, MsgData) ... ergo non si mette ONLINE
	--get property from composer
	--local propertyValue = Properties[sProperty]
	kwLogTrace(6, "#Properties ","KsGetProperty(" .. sProperty .. ") changed to: " .. Properties[sProperty])
	
	
	if (sProperty == "Log Level") then
		if (tonumber(string.sub(Properties['Log Level'] or "", 1, 1))) == 6 then
			C4:SetPropertyAttribs(KS_PROP["TAGS"], 0)
		else
			C4:SetPropertyAttribs(KS_PROP["TAGS"], 1)
		end
	end
	if (sProperty == KS_PROP["TAGS"]) then
		kwLogTrace(3, "#Properties ", "Tags changed")
    end
	if (sProperty == KS_PROP["LICENSE"]) then
		license_code = Properties[sProperty]
		checkLicense(license_code)
    end
end

function ON_DRIVER_LATEINIT.ksenia()
	for k,v in pairs(Properties) do
		OnPropertyChanged(k)
	end
	--C4:SetPropertyAttribs(KS_PROP["PORT"], 1)
	--C4:SetPropertyAttribs(KS_PROP["PROTOCOL"], 1)
	IsConnectionPropertySetted()
	local msg = "Driver restarted, read from panel in 120 secs"
	C4:UpdateProperty(KS_PROP["LAST_UPDATE"], msg)
	readFromPanelTimer:StartTimer(120)
end

function IsConnectionPropertySetted()
	if (Properties[KS_PROP["IP"]] ~= "192.168.x.x" and Properties[KS_PROP["INT_PWD"]] ~= "default" ) then
		CANCONNECT = true
		gNeedReadFromPanel = true 
		--readFromPanelTimer:StartTimer(3)
	else
        CANCONNECT = false
    end 
end 

--license
--MACisOK = false
function checkLicense(license)
	-- qui andr implementata la parte di codice per gestire le licenze, licenza, sicurezza
	license_code = license
	--C4:UpdateProperty(KS_PROP["LICENSE_STATUS"], 'Activating driver license...')
	C4:UpdateProperty(KS_PROP["DRIVER_VERSION"], C4:GetDriverConfigInfo ("version"))
	
	local mac = C4:GetUniqueMAC ()
	
end



--manage network comunication
function OnServerConnectionStatusChanged(nHandle, nPort, strStatus)
	--ISONLINE = true
	if (strStatus == "ONLINE") then
	--	ISONLINE = true
		kwLogTrace(6, "#socket #connection",'Server Connection Established: ' .. nHandle)
	else		
	--	ISONLINE = false
		kwLogTrace(6, "#socket #connection",'Server Connection Disconnected: ' .. nHandle)
    end
end
function OnServerDataIn(nHandle, strData)
    kwLogTrace(6, "#socket #connection",'OnServerDataIn > [' .. nHandle .. ']: ' .. strData)
end
function OnConnectionStatusChanged(idBinding, nPort, strStatus)
    kwLogTrace(6, "#socket #connection",'OnConnectionStatusChanged > Port: ' ..(nPort or " NO Port") ..' - Status: '..(strStatus or " NO Status").." - idBinding: " .. (idBinding or "NO BIND").." - "..(TypeOfSocket[idBinding] or "NO TypeOfSocket[idBinding]"))
	--DemoSocket[TypeOfSocket[idBinding]]:ConnectionChanged (strStatus)
	if (WebSock and WebSock.Sockets and WebSock.Sockets [idBinding]) then
		local ws = WebSock.Sockets [idBinding]
		HTTP_BINDING = idBinding
		ws:ConnectionChanged (strStatus)
	end
    
end
function ReceivedFromNetwork(idBinding, nPort, strData)
	if (WebSock and WebSock.Sockets and WebSock.Sockets [idBinding]) then
		local ws = WebSock.Sockets [idBinding]
		ws:ParsePacket (strData)
	end
end 

--read configuration
function readKseniaConf()
	kwLogTrace(6, "#socket #readKseniaConf",'readKseniaConf()')
	if CANCONNECT == true then
		C4:UpdateProperty(KS_PROP["LAST_UPDATE"], "reading Ksenia config...")
		
		resetWorkingTable()
		--TODO aggiungere timer di controllo ogni 2 minuti
		--togliere initTimer da ON_DRIVER_INIT.c4_common()
		--wstart_installer()
		for k,v in pairs(TypeOfSocket) do
			send_commands("LOGOUT", k)
			close_socket(v)
		end
		--IsConnectionPropertySetted()
		put_in_late_queue_labeled("SynchronizePanelInfo", SynchronizePanelInfo)
		put_in_late_queue_labeled("ReportPanelInitialized", ReportPanelInitialized)
		readFromPanelTimer:StartTimer(3)
	else
		kwLogTrace(3, "#socket #readKseniaConf","seems that not all parameter were setted")
	end
end 

function resetWorkingTable()
	-- fermo il Timer della coda prima di resettare la rispettiva tabella
	queue_processor_Timer:KillTimer()
	--cmds_c4_queue = nil    --svuota la tabella delle code
	if (cmds_c4_queue==nil) then
		cmds_c4_queue = Queue:new()
	else
		cmds_c4_queue:empty()
	end
	-- pulisco le tabelle dei messaggi letti, che verranno ricreate
	KSENIAData['GlobalData']['ksenia'] = {}
	KSENIAData['GlobalData']['config_received'] = {}
	KSENIAData['GlobalData']['readKseniaConf'] = true

	oldZones = {} --creo una tabella con le zone perch poi ricreo la table  KSENIAData['ksenia']['zones'] e dal diff con questa cancello le zone vecchie
	if KSENIAData['ksenia']['zones'] ~= nil then
		if table.getn(KSENIAData['ksenia']['zones']) ~= 0 then oldZones = KSENIAData['ksenia']['zones'] end
	end

    --pulisco la tabella di lavoro sui cui faccio le operazioni
 	KSENIAData['ksenia'] = {}

end


--                                $$\           $$\       $$\                     
--                                \__|          $$ |      $$ |                    
--  $$\    $$\ $$$$$$\   $$$$$$\  $$\  $$$$$$\  $$$$$$$\  $$ | $$$$$$\   $$$$$$$\ 
--  \$$\  $$  |\____$$\ $$  __$$\ $$ | \____$$\ $$  __$$\ $$ |$$  __$$\ $$  _____|
--   \$$\$$  / $$$$$$$ |$$ |  \__|$$ | $$$$$$$ |$$ |  $$ |$$ |$$$$$$$$ |\$$$$$$\  
--    \$$$  / $$  __$$ |$$ |      $$ |$$  __$$ |$$ |  $$ |$$ |$$   ____| \____$$\ 
--     \$  /  \$$$$$$$ |$$ |      $$ |\$$$$$$$ |$$$$$$$  |$$ |\$$$$$$$\ $$$$$$$  |
--      \_/    \_______|\__|      \__| \_______|\_______/ \__| \_______|\_______/ 
--                                                                           
--                                                                      
function OnVariableChanged(strName)
	kwLogTrace(6, "#variable","OnVariableChanged :"..strName)   --check lo volgio print?
	local NewValue = Variables[strName]
 	if string.find(strName,VARIABLE_NAME["ZoneBP"]) then --ByPass di zona
			-- send command to ksenia (l'update  automatico perch ho il tempo reale zona su IP da ksenia)
			updateVar("ByPassZ",strName,NewValue)
		elseif string.find(strName,VARIABLE_NAME["Out"]) then --variabile di output boolean
			updateVar("Output",strName,NewValue)
		elseif string.find(strName,VARIABLE_NAME["OutA"]) then --variabile di output analogico
			updateVar("OutputA",strName,NewValue)
		elseif string.find(strName,VARIABLE_NAME["ksTroubleText"]) then --variabile per trouble text
			--start trouble
			if NewValue == "" then 
				ClearTroubleCondition(1)
			else			
				StartTroubleCondition(NewValue)
			end
		else --non so di quale variabile si tratta oppure  readonly
			kwLogTrace(5, "","Error: Unknow Variable or Read Only Variable")
	end
end

function C4_SetVariable(name, value)
	--creata solo per poterla passare dentro al put_in_queue
	--perch col C4: davanti altrimenti mi da errore
	C4:SetVariable(name, tostring(value))
end

function updateVar(varType,varName,varValue)
	kwLogTrace(6, "#Variables #update ","updateVar "..tostring(varType).."-"..tostring(varName).."-"..tostring(varValue))
	--local tmpPin = KSENIAData['ksenia']['basis_info'][1].PINToUse
	if varType == "ByPassZ" then
		-- trovo la variabile in zones
		local ZonName = string.sub(varName,(string.len(VARIABLE_NAME["ZoneBP"])+1))
		for index,zon in pairs(KSENIAData['ksenia']['zones']) do
		    if zon.DES ==  ZonName then
			--actions.openCmdSocket(TMP_USER_PIN, socket_type.bypass, index, tonumber(varValue))
				actions.exeM2Mcommand(socket_type.installer, "BYPASS",  tonumber(varValue), index)
			end
		end
	elseif varType == "Output" then
		local OutName = string.sub(varName,(string.len(VARIABLE_NAME["Out"])+1))
		for index, out in pairs(KSENIAData['ksenia']['outputs']) do
			if out.DES == OutName then	
				local statePRX = ""		
				if varValue == false or tonumber(varValue) == 0 then 
					varValue = "OFF"
					statePRX = "OPENED"
				elseif varValue == true or tonumber(varValue) == 1 then 
					varValue = "ON"
					statePRX = "CLOSED"
				elseif varValue == "TOGGLE" or tonumber(varValue) == 2 then 
					local oldval = KSENIAData['ksenia']['outputs'][index].STA
					if oldval == "OFF" then
						varValue = "TGL" 
						statePRX = "CLOSED"
					elseif oldval == "ON" then
						varValue = "TGL"
						statePRX = "OPENED"
					end
				end 
				KSENIAData['ksenia']['outputs'][index].STA = varValue
				--actions.openCmdSocket(TMP_USER_PIN, socket_type.output, index, varValue)
				--OUTPUT C4:SendToProxy(out.contacts, statePRX,  "", "NOTIFY")
				outValue = KSENIAData['ksenia']['outputs'][index].STA
				actions.exeM2Mcommand(socket_type.installer, "OUTPUT",  outValue, index)
			end
		end
	else
	kwLogTrace(6, "#Variables #unknow ","Error: Unknow Variable Type")
	end
end

function table_insert_if_missing(tbl, value)
	local flag = false
	for k,v in ipairs(tbl) do
		if value == v then 
			flag = true
			break
		end
	end
	if flag == false then 
		table.insert(tbl, value)
	end
end

			

function ksAddVariable(name,value,tipo,rw)
    kwLogTrace(6, "#Variables #unknow ","Set/Add Variable: "..name)
	local isNewVar = false
	if (KSENIAData['ksenia']['variables'] == nil) then KSENIAData['ksenia']['variables'] = {} end
		table_insert_if_missing(KSENIAData['ksenia']['variables'], name)
    --table.insert(KSENIAData['ksenia']['variables'], name) -- devo ri-registrare che in ksenia c'
    if rw == 0 then rw = false else rw = true end -- gestione readonly
	if findVarByName(name) == nil then isNewVar = true end 
	if isNewVar then
	   local id = try_add_variable(name,value,tipo,rw,0)
		if id ~= nil then
		  PersistRestoreVar(id,name,value,tipo,rw)
		  kwLogTrace(6, "#Variables #unknow ","ksenia_variables_updater  >> ksAddVariable id."..id)
		end 
	else  -- c' gi imposto senza creare
		C4:SetVariable(name,tostring(value))
	end
end


function findVarByName(varName)
	for i,var in pairs(PersistData['ksenia']['VARrestore']) do
		if (var.name == varName) then return i end  -- in questo modo il for si ferma alla prima occorrenza
	end
end

function try_add_variable(name,value,tipo,rw,counter)
   LogError('try_add_variable: '..name.." - COUNTER ".. counter.." - value "..value.." - tipo ".. tipo.." - rw "..tostring(rw)..type(rw))
   if counter == nil then counter = 0 end
    if counter>10 then -- OKIO problema addvar da verificare
	   kwLogTrace(6, "#Variables #unknow ",'Fatal error on add variable')
	   return -- evidentemente non ci riesce
    end
   local result, idVar = C4:AddVariable(name,value,tipo,rw, false)
   kwLogTrace(5, "",counter.." - AddVariable: "..name.." - result: "..tostring(result).." - idVar: "..tostring(idVar))
    if (idVar) then
		kwLogTrace(6, "#Variables #unknow ","AddVariable success")
		return idVar
    else
	   kwLogTrace(6, "#Variables #unknow ","AddVariable fail")
	   local t = C4:SetTimer(1000, function(timer) try_add_variable(name,value,tipo,rw,counter+1) end)
    end
end

---------------------------------------------------------------------
-- Funzioni di Pulizia Connections e Variable
---------------------------------------------------------------------
function confVarClean() -- rimuove le variabili orfane
    local variables = {}
	local contacts = {}
	local to_delete = {}
	-- variabili ... 
    for index,nome in pairs(KSENIAData['ksenia']['variables']) do 
	    variables[nome] = true;
    end

    for index,varT in pairs(PersistData['ksenia']['VARrestore']) do
	    if (not variables[varT.name]) then -- non c' tra le variabili di ksenia
			C4:DeleteVariable(varT.name)
			PersistDeletedVar(varT.name)
			kwLogTrace(6, "#Variables #unknow ","Delete: "..varT.name)
	    end
    end
	 -- Output   
    --carico ID contacts from output
    for index,out in pairs(KSENIAData['ksenia']['outputs']) do
	   contacts[out.contacts] = true
    end
	-- confronto con la persist
	for index, outP in pairs(PersistData['ksenia']['CONrestore']) do
		if (not contacts[outP.id]) then
			table_insert_if_missing(to_delete, outP.id)
			-- non uso table.remove perche' altrimenti l'index cambia valore!
			PersistData['ksenia']['CONrestore'][index]=nil
		end
	end
	-- elimino
   for i,IDcontact in pairs(to_delete) do
	   kwLogTrace(6, "#Variables #unknow ","Delete contact: "..IDcontact)
	   C4:RemoveDynamicBinding(IDcontact)
    end
	
end

function PersistDeletedVar(name)
  for index,Var in pairs(PersistData['ksenia']['VARrestore']) do
    if Var.name == name then
      PersistData['ksenia']['VARrestore'][index].deleted = true
    end
  end
end

 end)
package.preload['ksenia_status'] = (function (...)
--                                                    
--ZONE
--                                                       
local Queue = require "SKC4.Queue"
cmds_c4_queue = Queue:new()


function regenerateZone(a, b, isUpdate)
	--rigenera le zone andando a vedere tutte le zone che hanno un nome
	--quindi le crea con un C4:AddDynamicBinding
	
    kwLogTrace(6, "#Status #Zone #Variables #KseniaConf"," - regenerateZone")
    if KSENIAData['ksenia']['zones'] == nil then  KSENIAData['ksenia']['zones'] = {} end

    local f = {}
    f = a--KSENIAData['GlobalData']['ksenia']["STATUS_ZONES"]
    local s = {}
    s = b--KSENIAData['GlobalData']['ksenia']["ZONES"]
    --KSENIAData['ksenia']['zones'] = merge_two_table_by_id(f,s)
    local zones = {}
	zones = merge_two_table_by_id(f,s)-- KSENIAData['ksenia']['zones']
	setZonesTable(zones, isUpdate)
	if isUpdate == false then 
		if oldZones == nil then oldZones= {} end
		put_in_queue(removeOldZone, {KSENIAData['ksenia']['zones'], oldZones})
	end
end

function setZonesTable(zones, isUpdate)
	for index,zs in pairs(zones) do --ciclo sulle zone
		local des = zs.DES or ""
		local sta = KSC4_ZONE.STA[zs.STA] or ""
		local id = tonumber(zs.ID) or ""
		local byp = KSC4_ZONE.BYP[zs.BYP] or ""
		local zone_name = des
		if (des == "" or des == nil) then
			kwLogTrace(3, "#Status #Zone #Variables #KseniaConf", "The zone is without name.... giving default ones")
			zone_name = "zone ".. id
		end
		local tmp = {
			ID =  id,
			DES = zone_name,
			AST = ast,
			BYP = byp,
			STA = sta
		}
		--to check se va bene rasarla oppure  meglio fare un update solo di alcuni valori
		if KSENIAData['ksenia']['zones'][id] == nil then KSENIAData['ksenia']['zones'][id] = {} end
		for k,v in pairs(tmp) do
			KSENIAData['ksenia']['zones'][id][k] = v
		end
		--KSENIAData['ksenia']['zones'][id] = {}
		put_in_queue(SetZoneInfo, {id,zone_name,1,1})
		-- aggiunge variabili
		if (isUpdate == false) then createZonesVariables(zone_name, sta, id) end
		local boolByPass	
		if byp ~= KSC4_ZONE.BYP.NO then boolByPass = true --in bypass
		else boolByPass = false end                  --not in bypass
		--variabile bypass zona
		put_in_queue(ksAddVariable,{VARIABLE_NAME["ZoneBP"].. zone_name,tostring(boolByPass),"BOOL",0})  
		--insert in Tabella stati ksenia
		--KSENIAData['ksenia']['zones'][tonumber(id)] = tmp
		put_in_queue(setZoneStatus, {id, true})
		
	end
end
function createZonesVariables(zone_name, sta, id)
	put_in_queue(ksAddVariable,{VARIABLE_NAME["Zone"].. zone_name,sta,"STRING",1})
	-----------------------------------------------------
	--mettere qualcosa per le zone analogiche  ANALOG
	-----------------------------------------------------
	put_in_queue(ksAddVariable,{VARIABLE_NAME["ZoneName"].. zone_name,zone_name,"STRING",1})
end
function setZoneStatus(zoneID, Initializing)
    ID = tonumber(zoneID)
	local state = KSENIAData['ksenia']['zones'][ID].STA
	local zone_nr = KSENIAData['ksenia']['zones'][ID].ID
	local bypass = KSENIAData['ksenia']['zones'][ID].BYP
    local name = KSENIAData['ksenia']['zones'][ID].DES
	local VarName = VARIABLE_NAME["Zone"]..name
	local partID = KSENIAData['ksenia']['zones'][ID].PART
	-- quando faccio il regenerate sono in inizializzazione
	local JustInitializing = Initializing or false
    -- By Pass
	local boolByPass	
	if (bypass ~= KSC4_ZONE.BYP.NO) then -- "BYPASS"
		boolByPass = true
		state = KSC4_ZONE.STA.R-- ZONE.STA.R  -- OKIO la zona ByPassata  sempre NORMAL >> CLOSED (non la variabile)
	elseif (bypass == KSC4_ZONE.BYP.NO) then --"UN_BYPASS"
		boolByPass = false
	else
		kwLogTrace(6, "#unknow #Zone #Status","ERROR: ByPass Sconosciuto: "..bypass)
	end
	if (state == KSC4_ZONE.STA.A or state == KSC4_ZONE.STA.T or state == KSC4_ZONE.STA.FM) then  --ALARM, TAMPER, MASK >> OPEN
		-- aggiorno stato su composer
		SetZoneState(zone_nr,true, JustInitializing) -- TEMPLATE
		 -- aggiorno variabile per programming
		put_in_queue(C4_SetVariable,{tostring(VarName), state})
		if IsPartitionArmed(partID) then 
			LastZoneAlarmed = name
			updateAlarmVariableAndTrouble(partID)
		end 
	elseif (state  ==  KSC4_ZONE.STA.R) then -- NORMAL >> CLOSED
		-- aggiorno stato su composer
		SetZoneState(zone_nr,false, JustInitializing)
		 -- aggiorno variabile per programming
		put_in_queue(C4_SetVariable, {tostring(VarName), state}) 
    
	else
		kwLogTrace(6, "#unknow #Zone #Status","ERROR: Unknow State: "..state)
	end
	--set BYPASS variable
	put_in_queue(SetZoneBypassState, {zone_nr, boolByPass})
	put_in_queue(C4_SetVariable, {VARIABLE_NAME["ZoneBP"]..name,(boolByPass and 1 or 0)})
end

function updateAlarmVariableAndTrouble(part)
	if  KSC4_PARTITION[KSENIAData['ksenia']['partitions'][part].AST] ~= nil then
		local status = KSC4_PARTITION[KSENIAData['ksenia']['partitions'][part].AST] 
		local LastAlarmMessage = KSENIAData['ksenia']['partitions'][part].DES .. " is " ..(KSC4_PARTITION[KSENIAData['ksenia']['partitions'][part].AST] or "no state").."\n on zone: "..(LastZoneAlarmed or "")
		StartTroubleCondition(LastAlarmMessage, messageValidityTime) 
		if LastZoneAlarmed  ~= nil then 
			put_in_queue(C4_SetVariable, {VARIABLE_NAME["LastZoneAlarm"],LastZoneAlarmed})
			put_in_queue(C4_SetVariable, {VARIABLE_NAME["LastAlarmMessage"],LastAlarmMessage})
		end
	end 
end

function removeOldZone(newZTable, oldZTable)

	local tmpZTable = {} 
	for o, oZ in pairs(oldZTable) do
		for n, nZ in pairs(newZTable) do 
			if oZ.ID == nZ.ID then 
				tmpZTable[o] = true
				if oZ.partition ~= nZ.partition then put_in_queue(RemoveZoneFromPartition,{oZ.partition, oZ.ID}) end
			elseif tmpZTable[o] == nil then tmpZTable[o] = false end
		end
	end
	for t, tZ in pairs(tmpZTable) do
		if tZ == false then put_in_queue(RemoveZone, {oldZTable[t].ID})
		end
	end
	-- oldZone = nil
end
--                                                    
--PARTITION
--                                                       

function regeneratePartition(a, b, isUpdate)
	--local data = os.date("%d/%m/%Y %X")
    kwLogTrace(6, "#Status #Partition #Variables #KseniaConf","regeneratePartition(partition_names, partition_states)")
	KSENIAData['ksenia']['partitions'] = {}

    local f = {}
    f = a
    local s = {}
    s = b
    local partitions = {}
	partitions = merge_two_table_by_id(f,s)
	if isUpdate == false then 
		-- aggiungo variabile globale per maschera partizioni
		put_in_queue(ksAddVariable, {VARIABLE_NAME["PartitionMask"],"","STRING",1})
		-- aggiungo variabili globali per cambio stato ksenia - OKIO al carico su controller Demo
		put_in_queue(ksAddVariable, {VARIABLE_NAME["LastZoneAlarm"],"","STRING",1})
		put_in_queue(ksAddVariable, {VARIABLE_NAME["LastAlarmMessage"],"","STRING",1})
		put_in_queue(ksAddVariable, {VARIABLE_NAME["PartitionChanged"],"","STRING",1})
		put_in_queue(ksAddVariable, {VARIABLE_NAME["ksTroubleText"],"","STRING",0})
		put_in_queue(ksAddVariable, {VARIABLE_NAME["TemperatureIn"],"","STRING",0})
		put_in_queue(ksAddVariable, {VARIABLE_NAME["TemperatureOut"],"","STRING",0})
		put_in_queue(ksAddVariable, {VARIABLE_NAME["TemperatureInNumeric"],"","NUMBER",0})
		put_in_queue(ksAddVariable, {VARIABLE_NAME["TemperatureOutNumeric"],"","NUMBER",0})
		put_in_queue(ksAddVariable, {VARIABLE_NAME["SimSignal"],"","STRING",0})
		put_in_queue(ksAddVariable, {VARIABLE_NAME["GSM_OPERATOR"],"","STRING",0})
		put_in_queue(ksAddVariable, {VARIABLE_NAME["Sim1_CREDIT"],0,"NUMBER",0})
	end 
	local max_index = 0 
	max_index = setPartitionsTable(partitions, isUpdate)

	if isUpdate == false then PersistData['ksenia']['PARTITIONSDisable'] = nil end

	if isUpdate == false then 
		if (max_index ~= 0) then 
			for i = max_index +1, PARTITION_ID_MAX do
				put_in_queue(SetPartitionEnabled, {i, "False"})
			end
		end
	else
		if tableLength(PersistData['ksenia']['PARTITIONSDisable']) ~= 0 then
      		for i,p in pairs(PersistData['ksenia']['PARTITIONSDisable']) do
        		put_in_queue(SetPartitionEnabled, {p, "False"})
			end
		end
    end
end

function setPartitionsTable(partitions, isUpdate)
	local max_index = 0 
	for index,ps in pairs(partitions) do --ciclo sulle partitions
        local des = ps.DES or ""
        local ast = ps.AST or ""
        local arm = KSC4_PARTITION[ps.ARM] or ""
		local id = tonumber(ps.ID) or ""
        local time = ps.T or ""
        local partition_name = des
        if (des == "" or des == nil) then
					kwLogTrace(3, "#Status #Zone #Variables #KseniaConf","The partition is without name.... giving default ones")
            partition_name = "partition ".. id  
		end
		local tmp = {
			ID =  id,
			DES = partition_name,
			AST = ast,
			ARM = arm
		}
		KSENIAData['ksenia']['partitions'][id] = {}
		KSENIAData['ksenia']['partitions'][id] = tmp
		
		if (isUpdate == false) then createPartitionsVariables(partition_name, arm, id) end
		if (isUpdate == false) then put_in_queue(SetPartitionEnabled,{id, "True"}) end
		setPartitionStatus(id)
		
		if id >= max_index then max_index = id end
	end
	return max_index
end

function createPartitionsVariables(partition_name, arm, id)
		-- creo le variabili per le partizioni
		put_in_queue(ksAddVariable, {VARIABLE_NAME["Partition"].. partition_name,arm,"STRING",1})
     	-- aggiungo variabile con nomi di zona 
		put_in_queue(ksAddVariable, {VARIABLE_NAME["PartitionName"].. partition_name,partition_name,"STRING",1})
		put_in_queue(kwLogTrace, {6, "#Status #Partition #Variables #KseniaConf"," - Partition: "..id .. ', ' .. partition_name .. ', ' .. arm})
end

function setPartitionStatus(partitionID)
	kwLogTrace(6, "#partition  #status","setPartitionStatus :"..partitionID)

    partitionID = tonumber(partitionID)
	kwLogTrace(6, "#unknow #Partition #Status","setPartitionStatus: "..partitionID.." - "..KSENIAData['ksenia']['partitions'][partitionID].DES)
	local status = KSENIAData['ksenia']['partitions'][partitionID].ARM
	local name = KSENIAData['ksenia']['partitions'][partitionID].DES
	--local TimeToPart = 0
	local stateType = status -- serve per le variabili pre-esistenti nel template
	local TimeOfPart = {}
    
	if KSENIAData['GlobalData']['ksenia']['PRG_PARTITIONS'] ~= nil then
		TimeOfPart.TIN = tonumber(KSENIAData['GlobalData']['ksenia']['PRG_PARTITIONS'][tostring(partitionID)].TIN)
		TimeOfPart.TOUT = tonumber(KSENIAData['GlobalData']['ksenia']['PRG_PARTITIONS'][tostring(partitionID)].TOUT)
		TimeOfPart.Tmax = math.max(TimeOfPart.TOUT, TimeOfPart.TIN)
	end

	updateAlarmVariableAndTrouble(partitionID)
	
	if  KSC4_PARTITION[KSENIAData['ksenia']['partitions'][partitionID].AST] ~= nil then
		status = KSC4_PARTITION[KSENIAData['ksenia']['partitions'][partitionID].AST] 
	end
	TimeOfPart.T = KSENIAData['ksenia']['partitions'][partitionID].T or TimeOfPart.Tmax
	SetPartitionState(partitionID, status, stateType, TimeOfPart.Tmax, TimeOfPart.T, false)	
	KSENIAData['ksenia']['partitions'][partitionID].T = nil
	-- cambio stato alla variabile
	local varName = VARIABLE_NAME["Partition"]..KSENIAData['ksenia']['partitions'][partitionID].DES
	put_in_queue(C4_SetVariable, {tostring(varName),status})
	-- cambio stato alla partition mask
	put_in_queue(updatePartitionMask)
	-- cambio variabile KS_STATUS_CHANGED - OKIO
	C4:SetVariable(VARIABLE_NAME["PartitionChanged"],name.." > "..status)
end

function updatePartitionMask()
	local partitionMask = ""
	
	for index,pt in pairs(KSENIAData['ksenia']['partitions']) do
		local decodeMask = 0
		if pt.ARM == AS_DISARMED_READY then decodeMask = 0
        elseif pt.ARM == AS_ARMED then decodeMask = 1
		elseif pt.ARM == AS_ALARM then decodeMask = 2
		elseif pt.ARM == AS_EXIT_DELAY then decodeMask = 3
		elseif pt.ARM == AS_ENTRY_DELAY then decodeMask = 4
		else
				decodeMask="X"
		end
		partitionMask = partitionMask..decodeMask
	end
	kwLogTrace(6, "#mask #Variables #Satus", "NewPartitionMask is: "..partitionMask)
	put_in_queue(C4_SetVariable, {VARIABLE_NAME["PartitionMask"],partitionMask})
end
--                                                    
--SCENARIO
--                                                       
function regenerateScenarios(tScenarios)
	kwLogTrace(6, "#Status #Scenario #Variables #KseniaConf","regenerateScenarios")
	KSENIAData['ksenia']['NotGenScenarios'] = {}
	KSENIAData['ksenia']['scenarios'] = {}
	local scenarioListStr = setScenariosTable(tScenarios)
	
	for i = 1,20 do
		local index = tostring( i )
		C4:UpdatePropertyList( KS_PROP["PANIC"..index], scenarioListStr ) 
		C4:UpdatePropertyList( KS_PROP["HOME"..index], scenarioListStr ) 
		C4:UpdatePropertyList( KS_PROP["AWAY"..index], scenarioListStr ) 
		C4:UpdatePropertyList( KS_PROP["STAY"..index], scenarioListStr ) 
		C4:UpdatePropertyList( KS_PROP["DISARM"..index], scenarioListStr )
		C4:UpdatePropertyList( KS_PROP["ARM"..index], scenarioListStr )
		C4:UpdatePropertyList( KS_PROP["CUSTOM_A"..index], scenarioListStr )
		C4:UpdatePropertyList( KS_PROP["CUSTOM_B"..index], scenarioListStr )
	end
	if tScenarioButton ~= nil then	
		for k, v in pairs(tScenarioButton) do
			if tScenarioButton[k] ~= nil and tScenarioButton[k] ~= "" then 
				C4:UpdateProperty(KS_PROP[k], "_!_")  --fix per far aggiornare le proprerty
				                            -- dopo che la macchina fa un read from panel
				C4:UpdateProperty(KS_PROP[k], v)
			end
		end
	end	
end

function setScenariosTable(tScenarios)
	local scenarioListStr	
	for index,zs in pairs(tScenarios) do 
		local id = tonumber(index)
		local tmp_scenario = {}
		tmp_scenario.name = zs.DES
		tmp_scenario.ksenia_number = id
		tmp_scenario.cat = zs.CAT
		local abil = zs.PIN
		if SCENARIOS_CONF[abil] ~= nil then tmp_scenario.abil = SCENARIOS_CONF[abil].abil end
		if SCENARIOS_CONF[abil] ~= nil then tmp_scenario.pin = SCENARIOS_CONF[abil].pin end

		KSENIAData['ksenia']['scenarios'][id] = {}
		KSENIAData['ksenia']['scenarios'][id] = tmp_scenario
	end
	for i, sz in pairs(KSENIAData['ksenia']['scenarios']) do
		--if sz.cat ~= "GEN" then
			-- table.insert(KSENIAData['ksenia']['NotGenScenarios'], i)
			KSENIAData['ksenia']['NotGenScenarios'][i] = i
			if scenarioListStr == nil then 
				scenarioListStr = "Arm,"..sz.name
			else
				scenarioListStr = scenarioListStr..","..sz.name
			end
		--end
	end
	return scenarioListStr..", "
end

function listScroll(PartitionID,indexIn,goUp)
	local indexOut
	local listElements = table.getn(KSENIAData['ksenia']['NotGenScenarios'])
	if goUp == true then
		if indexIn > 1 then indexOut = indexIn - 1 else indexOut = listElements end
	else
		if indexIn < listElements then indexOut = indexIn + 1 else indexOut = 1 end
	end
	
	local scenarioToDisplay = KSENIAData['ksenia']['scenarios'][KSENIAData['ksenia']['NotGenScenarios'][indexOut]].name
	DisplayPartitionText(PartitionID, scenarioToDisplay)
	return indexOut
end

function DisplayScenarioList(KeyValue,PartitionID,InterfaceID)
	if indexList == nil then indexList = 1 end

	if (KeyValue == "A" or KeyValue == "Up") then	-- UP -- or necessario per interfaccia 
		indexList = listScroll(PartitionID, indexList,true)
	
	elseif (KeyValue == "B" or KeyValue == "Ok") then -- OK  -- or necessario per interfaccia myHome
		if KSENIAData['ksenia']['scenarios'][indexList].pin == "FALSE" then
			actions.openCmdSocket(UserCod, socket_type.scenario, PartitionID, value)
			kwLogTrace(6, "#Scenario #partitionID #UI","DisplayScenarioLis on "..PartitionID)
			DisplayPartitionText(PartitionID, KSENIAData['ksenia']['scenarios'][KSENIAData['ksenia']['NotGenScenarios'][indexList]].name.." activated!")
		elseif (usercode  ~= nil and string.len(usercode) == 6) then -- ho gi inserito il codice di 6 cifre

			managePin("Scenario", MemorizedPIN, nil, selectedScenario,  nil, InterfaceID)
		else
			DisplayPartitionText(PartitionID, "Please insert PIN")
		end
		
	elseif (KeyValue == "C" or KeyValue == "Down") then -- DOWN -- or necessario per interfaccia myHome
		indexList = listScroll(PartitionID, indexList, false)
	elseif (KeyValue == "D" or KeyValue == "Esc") then -- ESC -- or necessario per interfaccia myHome
		usercode = nil
		blindedCode = nil
		MemorizedPIN = nil 
		indexList = nil
		DisplayPartitionText(PartitionID, "")  
		else
		kwLogTrace(6, "#Scenario #Unknow #UI","Unknow key pressed: "..KeyValue)
	end
	
	kwLogTrace(3, "#Scenario #UI","DisplayScenarioList\nindexList: "..indexList)
	return indexList
end

--                                                    
--OUTPUT
--                                                       

--function updateStatusOutput(output_names, output_states)
function regenerateOutput(a, b, isUpdate)
	kwLogTrace(6, "#unknow #Output #Status"," - update Output Status")
	
	KSENIAData['ksenia']['outputs'] = {}
	local f = {}
    f = a
    local s = {}
    s = b
    local outputs = {}
	outputs = merge_two_table_by_id(f,s)
	setOutputsTable(outputs, isUpdate)
end


function setOutputsTable(outputs, isUpdate)
	local firstOutID = 870 -- i precedenti sono occupati dalle zone
    for index,os in pairs(outputs) do --
	
		local id = tonumber(os.ID) or ""
		local des = os.DES or ""
        local cnv = os.CNV or ""
		local cat = os.CAT or ""
		local sta = os.STA or ""
		
		local output_name = des
        if (des == "" or des == nil) then
            output_name = "output ".. id  
		end
		local tmp = {
			ID =  id,
			DES = output_name,
			CNV = cnv,
			CAT = cat,
			STA = sta,
			contacts = id + firstOutID
		}
		KSENIAData['ksenia']['outputs'][id] = {}
		KSENIAData['ksenia']['outputs'][id] = tmp
		--put_in_queue(setOutStatus,id)
		
		if (tmp.CAT == "ROLL") then 
			kwLogTrace(6, "#ROLL #Output #Status","Auxi will operate on it")


		elseif(isUpdate == false) then
			C4:AddDynamicBinding(tmp.contacts, "CONTROL", true, output_name, "RELAY",false, false)
			put_in_queue(ksAddVariable, {VARIABLE_NAME["Out"].. output_name,tmp.STA,"BOOL",0})
		end
		PersistRestoreConn(tmp.contacts, "CONTROL", true, output_name, "RELAY", false, false)
		if (tmp.STA == "OFF") then
			C4:SendToProxy(tmp.contacts, "OPENED", "NOTIFY")
		else
			C4:SendToProxy(tmp.contacts, "CLOSED", "NOTIFY")
		end
		
	end
end
function setOutStatus(OutID, Initializing)
	kwLogTrace(6, "#unknow #Output #Status","set Out Status")
	local value = KSENIAData['ksenia']['outputs'][OutID].STA
	local idOutBind = KSENIAData['ksenia']['outputs'][OutID].contacts
	local name = KSENIAData['ksenia']['outputs'][OutID].DES

	put_in_queue(ksAddVariable, {VARIABLE_NAME["Out"].. name,value,"BOOL",0})
end

function put_in_late_queue_labeled(label, ...)
	if (cmds_c4_queue_late==nil) then
		cmds_c4_queue_late = Queue:new()
	end
	cmds_c4_queue_late:push_by_key(label, {...})
	kwLogTrace(5, "#queue #Status","Pushed in queue late, labeled as ("..label..") (size: "..tostring(cmds_c4_queue:size())..")")
  
	
	--if not queue_processor_Timer:TimerStarted() then 
	--	queue_processor_Timer:StartTimer(queue_timeLapse)
  	--end
end

--- function put_in_queue(...)			
--- 	if (cmds_c4_queue==nil) then
--- 		cmds_c4_queue = Queue:new()
--- 	end
--- 	
--- 	cmds_c4_queue:push({...})
--- 
--- 	kwLogTrace(5, "#queue #Status","Pushed in queue (size: "..tostring(cmds_c4_queue:size())..")")
---   if not queue_processor_Timer:TimerStarted() then 
--- 		queue_processor_Timer:StartTimer(queue_timeLapse)
---   end
--- end
  function put_in_queue(...)      
	if (cmds_c4_queue==nil) then
	  cmds_c4_queue = Queue:new()
	end
	
	cmds_c4_queue:push({...})
    print("---------->>>", getName(...))
	kwLogTrace(5, "#queue #Status","Pushed in queue (size: "..tostring(cmds_c4_queue:size())..")")
	if not queue_processor_Timer:TimerStarted() then 
	  queue_processor_Timer:StartTimer(queue_timeLapse)
	end
  end
  
  function getName(funct)
	for i,v in pairs(getfenv()) do
	  if v == funct then
		return i
	  end
	end
  end


timermin, timermax = 80, 120-- 50,150
function queue_processor()
	if cmds_c4_queue:is_empty() then
		kwLogTrace(6, "#queue #Status","END QUEUE")
		send_commands("REALTIME", NumberOfSocket[socket_type.installer])
		--local data = os.date("%d/%m/%Y %X")
		--local msg = "Queue empty on "..data.. "."
		--C4:UpdateProperty(KS_PROP["LAST_UPDATE"], msg)
		-- non so bene a cosa serva, ma nel dubbio qui ha un senso 2019-06-13
		--SynchronizePanelInfo()
		--ReportPanelInitialized()
		queue_processor_late()
		--queue_timeLapse = 100
		--queue_processor_Timer:KillTimer()
	else
		local element = cmds_c4_queue:pop()
		local len = cmds_c4_queue:size()
		local msg = "Processing queue, "..len.." action(s) left"
		kwLogTrace(3, "#queue #Status",msg)

		-- aggiorno la proprerty solo una volta ogni 10 per ridurre
		-- i refresh su Composer che non li tratta adeguatamente
		if (len < 10) then
			msg = "Processing queue, less then 10 actions left"
		else
			msg = "Processing queue, more then "..tostring(len-len%10).." actions left..."
		end
		-- aggiorna solo se messaggio cambiato
		if string.match (Properties[KS_PROP["LAST_UPDATE"]], msg) ~= msg then
			C4:UpdateProperty(KS_PROP["LAST_UPDATE"], msg)
		end
			
		if type(element[2])=="table" then 
			status, err = pcall(element[1], unpack(element[2]))
			if (not status) then
				kwLogTrace(1, "#queue #call","LUA_ERROR: " .. err)
			end
		else
			status, err = pcall(element[1], element[2])
			if (not status) then
				kwLogTrace(1, "#queue #call","LUA_ERROR: " .. err)
			end
		end
		element[1] = nil
		element[2] = nil
		element		 = nil
		queue_processor_Timer:StartTimer(queue_timeLapse)
	end
end

function queue_processor_late()
	if (cmds_c4_queue_late==nil) then
		cmds_c4_queue_late = Queue:new()
	end

	if cmds_c4_queue_late:is_empty() then
		kwLogTrace(6, "#queue #Status","END QUEUE LATE")
		send_commands("REALTIME", NumberOfSocket[socket_type.installer])
		local data = os.date("%d/%m/%Y %X")
		local msg = "Queue late empty on "..data.. "."
		C4:UpdateProperty(KS_PROP["LAST_UPDATE"], msg)
		-- non so bene a cosa serva, ma nel dubbio qui ha un senso 2019-06-13
		--SynchronizePanelInfo()
		--ReportPanelInitialized()
		queue_timeLapse = 100
		queue_processor_Timer:KillTimer()
	else
		local element = cmds_c4_queue_late:pop()
		local len = cmds_c4_queue_late:size()
		local msg = "Processing queue late, "..len.." action(s) left"
		kwLogTrace(3, "#queue #Status",msg)

		-- aggiorno la proprerty solo una volta ogni 10 per ridurre
		-- i refresh su Composer che non li tratta adeguatamente
		if (len < 10) then
			msg = "Processing queue late, less then 10 actions left"
		else
			msg = "Processing queue late, more then "..tostring(len-len%10).." actions left..."
		end
		-- aggiorna solo se messaggio cambiato
		if string.match (Properties[KS_PROP["LAST_UPDATE"]], msg) ~= msg then
			C4:UpdateProperty(KS_PROP["LAST_UPDATE"], msg)
		end
			
		if type(element[2])=="table" then 
			status, err = pcall(element[1], unpack(element[2]))
			if (not status) then
				kwLogTrace(1, "#queue #call","LUA_ERROR: " .. err)
			end
		else
			status, err = pcall(element[1], element[2])
			if (not status) then
				kwLogTrace(1, "#queue #call","LUA_ERROR: " .. err)
			end
		end
		element[1] = nil
		element[2] = nil
		element		 = nil
		queue_processor_Timer:StartTimer(queue_timeLapse)
	end
end end)
package.preload['ksenia_persist'] = (function (...)
-- GESTIONE DELLE PERSIST
----------------------------------------------------------------------
-- RESTORE SAVED BINDINGS ON DRIVER REBOOT (CONTROL4 ANORMAL POWER OFF)
--------------------------------------------------------------------

-- svuoto la persist delle variabili (per ricrearle tutte)
if (PersistData ~= nil) then
    if (PersistData['ksenia'] == nil) then PersistData['ksenia'] = {} end
    if (PersistData['ksenia']['CONrestore'] == nil) then PersistData['ksenia']['CONrestore'] = {} end
    if (PersistData['ksenia']['VARrestore'] == nil) then PersistData['ksenia']['VARrestore'] = {} end
    --ripristino contatti
    for index, c in pairs(PersistData['ksenia']['CONrestore']) do
	   C4:AddDynamicBinding(c.id, c.ctype, c.bIs, c.name, c.class,c.hidden, c.abind)
    end
   --ripristino variabili
    for index, v in pairs(PersistData['ksenia']['VARrestore']) do
	   C4:AddVariable(v.name,v.value,v.tipo,v.rw)
    end
end


function PersistRestoreConn (id, ctype, bIs, name, class,hidden, abind)
    local flag_found = false
	for index,Var in pairs(PersistData['ksenia']['CONrestore']) do
	   if Var.id == id then
		  PersistData['ksenia']['CONrestore'][index].ctype = ctype
		  PersistData['ksenia']['CONrestore'][index].bIs = bIs
		  PersistData['ksenia']['CONrestore'][index].name = name
		  PersistData['ksenia']['CONrestore'][index].class = class
          PersistData['ksenia']['CONrestore'][index].hidden = hidden
          PersistData['ksenia']['CONrestore'][index].abind = abind
		  flag_found = true
	   end
    end
    
    if (flag_found ==false) then
        table.insert(PersistData['ksenia']['CONrestore'], 
        {  id= id, 
        ctype = ctype, 
        bIs = bIs, 
        name = name, 
        class = class,
        hidden = hidden, 
        abind = abind })
    end
    
end

function PersistRestoreVar(id,name,value,tipo,rw)
    --Dbg:Debug("PersistRestoreVar: "..name.." - "..value.." - "..tipo.." - "..tostring(rw))
  local flag_found = false
	for index,Var in pairs(PersistData['ksenia']['VARrestore']) do
	   if Var.id == id then
		  PersistData['ksenia']['VARrestore'][index].name = name
		  PersistData['ksenia']['VARrestore'][index].value = value
		  PersistData['ksenia']['VARrestore'][index].tipo = tipo
		  PersistData['ksenia']['VARrestore'][index].rw = rw
		  PersistData['ksenia']['VARrestore'][index].deleted = false
		  flag_found = true
	   end
  end
  
  if (flag_found ==false) then
      table.insert(PersistData['ksenia']['VARrestore'],
             {	name = name,
             value = value,
             tipo = tipo,
             rw = rw,
		   deleted = false
               })
    end
end

 end)
package.preload['ksenia_debugger'] = (function (...)

function DisplayStatus()
	local data = os.date("%d/%m/%Y %X")
	local header = ""
	local txt = ""
	local msg = ""
	local indent = string.rep("  ", 3)
    header = "----------------------------------------------\n"
    header = header..data.." - Status of Ksenia I/O"
    header = header.."\n----------------------------------------------\n"
	msg = header

	--Basis Info
	header 	= "1. > BASIS INFO\n\n"
	txt = indent..string.format("%-12s: %-10s","PINToUse", (tPayloadType.ergo.code or "NO CODE"))--KSENIAData['ksenia']['basis_info'][1].PINToUse)
	txt = txt.."\n"
	msg = msg..header..txt
	
	--Lares Status
	header 	= "2. > LARES STATUS\n\n"
	if KSENIAData['ksenia']['lares_status']["TEMP"] ~= nil then 
		txt = indent..string.format("%-12s: %-10s","Temp Indoor",(KSENIAData['ksenia']['lares_status']["TEMP"].IN or "NO IN TEMP"))--KSENIAData['ksenia']['lares_status'][1].indoor)
		txt = txt.."\n"
		txt = txt..indent..string.format("%-12s: %-10s","Temp Outdoor",(KSENIAData['ksenia']['lares_status']["TEMP"].OUT or "NO OUT TEMP"))--KSENIAData['ksenia']['lares_status'][1].outdoor)
		txt = txt.."\n"
	end
	local operator
	if type(KSENIAData['ksenia']['lares_status']["MOBILE"].CARRIER) == 'string' then
	   operator =KSENIAData['ksenia']['lares_status']["MOBILE"].CARRIER
    else
	   operator = "Unknown"
    end
	txt = txt..indent..string.format("%-12s: %-10s","GSM Operator",operator)
	txt = txt.."\n"

	local credit = (KSENIAData['ksenia']['lares_status']["MOBILE"].CRE or "4294967295")
	if credit == "4294967295" then credit = "not installed" end
	txt = txt..indent..string.format("%-12s: %-10s","Sim 1 Credit",credit)
	txt = txt.."\n"
	
	-- Zone
	header 	= "3. > ZONES\n\n"
	txt = indent
	txt = txt..string.format("%-3s %-35s %-10s %-30s %-12s %-10s","Nr","ZONE","STATUS","PARTITION", "BYPASS","ISANALOG")
	txt = txt.."\n"
		for index,zs in pairs(KSENIAData['ksenia']['zones']) do
		   txt = txt..indent
		   local partition
		   if KSENIAData['ksenia']['partitions'][tonumber(zs.PART)] ~= nil  then
				partition = KSENIAData['ksenia']['partitions'][tonumber(zs.PART)].DES
			else
				partition = "Unassociated"
			end
		   txt = txt..string.format("%-3s %-35s %-10s %-30s %-12s %-10s"
										,zs.ID
										,zs.DES
										,zs.STA
										,partition
										,zs.BYP
										,tostring(zs.isAnalog) or "no info"
									)
			txt = txt.."\n"
		end
	txt = txt.."\n"
	msg = msg..header..txt
    -- Partizioni
	header 	= "4. > PARTITIONS\n\n"
	txt = indent
	txt = txt..string.format("%-3s %-25s %-20s %-12s","Nr","PARTITION","STATUS","EXIT_TIME")

	txt = txt.."\n"
		for index,pt in pairs(KSENIAData['ksenia']['partitions']) do
		   txt = txt..indent
		   txt = txt..string.format("%-3s %-25s %-20s %-12s"
										,index
										,pt.DES
										,pt.ARM
										,pt.TIME or "no time"
										)
			txt = txt.."\n"
		end
	txt = txt.."\n"
	msg = msg..header..txt

	
	-- Scenari
	header 	= "5. > SCENARI\n\n"
	txt = indent
	txt = txt..string.format("%-3s %-15s %-20s","Nr","SCENARIO","ABIL")
	txt = txt.."\n"
		for index,sc in pairs(KSENIAData['ksenia']['scenarios']) do
		   txt = txt..indent
		   txt = txt..string.format("%-3s %-15s %-20s"
										,index
										,sc.name
										,sc.abil
										)
			txt = txt.."\n"
		end
	txt = txt.."\n"
	msg = msg..header..txt
    -- Output
		header 	= "6. > OUTPUT\n\n"
	txt = indent
	txt = txt..string.format("%-3s %-15s %-10s %-12s %-10s %-20s","Nr","OUTPUT","STATUS","TYPE","CNV","CONTACT")
	txt = txt.."\n"
		for index,out in pairs(KSENIAData['ksenia']['outputs']) do
		   txt = txt..indent
		   txt = txt..string.format("%-3s %-15s %-10s %-12s %-10s %-20s"
										,index
										,out.DES
										,out.STA
										,out.CAT
										,out.CNV
										,out.contacts)
			txt = txt.."\n"
		end
	txt = txt.."\n"
	msg = msg..header..txt
	msg = msg .."\n----------------------------------------------"
	msg = msg .. "\n\nDemoSocket"

	msg = msg .. tstring (DemoSocket,2)
	msg = msg .. "\n\n CANCONNECT: "..tostring(CANCONNECT)
	msg = msg .. "\n\n ISONLINE: "..tostring(ISONLINE)
	msg = msg .. "\n\n SocketIsOpenOrInOpening: "..tostring(SocketIsOpenOrInOpening)
	msg = msg .. "\n\n Last scenario active parsed: "..tostring(gScenarioActive)
	msg = msg .. "\n\n is Able ToWork: "..tostring(LICENSE_MGR:isAbleToWork()) or "NIL"
	msg = msg .. "\n\n is trial or licenced: ".. tostring(LICENSE_MGR:isLicenseActiveOrTrial()) or "NIL"
	msg = msg .. "\n\n DriverCentral Licence: ".. tostring(LICENSE_MGR:getParamValue("Licensed", "DRIVERCENTRAL")) or "NIL"
	msg = msg .. "\n\n DriverCentral Trial: ".. tostring(LICENSE_MGR:getParamValue("Trial", "DRIVERCENTRAL")) or "NIL"

	msg = msg .."\n----------------------------------------------"
	msg = msg .. "\n\nTable status"
	
	msg = msg .. "\nTimers table: "..len(timerTable)
	msg = msg .. "\nQueue table: "..cmds_c4_queue:size()
	msg = msg .. "\nVAR table: "..len(PersistData['ksenia']['VARrestore'])
	msg = msg .. "\nCON table: "..len(PersistData['ksenia']['CONrestore'])
	print(msg) --check: lo volglio print?
	print ("----------------------------------------------")
end

function DisplayC4Variable()

	local data = os.date("%d/%m/%Y %X")
	local header = ""
	local txt = ""
	local msg = ""
	local indent = string.rep("  ", 3)
    header = "-------------------------------------------------------------------------\n"
    header = header..data.." - Status of Control4 Variables"
    header = header.."\n-------------------------------------------------------------------------\n"
	msg = header
	
	-- PANEL VARIABLES
	header 	= "0. > PANEL VARIABLES\n\n"
	local id = C4:GetDeviceID()
	local PanelTable = C4:GetDeviceVariables(id)
	txt = indent
	txt = txt..string.format("%-20s %-50s %-10s","NAME","VALUE","READONLY")
	txt = txt.."\n"
		for i, var in pairsByKeys(PanelTable) do
		   txt = txt..indent
		   txt = txt..string.format("%-20s %-50s %-10s"
										,var.name
										,var.value
										,var.readonly
										)
			txt = txt.."\n"
		end
	txt = txt.."\n"
	
	id = id +1
	local PanelTable = C4:GetDeviceVariables(id)
		for i, var in pairsByKeys(PanelTable) do
		   txt = txt..indent
		   txt = txt..string.format("%-20s %-50s %-10s"
										,var.name
										,var.value
										,var.readonly
										)
			txt = txt.."\n"
		end
	txt = txt.."\n"
	msg = msg..header..txt
	local PartitionVarTable = {}
	for index,pt in pairs(KSENIAData['ksenia']['partitions']) do
		id = id +1
		PartitionVarTable[index] = (C4:GetDeviceVariables(id))
		msg = msg..DysplayPartitionVar(PartitionVarTable[index],index)
	end
	print(msg) --check: lo volglio print?
end

function DysplayPartitionVar(partitionVarTable, nr)
	local header = ""
	local txt = ""
	local msg = ""
	local indent = string.rep("  ", 3)
 	-- PANEL VARIABLES
	header 	= nr..". > PARTITION VARIABLES\n\n"
	txt = indent
	txt = txt..string.format("%-20s %-50s %-10s","NAME","VALUE","READONLY")
	txt = txt.."\n"
		for i, var in pairsByKeys(partitionVarTable) do
		   txt = txt..indent
		   txt = txt..string.format("%-20s %-50s %-10s"
										,var.name
										,var.value
										,var.readonly
										)
			txt = txt.."\n"
		end
	txt = txt.."\n"
	msg = msg..header..txt
	return msg
end

function pairsByKeys (t, f)
    local a = {}
    for n in pairs(t) do
        table.insert(a, n)
    end
    table.sort(a, f)
    local i = 0      -- iterator variable
    local iter = function ()   -- iterator function
        i = i + 1
        if a[i] == nil then
            return nil
        else
            return a[i], t[a[i]]
        end
    end
    return iter
end

 end)
package.preload['create_commands'] = (function (...)
   
function create_arm_partition_pld( ids, mod)
    local message  =""
    --da come  scritto il comando posso comandare solo una partizione per volta
    message = message..'           "PARTITION":{ \n             "ID":"'
       --per ora considero che mi possono arrivare solo comandi per partizioni singole
    message = message .. ids
    message = message .. '",\n          '
    message = message .. '"MOD":"'
    message = message .. mod
    message = message .. '" \n}'
    return message
end

 end)
package.preload['variables_and_tables'] = (function (...)
require "create_commands"
-- Properties
KS_PROP = {}
--KS_PROP["TYPE"]   = "Ks lares Type" --128IP --48IP --16IP
KS_PROP["IP"] = "Ksenia websocket IP address"
KS_PROP["PROTOCOL"] = "Ksenia websocket protocol"
KS_PROP["INT_PWD"]  = "Ksenia installer password"  
KS_PROP["C4_PWD"] = "Ksenia user password"
KS_PROP["PORT"]   = "Ksenia websocket IP port"
KS_PROP["LAST_UPDATE"] = "Ks Last Config"
KS_PROP["POLL_TIME"] = "Polling Time (min)" -- need a tonumber

--KS_PROP["OUT_MODE"] = "Pgm/Output Mode" -- predisposizione PGM

for i = 1,20 do 
	local index = tostring( i )
	KS_PROP["PANIC"..index] = "Partition "..index.." Panic Scenario button"
	KS_PROP["HOME"..index] = "Partition "..index.." Home Scenario button"
	KS_PROP["AWAY"..index] = "Partition "..index.." Away Scenario button"
	KS_PROP["STAY"..index] = "Partition "..index.." Stay Scenario button"
	KS_PROP["DISARM"..index] = "Partition "..index.." Disarming Scenario function"
	KS_PROP["ARM"..index] = "Partition "..index.." Arm Scenario button"
	KS_PROP["CUSTOM_A"..index] = "Partition "..index.." Custom A Scenario function"
	KS_PROP["CUSTOM_B"..index] = "Partition "..index.." Custom B Scenario function"
end

KS_PROP["POLLING"] = "Polling Period (minutes)"
--license
KS_PROP["CLOUDSTATUS"] = "Cloud Status"
KS_PROP["AUTOUPDATES"] = "Automatic Updates"

pollingTimerPeriod = Properties[KS_PROP["POLLING"]]

C4_BUTTON = {}
C4_BUTTON["HOME"] = "HomeScenario"
C4_BUTTON["AWAY"] = "AwayScenario"
C4_BUTTON["DISARM"] = "DisarmingScenario"
C4_BUTTON["STAY"] = "StayScenario"
C4_BUTTON["ARM"] = "ArmScenario"
C4_BUTTON["CUSTOM_A"] = "Custom A Scenario"
C4_BUTTON["CUSTOM_B"] = "Custom B Scenario"

KS_PROP["TAGS"] = "Log hashTags"
KS_PROP["LICENSE"] = "License Code"
KS_PROP["LICENSE_STATUS"] = "License Status"
KS_PROP["DRIVER_VERSION"] = "Driver Version"
KS_PROP["SUPPORT_CODE"] = "Support Code"

GlobalString = {}
GlobalString.ConnectionEstablished =  '{"ws": "connection established"}'
GlobalString.error2interface = "ERROR, MORE INTERFACE TRYING TO USE PIN"
GlobalString.selectScenario ="Select Scenario"

NetworkIP = true
ISONLINE = true
HTTP_BINDING = 6083
SocketIsOpenOrInOpening = false

KS = {}
KS.ID_LOGIN = "0"
KS.RESULT = ""
KS.RESULT_DETAIL = ""
KS.DESCRIPTION = ""
KS.SENDER = "7C5452FB-079D-48AF-82D8-AD01F98AD3DD"
KS.RESOURCE =  "KseniaWsock"
--KS.IP_DEVICE = "wss://192.168.0.195"
--KS.PROTOCOL = "TLS"
--KS.HTTP_PORT = 443
KS.IP_DEVICE = "default" --Properties[KS_PROP["IP"]]-- "ws://192.168.0.195"
KS.PROTOCOL =  "default" --"TCP"
KS.HTTP_PORT = "default" --Properties[KS_PROP["PORT"]]-- 80PORT
queue_timeLapse = 200
sw_version = 1000

KseniaSettings = {}
KseniaSettings.default = {}
KseniaSettings.default = KS

--arming and disarming stuff
socket_type = {}
socket_type.installer = "INSTALLER"--"IP_SUPERV"--
socket_type.user = "IP_SUPERV"--"ERGO_T"
socket_type.cmd = "CMD"
socket_type.part = "PART"
socket_type.scenario = "SCENARIO"
socket_type.output = "OUTPUT"
socket_type.bypass = "BYPASS"
socket_type.auxi = "AUXI"
socket_number = {}
socket_number.installer = 6101
socket_number.user = 6102

TypeOfSocket = {}
NumberOfSocket = {} 
Arm_all_partitions = "-1"

pinValidityTime = 5
messageValidityTime = 10

gNeedReadFromPanel = true
PRINTLOG = true
LOGTABLE = {}

Partition_of_Timer = {}

LAST_PARTITION = ""

OLD_IntfcID = ""

FAIL = "FAIL"
LOGIN_KO = "LOGIN_KO"
NOT_LOGGED = "NOT_LOGGED"
----------------------KS.isrunning = false

--Comand of the protocol to send
--"CMD"
tCmd = {}
	tCmd.login = "LOGIN"
	tCmd.logout = "LOGOUT"
	tCmd.read = "READ"   --comando usato per leggere le strutture
	tCmd.realtime = "REALTIME"
	tCmd.write = "WRITE"
	tCmd.cmduser= "CMD_USR"

--Payloadtype of the protocol
--"PAYLOAD_TYPE"
tPayloadType = {}
	--tPayloadType.ergo = {name = "ERGO_T", code = string.sub(C4:GetUniqueMAC (), -6)} --654321"}	local mac = C4:GetUniqueMAC ()
	tPayloadType.ergo = {name = "IP_SUPERV", code = string.sub(C4:GetUniqueMAC (), -6)} --654321"}	local mac = C4:GetUniqueMAC ()
	--tPayloadType.installer = {name = "IP_SUPERV", code = string.sub(C4:GetUniqueMAC (), -6)} --654321"}	local mac = C4:GetUniqueMAC ()
	tPayloadType.installer = {name = "INSTALLER", code = "default"} --123456"}
	tPayloadType.usr = {name = "USER", code = "default"}
	tPayloadType.zones = "ZONES"
	tPayloadType.scenarios = "SCENARIOS"
	tPayloadType.all = "ALL"
	tPayloadType.register = "REGISTER"
	tPayloadType.prg_all = "PRG_ALL"
	tPayloadType.prg_zones = "PRG_ZONES"
	tPayloadType.prg_partitions = "PRG_PARTITIONS"
	tPayloadType.prg_scenarios = "PRG_SCENARIOS"  --non usata DELETEME
	tPayloadType.prg_outputs = "PRG_OUTPUTS"
	tPayloadType.arm_partition = "CMD_ARM_PARTITION"
	tPayloadType.exe_scenario = "CMD_EXE_SCENARIO"
	tPayloadType.set_output = "CMD_SET_OUTPUT"
	tPayloadType.byp_zone = "CMD_BYP_ZONE"
	tPayloadType.set_auxi = "CMD_SET_OUTPUT"
	tPayloadType.exe_scenario = "CMD_EXE_SCENARIO"
	tPayloadType.change_pin = "CMD_CHANGE_PIN"

--Payload accepted by the protocol
tPayload = {}
	tPayload.ID_ITEMS_RANGE = "ID_ITEMS_RANGE"
	tPayload.ALLALL = '["ALL","ALL"]'
	tPayload.STATUSALL = '["STATUS_ALL"]'

--tPayload.ARMPARTITION =  '       "PRG_ARMING_MODES":[ {"ID":"1", \n                "DES":"Perimetrali", \n                "MOD":"N"} ]'
tPayload.ARMPARTITION =  create_arm_partition_pld

--contiene il payload
tPAYLOAD = {}
	tPAYLOAD.LOGIN = {}
	tPAYLOAD.LOGIN.PIN = tPayloadType.ergo.code   
	tPAYLOAD.LOGIN_INST = {}
	tPAYLOAD.LOGIN_INST.PIN = tPayloadType.installer.code

--contiene le risposte ai comandi ma semplificate per leggibilita
tRESPONSE = {}
tRESPONSE.LOGIN_RES = "login"
tRESPONSE.LOGOUT_RES = "logout"
tRESPONSE.CLEAR_RES = "clear"
tRESPONSE.READ_RES = {}
tRESPONSE.READ_RES.CMD = "READ_RES"

tRESPONSE.READ_RES.PRG_ZONES = "read_zones"
tRESPONSE.READ_RES.PRG_OUTPUTS = "read_outputs"
tRESPONSE.READ_RES.PRG_PARTITIONS = "read_partitions"

--tRESPONSE.READ_RES.ZONES = "read_zones"
--tRESPONSE.READ_RES.OUTPUTS = "read_outputs"
--tRESPONSE.READ_RES.PARTITIONS = "read_partitions"
tRESPONSE.READ_RES.SCENARIOS = "read_scenarios"
tRESPONSE.READ_RES.ALL = "read_all"
tRESPONSE.REALTIMES_RES = "realtime" 
tRESPONSE.CMD_USR_RES = ""


KSC4_ZONE = {}
	KSC4_ZONE.STA = {}
	KSC4_ZONE.STA.R = "NORMAL"--"R"--"Rest"
	KSC4_ZONE.STA.A = "ALARM"  --"A"--"Alarm"
	KSC4_ZONE.STA.FM = "MASK"--"FM"--"Fault/Masking"
	KSC4_ZONE.STA.T = "TAMPER"  --"T"--"Tamper" --sabotaggio
	KSC4_ZONE.STA.E = "ERROR" --"E"--"Error"
	KSC4_ZONE.BYP = {} 
	KSC4_ZONE.BYP.NO = "UN_BYPASS"--"NO"--"Not Bypass"
	KSC4_ZONE.BYP.AUTO = "BYPASS"--"AUTO"--"Auto Bypass"
	KSC4_ZONE.BYP.MAN_I = "BYPASS"--"MAN_I"--"Manually Bypass Enter"
	KSC4_ZONE.BYP.MAN_M = "BYPASS"--"MAN_M"--"Manually Bypass Menu"
--tabella di conversione fra gli stati letti da ksenia e quelli che imposto in C4
KSC4_PARTITION = {}
	KSC4_PARTITION["D"] = AS_DISARMED_READY
	KSC4_PARTITION["DA"] = AS_DISARMED_READY
	KSC4_PARTITION["OT"] = AS_EXIT_DELAY
	KSC4_PARTITION["IA"] = AS_ARMED
	KSC4_PARTITION["IT"] = AS_ENTRY_DELAY
	KSC4_PARTITION["DA"] = AS_ARMED
	KSC4_PARTITION["AL"] = AS_ALARM

ZONE = {}
	ZONE.STA = {}
	ZONE.STA.R = "R"--"Rest"
	ZONE.STA.A = "A"--"Alarm"
	ZONE.STA.FM = "FM"--"Fault/Masking"
	ZONE.STA.T = "T"--"Tamper" --sabotaggio
	ZONE.STA.E = "E"--"Error"
	ZONE.BYP = {} 
	ZONE.BYP.NO = "NO"--"Not Bypass"
	ZONE.BYP.AUTO = "AUTO"--"Auto Bypass"
	ZONE.BYP.MAN_I = "MAN_I"--"Manually Bypass Enter"
	ZONE.BYP.MAN_M = "MAN_M"--"Manually Bypass Menu"
	ZONE.T = {}  --Ciclo memoria diTamper /sabotaggio
	ZONE.T.C = "C"--"Cycle Active"
	ZONE.T.M = "M"--"Memory Active"
	ZONE.T.N = "C"--"Cycle and Memory Not Active"
	ZONE.A = {}-- ciclo memoria allarme
	ZONE.A.C = "C"--"Cycle Active"
	ZONE.A.M = "M"--Memory Active"
	ZONE.A.N = "N"--"Cycle and Memory Not Active"
	ZONE.FM = {}
	ZONE.FM.F = "F"--"False"
	ZONE.FM.T = "T"--"True"
	ZONE.BYP_EN = {}
	ZONE.BYP_EN.F = "F"-- "False"
	ZONE.BYP_EN.T = "T"--"True"
	ZONE.CMD = {}
	ZONE.CMD.F = "F"--"False"
	ZONE.CMD.T = "T"--"True"
	ZONE.ID = ""
	ZONE.DES = ""
		    
---// identificatore partizione 
PARTITION = {}
	PARTITION.ID = ""
	PARTITION.ARM = {}
	PARTITION.ARM.D = "D"  --Diosarm, Disinserito
	PARTITION.ARM.DA = "DA" -- delayed Arming, inserimento ritardato
	PARTITION.ARM.IA ="IA" -- Immediate Arming, inserimento instantaneo
	PARTITION.ARM.IT = "IT" --Input Time, Tempo di ingresso
	PARTITION.ARM.OT = "OT" --Output Time
	PARTITION.AST = {}   --alarme
	PARTITION.AST.OK = "OK"  --no alarme
	PARTITION.AST.AL = "AL" --alarme
	PARTITION.AST.AM = "AM"  --memoria allarme
	PARTITION.TST = {}   --sabotaggio
	PARTITION.TST.OK = "OK"    --no sabotaggio
	PARTITION.TST.TAM = "TAM"  --sabotaggio in corso
	PARTITION.TST.AM = "AM"--memoria sabotaggio
	PARTITION.DES = ""
	PARTITION.T = "" --Tempo di ingresso

SCENARIOS_CONF = {}
	SCENARIOS_CONF.H = {abil = "FALSE", pin = "FALSE"}
	SCENARIOS_CONF.P = {abil = "TRUE", pin = "TRUE"}
	SCENARIOS_CONF.PL = {abil = "FALSE", pin = "FALSE"}
	SCENARIOS_CONF.N = {abil = "TRUE", pin = "FALSE"}
	SCENARIOS_CONF.NL = {abil = "FALSE", pin = "FALSE"}
	SCENARIOS_CONF.PR = {abil = "TRUE", pin = "TRUE"}

OUTPUT = {}
OUTPUT.STA = {}
	OUTPUT.STA.ON = "ON" 
	OUTPUT.STA.OFF = "OFF" 
	OUTPUT.STA.UNK = "UNK"
	OUTPUT.STA.STOP = "STOP"
	OUTPUT.STA.UP = "UP"
	OUTPUT.STA.DOWN = "DOWN" 
	OUTPUT.STA.OPEN = "UP" 


KSENIA_ARM_TYPE = {}
	KSENIA_ARM_TYPE.Arm = "A"
	KSENIA_ARM_TYPE.ArmAll = "A"
	KSENIA_ARM_TYPE.DisarmAll = "D"
	KSENIA_ARM_TYPE.Disarm = "D"

VARIABLE_NAME = {}
	VARIABLE_NAME["Zone"] = "Z_" --zone
	VARIABLE_NAME["ZoneName"] = "Z-N_" --zone name
	VARIABLE_NAME["AnalogZ"] = "zA_" --zone analogiche
	VARIABLE_NAME["ZoneBP"] = "Z-BP_" --bypass zone
	VARIABLE_NAME["Partition"] = "P_" --partizioni
	VARIABLE_NAME["PartitionName"] = "P-N_" --zone name
	VARIABLE_NAME["PartitionMask"] = "KS_PartitionsMask" -- maschera partizioni
	VARIABLE_NAME["Out"] = "O_" --output
	VARIABLE_NAME["OutA"] = "O-A_" --output analogici
	VARIABLE_NAME["LastZoneAlarm"] = "KS_LastZoneAlarmed"
	VARIABLE_NAME["LastAlarmMessage"] = "KS_LastAlarmMessage"
	VARIABLE_NAME["PartitionChanged"] = "KS_PartitionsChanged"
	VARIABLE_NAME["ksTroubleText"] = "KS_TROUBLE_TEXT" -- scrittura su trouble
	VARIABLE_NAME["SimSignal"] = "KS_Sim_Signal"
	VARIABLE_NAME["GSM_OPERATOR"] = "GSM_operator"
	VARIABLE_NAME["Sim1_CREDIT"] = "Sim1_Credit"
	VARIABLE_NAME["TemperatureIn"] = "KS_TemperatureIn"
	VARIABLE_NAME["TemperatureOut"] = "KS_TemperatureOut"
	VARIABLE_NAME["TemperatureInNumeric"] = "KS_TemperatureInNumeric"
	VARIABLE_NAME["TemperatureOutNumeric"] = "KS_TemperatureOutNumeric"






STATUS_SYSTEM = {}
STATUS_SYSTEM.name = "STATUS_SYSTEM"
STATUS_SYSTEM.ID = ""--":"1",               
--// Array di lunghezza variabile contenente informazioni varie relative lo stato del sistema 
STATUS_SYSTEM.INFO = ""--":[      "FRZ_ALARM", // Sistema in blocco allarmi     "FRZ_ALL",   // Sistema in blocco totale     "PRG_SES",   // Sessione prog. aperta     "BYP_ZONE",  // Zone escluse (manualmente)     "TEST_ZONE", // Zone in test     "CYCLE"      // Ciclo in corso ],               
--// Array di lunghezza variabile contenente informazioni relative ai sabotaggi attivi del sistema 
STATUS_SYSTEM.TAMPER = ""--":[     "PANEL",    // Scheda di centrale     "BUS_PER",  // Periferica bus     "WLS_PER",  // Periferica wireless      "JAM_868",  // Disturbo radio sulla banda 868MHz     "LOST_BUS", // Scomparsa periferica bus     "LOST_WLS", // Scomparsa periferica wireless     "ZONE"      // Zona ],               
--// Array di lunghezza variabile contenente informazioni relative alle memorie di sabotaggio del sistema. Pu contenere gli stessi valori definiti per l'array "TAMPER" 
STATUS_SYSTEM.TAMPER_MEM = ""--":[],               
--// Array di lunghezza variabile contenente informazioni relative agli allarmi attivi del sistema 
STATUS_SYSTEM.ALARM = ""--":[ "ZONE" // Zona in allarme (per ora unico valore definito) ],               
--// Array di lunghezza variabile contenente informazioni relative alle memorie di allarme del sistema. Pu contenere gli stessi valori definiti per l'array "ALARM" 
STATUS_SYSTEM.ALARM_MEM = ""--":[],               
--// Array di lunghezza variabile contenente informazioni relative ai guasti attivi del sistema 
STATUS_SYSTEM.FAULT = "" --:[     "PS_MISS",       // Mancanza rete 220Vac     "PS_LOW",        // Alimentazione bassa     "PS_FAULT",      // Caricabatterie guasto     "FUSE",          // Fusibile aperto     "LOW_BATT",      // Batteria Bassa     "BAD_BATT",      // Batteria guasta da sostituire     "LOST_BUS",      // Periferica bus scomparsa     "LOST_WLS",      // Periferica wireless scomparsa     "ZONE",          // Zona in mascheramento/guasto     "LAN_ETH",       // Collegamento Ethernet non presente     "REM_ETH",       // Ethernet con accesso solo locale     "PSTN",          // Guasto PSTN     "MOBILE",        // Guasto comunicatore cellulare/no rete     "SIM_CRE",       // Credito residuo SIM sotto soglia     "SIM_DATE",      // SIM scaduta     "COMMUNICATION", // Fallita comunicazione     "SIAIP_SUP",     // Fallita supervisione SIA IP     "SYSTEM"         // Guasto di sistema ],               
--// Array di lunghezza variabile contenente informazioni relative alle memorie di allarme del sistema. Pu contenere gli stessi valori definiti per l'array "FAULT"STATUS_SYSTEM.FAULT_MEM = ""--":[], // Modalit di inserimento attivo 
STATUS_SYSTEM.ARM = ""--":{     // Descrizione     "D":"Inserimento Totale", // Stringa MAX 32 caratteri con     // la descrizione della modalit     // di inserimento attiva     // Stato generale di inserimento     "S":"T|     // Inserito totale          T_IN|  // Inserito totale con tempo d'ingresso attivo          T_OUT| // Inserito totale con tempo d'uscita attivo           P|     // Inserito parziale          P_IN|  // Inserito parziale con tempo d'ingresso att.          P_OUT| // Inserito parziale con tempo d'uscita attivo          D",    // Disinserito } 
--// Temperatura 
STATUS_SYSTEM.TEMP = "" --":{ "IN":"NA|32.5", "OUT":"NA|32.5

STATUS_ZONES = {name="STATUS_ZONES"}
STATUS_PARTITIONS = {name="STATUS_PARTITIONS"}

KseniaMaskPartition = {}
KseniaMaskPartition[1] = 1
KseniaMaskPartition[2] = 2
KseniaMaskPartition[4] = 3
KseniaMaskPartition[8] = 4
KseniaMaskPartition[10] = 5
KseniaMaskPartition[20] = 6
KseniaMaskPartition[40] = 7
KseniaMaskPartition[80] = 8
KseniaMaskPartition[100] = 9
KseniaMaskPartition[200] = 10
KseniaMaskPartition[400] = 11
KseniaMaskPartition[800] = 12
KseniaMaskPartition[1000] = 13
KseniaMaskPartition[2000] = 14
KseniaMaskPartition[4000] = 15
KseniaMaskPartition[8000] = 16
KseniaMaskPartition[10000] = 17
KseniaMaskPartition[20000] = 18
KseniaMaskPartition[40000] = 19
KseniaMaskPartition[80000] = 20
KseniaMaskPartition[100000] = 21
KseniaMaskPartition[200000] = 22
KseniaMaskPartition[400000] = 23
KseniaMaskPartition[800000] = 24
KseniaMaskPartition[1000000] = 25
KseniaMaskPartition[2000000] = 26
KseniaMaskPartition[4000000] = 27
KseniaMaskPartition[8000000] = 28
KseniaMaskPartition[10000000] = 29
KseniaMaskPartition[20000000] = 30

-- ripristino variabili e connessioni da Persist
if (PersistData ~= nil) then
	if (PersistData['ksenia'] == nil) then 
	   PersistData['ksenia'] = {} 
	end
	if (PersistData['ksenia']['CONrestore'] == nil) then 
	   PersistData['ksenia']['CONrestore'] = {} 
	end
	if (PersistData['ksenia']['VARrestore'] == nil) then 
	   PersistData['ksenia']['VARrestore'] = {} 
	end
	--ripristino contatti
	for index, c in pairs(PersistData['ksenia']['CONrestore']) do
	   C4:AddDynamicBinding(c.id, c.ctype, c.bIs, c.name, c.class,c.hidden, c.abind)
	end
   --ripristino variabili
	for index, v in pairs(PersistData['ksenia']['VARrestore']) do
	   C4:AddVariable(v.name,v.value,v.tipo,v.rw)
	end
end

if (KSENIAData == nil) then KSENIAData = {} end
if (KSENIAData['GlobalData'] == nil) then KSENIAData['GlobalData'] = {} end  --ci metto tutti i dati parsificati dal json in arrivo
if (KSENIAData['GlobalData']['ksenia'] == nil) then KSENIAData['GlobalData']['ksenia'] = {} end
if (KSENIAData['GlobalData']['config_received'] == nil) then KSENIAData['GlobalData']['config_received'] = {} end
if (KSENIAData['GlobalData']['readKseniaConf'] == nil) then KSENIAData['GlobalData']['readKseniaConf'] = true end
if (KSENIAData['ksenia'] == nil) then KSENIAData['ksenia'] = {} end --ci metto tutti i dati che provengono dalla GlobalData, ma organizzati in modo che siano usabili
if (KSENIAData['ksenia']['zones'] == nil) then KSENIAData['ksenia']['zones'] = {} end
if (KSENIAData['ksenia']['partitions'] == nil) then KSENIAData['ksenia']['partitions'] = {} end
if (KSENIAData['ksenia']['outputs'] == nil) then KSENIAData['ksenia']['outputs'] = {} end
if (KSENIAData['ksenia']['scenarios'] == nil) then KSENIAData['ksenia']['scenarios'] = {} end
if (KSENIAData['ksenia']['NotGenScenarios'] == nil) then KSENIAData['ksenia']['NotGenScenarios'] = {} end
if (KSENIAData['ksenia']['lares_status'] == nil) then KSENIAData['ksenia']['lares_status'] = {} end
if (KSENIAData['ksenia']['basis_info'] == nil) then KSENIAData['ksenia']['basis_info'] = {} end
--IS_LICENSED = PersistData['ksenia']['IS_LICENSED'] or true

if (KSENIAData['ksenia']['variables'] == nil) then KSENIAData['ksenia']['variables'] = {} end


 end)
package.preload['wssocket'] = (function (...)
require "utility"  
require "variables_and_tables"
--require "json" 



-----------------------------------------------
-----------------------------------------------
local WebSocket = WebSocket or {}

function WebSocket:new (protocol, host, port, resource)
	kwLogTrace (6, "#websocket #new", "WebSocket:new protocol "..(protocol or "NO protocol")..", host "..(host or "NO host")..", port"..(port or "NO port")..", resource "..(resource or "NO resource"))
	if (protocol == 'TCP') then host = "ws://"..host
	elseif (protocol == 'TLS') then host = "wss://"..host
	end
	local url = host..":"..port.."/"..resource.."/"

	--non controllo se c' gi la WS perchtanto la apro con il timestamp e non posso sapere se c'
	-- if (WebSocket.Sockets and WebSocket.Sockets [url]) then
	-- 	return (WebSocket.Sockets [url])
	-- end

	local ws -- our WebSocket object
	local rest

	protocol, rest = string.match (url or '', '(wss?)://(.*)')

	local hostport, resource-- = string.match (rest or '', '(.-)(/.*)')
	hostport, resource = string.match (rest or '', '(.-)(/.*)')
	
	if (not (hostport and resource)) then
		hostport = rest
		resource = '/'
	end

	host, port = string.match (hostport or '', '(.-):(.*)')

	if (not (host and port)) then
		host = hostport
		if (protocol == 'ws') then port = 80
		elseif (protocol == 'wss') then port = 443
		end
	end

	port = tonumber (port)
	
	if (protocol and host and port and resource) then
		ws = {
				url = url,
				protocol = protocol,
				host = host,
				port = port,
				resource = resource,
				buf = '',
				ping_interval = 30,
				unique_identifier = tonumber(os.time(os.date("!*t")))
		}
		for k,v in pairs(ws) do 
			kwLogTrace (6, "#websocket #new", k,v) 
		end

		setmetatable (ws, self)
		self.__index = self
		self.header = {}

		WebSocket.Sockets = WebSocket.Sockets or {}
		WebSocket.Sockets [ws.unique_identifier] = ws
		return ws
	else
		return nil, 'invalid WebSocket URL provided:' .. (url or '')
	end
end

function WebSocket:delete ()
	self:Close ()
	if (WebSocket.Sockets) then
		if (self.unique_identifier) then
			WebSocket.Sockets [self.unique_identifier] = nil
		end
		if (self.netBinding) then
			C4:NetDisconnect(self.netBinding, self.port) 
			WebSocket.Sockets [self.netBinding] = nil
			C4:SetBindingAddress(self.netBinding, '')
		end
	end
end

function WebSocket:Start (idBind)
	kwLogTrace(6,"#start #socket", "starting Web Socket... Creating net connection to " .. (self.url or "No Url").." - "..(idBind or "No Bind"))
	local i = 6100

	if idBind ~= nil then
		self.netBinding = idBind
	else
		while (not self.netBinding and i < 6200) do
			local checkAddress = C4:GetBindingAddress (i)
			if (checkAddress == nil or checkAddress == '') then
				self.netBinding = i
			end
			i = i + 1
		end
	end
	if (self.netBinding and self.protocol) then
		WebSocket.Sockets = WebSocket.Sockets or {}
		WebSocket.Sockets [self.netBinding] = self

		if (self.protocol == 'wss') then
			C4:CreateNetworkConnection (self.netBinding, self.host, 'SSL')
			C4:NetPortOptions (self.netBinding, self.port, 'SSL')
		else
			C4:CreateNetworkConnection (self.netBinding, self.host)
		end
		C4:NetDisconnect (self.netBinding, self.port)
		C4:NetConnect (self.netBinding, self.port)
	else
		kwLogTrace(6,"#start #socket", 'No C4 network connections available')
	end
	 
end

function WebSocket:MakeHeaders ()
    local head = {}
    --local resource = '/KseniaWsock/'
	table.insert (head, 'GET ' .. self.resource.. ' HTTP/1.1')
	table.insert (head, 'Host: ' .. self.host .. ':' .. self.port)
	table.insert (head, 'Cache-Control: no-cache')
	table.insert (head, 'Pragma: no-cache')
	table.insert (head, 'Connection: Upgrade')
	table.insert (head, 'Upgrade: websocket')
	table.insert (head, 'Origin: file://') --GL
	-- Sec-WebSocket-Key is random 16-byte value, base64 encoded...
	self.key = ''
	for i = 1, 16 do 
		self.key = self.key .. string.char (math.random (33, 125))
	end
	self.key = C4:Base64Encode (self.key)
	table.insert (head, 'Sec-WebSocket-Key: '.. self.key)
	table.insert (head, 'Sec-WebSocket-Version: 13')
	table.insert (head, 'User-Agent: C4WebSocket/1')
	table.insert (head, 'Accept-Encoding: gzip, deflate, br')
	table.insert (head, 'Accept-Language: it-IT,it;q=0.9,en-US;q=0.8,en;q=0.7')
	table.insert (head, 'Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits')
    table.insert (head, 'Sec-WebSocket-Protocol: KS_WSOCK')
    table.insert (head, '\r\n')
    return (table.concat (head, '\r\n'))
    
end

function WebSocket:ParsePacket (strData)
	self.buf = (self.buf or '') .. strData

	if (self.running) then
		self:parseWSPacket ()
	else
		self:parseHTTPPacket ()
	end
end

function WebSocket:parseWSPacket ()
	local _, h1, h2, b1, b2, b3, b4, b5, b6, b7, b8 = string.unpack (self.buf, 'bbbbbbbbbb')

	local final = (bit.band (h1, 0x80) == 0x80)
	local rsv1 = (bit.band (h1, 0x40) == 0x40)
	local rsv2 = (bit.band (h1, 0x20) == 0x20)
	local rsv3 = (bit.band (h1, 0x10) == 0x10)
	local opcode = bit.band (h1, 0x0F)

	local masked = (bit.band (h2, 0x80) == 0x80)
	local mask
	local len = bit.band (h2, 0x7F)

	local msglen = 0
	local headerlen = 2
	if (len <= 125) then
		-- 1-byte length
		msglen = len
	elseif (len == 126) then
		-- 2-byte length
		msglen = msglen + b1; msglen = msglen * 0x100
		msglen = msglen + b2;
		headerlen = 4
	elseif (len == 127) then
		-- 8-byte length
		msglen = msglen + b1; msglen = msglen * 0x100
		msglen = msglen + b2; msglen = msglen * 0x100
		msglen = msglen + b3; msglen = msglen * 0x100
		msglen = msglen + b4; msglen = msglen * 0x100
		msglen = msglen + b5; msglen = msglen * 0x100
		msglen = msglen + b6; msglen = msglen * 0x100
		msglen = msglen + b7; msglen = msglen * 0x100
		msglen = msglen + b8;
		headerlen = 10
	end

	if (masked) then
		local maskbytes = string.sub (self.buf, headerlen + 1, headerlen + 5)
		mask = {}
		for i = 1, 4 do
			mask [i] = string.byte (string.sub (maskbytes, i, i))
		end
		headerlen = headerlen + 4
	end

	if (string.len (self.buf) >= headerlen + msglen) then
		local thisFragment = string.sub (self.buf, headerlen + 1, headerlen + msglen)
		if (masked) then
			if (mask) then
				thisFragment = self:Mask (thisFragment, mask)
			else
				kwLogTrace(6,"#start #socket #packet", 'masked bit set but no mask received')
				self.buf = ''
				return
			end
		end
		self.buf = string.sub (self.buf, headerlen + msglen + 1)

		if (opcode == 0x08) then
			if (self.ClosedByRemote) then
				self:ClosedByRemote ()
			end

		elseif (opcode == 0x09) then -- ping control frame
			self:Pong ()

		elseif (opcode == 0x0A) then -- pong control frame

		elseif (opcode == 0x00) then -- continuation frame
			if (not self.fragment) then
				kwLogTrace(4,"#start #socket #packet", 'error: received continuation frame before start frame')
				self.buf = ''
				return
			end
			self.fragment = self.fragment .. thisFragment

		elseif (opcode == 0x01 or opcode == 0x02) then -- non-control frame, beginning of fragment
			self.fragment = thisFragment
		end

		if (final and opcode < 0x08) then
			local data = self.fragment
			self.fragment = nil

			if (self.ProcessMessage) then
				self:ProcessMessage (self.netBinding, data)
			end
		end

		if (string.len (self.buf) > 0) then
			self:ParsePacket ('')
		end
	end

end

function WebSocket:parseHTTPPacket ()

	local headers = {}
	for line in string.gmatch (self.buf, '(.-)\r\n') do
		local k, v = string.match (line, '%s*(.-)%s*[:/*]%s*(.+)')
		if (k and v) then
			k = string.upper (k)
			headers [k] = v
		end
	end
	self.header = headers   --16/11/18

	local EOH = string.find (self.buf, '\r\n\r\n')


	if (EOH and headers ['SEC-WEBSOCKET-ACCEPT']) then
		self.buf = string.sub (self.buf, EOH + 4)
		
		local check = self.key ..'258EAFA5-E914-47DA-95CA-C5AB0DC85B11'

		local hash = C4:Hash ('sha1', check, {['return_encoding'] = 'BASE64'})

		if (headers ['SEC-WEBSOCKET-ACCEPT'] == hash and
			headers ['UPGRADE'] == 'websocket' and
			string.lower (headers ['CONNECTION']) == 'upgrade') then
				self.running = true
			if (self.Established) then
				self:Established (self.netBinding)
			end
		end
	end
	PrintTable (headers, " ")
	
end

function WebSocket:Close ()
	kwLogTrace(5,"#start #socket #connection",  "WebSocket:Close")
	self.running = false
	if (self.connected) then
		local pkt = string.char (0x88, 0x82, 0x00, 0x00, 0x00, 0x00, 0x03, 0xE8)
		C4:SendToNetwork (self.netBinding, self.port, pkt)

	end
	if (self.ClosingTimer) then self.ClosingTimer = self.ClosingTimer:Cancel () end
	self.ClosingTimer = C4:SetTimer (2500, function (timer) C4:NetDisconnect (self.netBinding, self.port) kwLogTrace(5,"#start #socket #connection","self.ClosingTimer EXPIRED") end)
end

function WebSocket:Ping ()
	if (self.connected) then
		-- MASK of 0x00's
		local pkt = string.char (0x89, 0x80, 0x00, 0x00, 0x00, 0x00)
		C4:SendToNetwork (self.netBinding, self.port, pkt)
	end
end

function WebSocket:Pong ()
	if (self.connected) then
		local pkt = string.char (0x8A, 0x80, 0x00, 0x00, 0x00, 0x00)
		C4:SendToNetwork (self.netBinding, self.port, pkt)
	end
end

function WebSocket:ConnectionChanged (strStatus)
	self.connected = (strStatus == 'ONLINE')
	if (self.PingTimer) then self.PingTimer = self.PingTimer:Cancel () end
    if (self.connected) then
		local header = self:MakeHeaders ()
        C4:SendToNetwork (self.netBinding, self.port, header)
	else
		if (self.running) then
			kwLogTrace(5,"#change #socket #connection",'WS ' .. self.url.." on identifier ".. self.unique_identifier .. ' disconnected while running')
		else
			kwLogTrace(5,"#change #socket #connection",'WS ' .. self.url .." on identifier ".. self.unique_identifier .. ' disconnected while not running')
		end
		self.running = false
		if (self.Offline) then
			self:Offline (self.netBinding)
		end
	end
end

function WebSocket:Send (s)
	if (self.connected) then
		local len = string.len (s)
		local lenstr = ''
		if (len <= 125) then
			lenstr = string.char (0x81, bit.bor (len, 0x80))
		elseif (len <= 65535) then
			lenstr = string.char (0x81, bit.bor (126, 0x80)) .. tohex (string.format ('%04X', len))
		else
			lenstr = string.char (0x81, bit.bor (127, 0x80)) .. tohex (string.format ('%16X', len))
		end

		local mask = {math.random (0, 255), math.random (0, 255), math.random (0, 255), math.random (0, 255)}
		local packet = {lenstr, string.char (mask [1]), string.char (mask [2]), string.char (mask [3]), string.char (mask [4])}

		table.insert (packet, self:Mask (s, mask))

		packet = table.concat (packet)
		C4:SendToNetwork(self.netBinding, self.port, packet)
	end
end

function WebSocket:Mask (s, mask)
	if (type (mask) == 'table') then
	elseif (type (mask) == 'string' and string.len (mask) >= 4) then
		local m = {}
		for i = 1, string.len (mask) do
			table.insert (m, string.byte (mask [i]))
		end
		mask = m
	end

	local slen = string.len (s)
	local mlen = table.getn (mask)

	local packet = {}

	for i = 1, slen do
		local pos = i % mlen
		if (pos == 0) then pos = mlen end
		local maskbyte = mask [pos]
		local sbyte = string.sub (s, i, i)
		local byte = string.byte (sbyte)
		local char = string.char (bit.bxor (byte, maskbyte))
		table.insert (packet, char)
	end

	packet = table.concat (packet)
	return (packet)
end

function WebSocket:SetProcessMessageFunction (f)
	self.ProcessMessage = f
end

function WebSocket:SetClosedByRemoteFunction (f)
	self.ClosedByRemote = f
end

function WebSocket:SetEstablishedFunction (f)
	self.Established = f
end

function WebSocket:SetOfflineFunction (f)
	self.Offline = f
end


return WebSocket end)
package.preload['json_b'] = (function (...)
--[[ json_b.lua

A compact pure-Lua json_b library.
The main functions are: json_b.stringify, json_b.parse.

## json_b.stringify:

This expects the following to be true of any tables being encoded:
 * They only have string or number keys. Number keys must be represented as
   strings in json_b; this is part of the json_b spec.
 * They are not recursive. Such a structure cannot be specified in json_b.

A Lua table is considered to be an array if and only if its set of keys is a
consecutive sequence of positive integers starting at 1. Arrays are encoded like
so: `[2, 3, false, "hi"]`. Any other type of Lua table is encoded as a json_b
object, encoded like so: `{"key1": 2, "key2": false}`.

Because the Lua nil value cannot be a key, and as a table value is considerd
equivalent to a missing key, there is no way to express the json_b "null" value in
a Lua table. The only way this will output "null" is if your entire input obj is
nil itself.

An empty Lua table, {}, could be considered either a json_b object or array -
it's an ambiguous edge case. We choose to treat this as an object as it is the
more general type.

To be clear, none of the above considerations is a limitation of this code.
Rather, it is what we get when we completely observe the json_b specification for
as arbitrary a Lua object as json_b is capable of expressing.

## json_b.parse:

This function parses json_b, with the exception that it does not pay attention to
\u-escaped unicode code points in strings.

It is difficult for Lua to return null as a value. In order to prevent the loss
of keys with a null value in a json_b string, this function uses the one-off
table value json_b.null (which is just an empty table) to indicate null values.
This way you can check if a value is null with the conditional
`val == json_b.null`.

If you have control over the data and are using Lua, I would recommend just
avoiding null values in your data to begin with.

--]]


local json_b = {}


-- Internal functions.

local function kind_of(obj)
  if type(obj) ~= 'table' then return type(obj) end
  local i = 1
  for _ in pairs(obj) do
    if obj[i] ~= nil then i = i + 1 else return 'table' end
  end
  if i == 1 then return 'table' else return 'array' end
end

local function escape_str(s)
  --local in_char  = {'\\', '"', '/', '\b', '\f', '\n', '\r', '\t'}
  --local out_char = {'\\', '"', '/',  'b',  'f',  'n',  'r',  't'}
  local in_char  = {'\\', '/', '\b', '\f', '\n', '\r', '\t'}  --ho tolto le " dai caratteri speciali
  local out_char = {'\\', '/',  'b',  'f',  'n',  'r',  't'}
  for i, c in ipairs(in_char) do
    s = s:gsub(c, '\\' .. out_char[i])
  end
  return s
end

-- Returns pos, did_find; there are two cases:
-- 1. Delimiter found: pos = pos after leading space + delim; did_find = true.
-- 2. Delimiter not found: pos = pos after leading space;     did_find = false.
-- This throws an error if err_if_missing is true and the delim is not found.
local function skip_delim(str, pos, delim, err_if_missing)
  pos = pos + #str:match('^%s*', pos)
  if str:sub(pos, pos) ~= delim then
    if err_if_missing then
      error('Expected ' .. delim .. ' near position ' .. pos)
    end
    return pos, false
  end
  return pos + 1, true
end

-- Expects the given pos to be the first character after the opening quote.
-- Returns val, pos; the returned pos is after the closing quote character.
local function parse_str_val(str, pos, val)
  val = val or ''
  local early_end_error = 'End of input found while parsing string.'
  if pos > #str then error(early_end_error) end
  local c = str:sub(pos, pos)
  if c == '"'  then return val, pos + 1 end
  if c ~= '\\' then return parse_str_val(str, pos + 1, val .. c) end
  -- We must have a \ character.
  local esc_map = {b = '\b', f = '\f', n = '\n', r = '\r', t = '\t'}
  local nextc = str:sub(pos + 1, pos + 1)
  if not nextc then error(early_end_error) end
  return parse_str_val(str, pos + 2, val .. (esc_map[nextc] or nextc))
end

-- Returns val, pos; the returned pos is after the number's final character.
local function parse_num_val(str, pos)
  local num_str = str:match('^-?%d+%.?%d*[eE]?[+-]?%d*', pos)
  local val = tonumber(num_str)
  if not val then error('Error parsing number at position ' .. pos .. '.') end
  return val, pos + #num_str
end


-- Public values and functions.

function json_b.stringify(obj, as_key)
  local s = {}  -- We'll build the string as an array of strings to be concatenated.
  local kind = kind_of(obj)  -- This is 'array' if it's an array or type(obj) otherwise.
  if kind == 'array' then
    if as_key then error('Can\'t encode array as key.') end
    s[#s + 1] = '['
    for i, val in ipairs(obj) do
      if i > 1 then s[#s + 1] = ', ' end
      s[#s + 1] = json_b.stringify(val)
    end
    s[#s + 1] = ']'
  elseif kind == 'table' then
    if as_key then error('Can\'t encode table as key.') end
    s[#s + 1] = '{'
    for k, v in pairs(obj) do
      if #s > 1 then s[#s + 1] = ', ' end
      s[#s + 1] = json_b.stringify(k, true)
      s[#s + 1] = ':'
      s[#s + 1] = json_b.stringify(v)
    end
    s[#s + 1] = '}'
  elseif kind == 'string' then
    if obj:sub(1,1) == '[' and  obj:sub(-1,-1) == ']' then 
      return escape_str(obj)
    else
      return '"' .. escape_str(obj) .. '"'
    end
  elseif kind == 'number' then
    if as_key then return '"' .. tostring(obj) .. '"' end
    return tostring(obj)
  elseif kind == 'boolean' then
    return tostring(obj)
  elseif kind == 'nil' then
    return 'null'
  else
    error('Unjson_bifiable type: ' .. kind .. '.')
  end
  return table.concat(s)
end

json_b.null = {}  -- This is a one-off table to represent the null value.

function json_b.parse(str, pos, end_delim)
  pos = pos or 1
  if pos > #str then error('Reached unexpected end of input.') end
  local pos = pos + #str:match('^%s*', pos)  -- Skip whitespace.
  local first = str:sub(pos, pos)
  if first == '{' then  -- Parse an object.
    local obj, key, delim_found = {}, true, true
    pos = pos + 1
    while true do
      key, pos = json_b.parse(str, pos, '}')
      if key == nil then return obj, pos end
      if not delim_found then error('Comma missing between object items.') end
      pos = skip_delim(str, pos, ':', true)  -- true -> error if missing.
      obj[key], pos = json_b.parse(str, pos)
      pos, delim_found = skip_delim(str, pos, ',')
    end
  elseif first == '[' then  -- Parse an array.
    local arr, val, delim_found = {}, true, true
    pos = pos + 1
    while true do
      val, pos = json_b.parse(str, pos, ']')
      if val == nil then return arr, pos end
      if not delim_found then error('Comma missing between array items.') end
      arr[#arr + 1] = val
      pos, delim_found = skip_delim(str, pos, ',')
    end
  elseif first == '"' then  -- Parse a string.
    return parse_str_val(str, pos + 1)
  elseif first == '-' or first:match('%d') then  -- Parse a number.
    return parse_num_val(str, pos)
  elseif first == end_delim then  -- End of an object or array.
    return nil, pos + 1
  else  -- Parse true, false, or null.
    local literals = {['true'] = true, ['false'] = false, ['null'] = json_b.null}
    for lit_str, lit_val in pairs(literals) do
      local lit_end = pos + #lit_str - 1
      if str:sub(pos, lit_end) == lit_str then return lit_val, lit_end + 1 end
    end
    local pos_info_str = 'position ' .. pos .. ': ' .. str:sub(pos, pos + 10)
    error('Invalid json_b syntax starting at ' .. pos_info_str)
  end
end

return json_b end)
package.preload['wssocket_parser'] = (function (...)

--WebSock = require "wssocket"
--require "variables_and_tables"
require "wssocket_command"
j_parser = require "json_b" 
require "utility"  
require "COMMANDS"
require "ksenia_status"  
--   $$$$$$\  $$$$$$$$\ $$\   $$\ $$$$$$$\  
--  $$  __$$\ $$  _____|$$$\  $$ |$$  __$$\ 
--  $$ /  \__|$$ |      $$$$\ $$ |$$ |  $$ |
--  \$$$$$$\  $$$$$\    $$ $$\$$ |$$ |  $$ |
--   \____$$\ $$  __|   $$ \$$$$ |$$ |  $$ |
--  $$\   $$ |$$ |      $$ |\$$$ |$$ |  $$ |
--  \$$$$$$  |$$$$$$$$\ $$ | \$$ |$$$$$$$  |
--   \______/ \________|\__|  \__|\_______/ 
--                                          
--   
function send_commands(k, idbind)
	if (type(k) == "table") then k, idbing = unpack(k) end
	kwLogTrace (6, "#socket #send #network"," send_commands("..(idbind or "No Idbind").." , "..(k or "No Message"))
	if COMMANDS[idbind] ~= nil then
		if COMMANDS[idbind][k] ~= nil then
			local data = COMMANDS[idbind][k] 
			kwLogTrace (6, "#socket #send #network"," send DATA: "..(data or "No Message"))
			LogTrace(">>>>>>>>>>Sending %s",data or "No Message")
			send_on_socket(data, TypeOfSocket[idbind])
		end
	else
		kwLogTrace (3, "#socket #send #network","COMMANDS > not binding ",k, idbind)
	end
end
-------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------
--  $$$$$$$\  $$$$$$$$\  $$$$$$\  $$$$$$$$\ $$$$$$\ $$\    $$\ $$$$$$$$\ $$$$$$$\  
--  $$  __$$\ $$  _____|$$  __$$\ $$  _____|\_$$  _|$$ |   $$ |$$  _____|$$  __$$\ 
--  $$ |  $$ |$$ |      $$ /  \__|$$ |        $$ |  $$ |   $$ |$$ |      $$ |  $$ |
--  $$$$$$$  |$$$$$\    $$ |      $$$$$\      $$ |  \$$\  $$  |$$$$$\    $$ |  $$ |
--  $$  __$$< $$  __|   $$ |      $$  __|     $$ |   \$$\$$  / $$  __|   $$ |  $$ |
--  $$ |  $$ |$$ |      $$ |  $$\ $$ |        $$ |    \$$$  /  $$ |      $$ |  $$ |
--  $$ |  $$ |$$$$$$$$\ \$$$$$$  |$$$$$$$$\ $$$$$$\    \$  /   $$$$$$$$\ $$$$$$$  |
--  \__|  \__|\________| \______/ \________|\______|    \_/    \________|\_______/ 
--                                                                                 
--                                                                                 
--                   
--chiamata quando ricevo un messaggio
function Ksenia_Parser(idbinding, strData)
	kwLogTrace (6, "#socket #parser #network","Ksenia_Parser("..idbinding.. ")")
	LogTrace("<<<<<<<<<<Received: %s",strData or "No Message")
	local tMessage_Received = {}
	local type_of_socket = TypeOfSocket[idbinding]

	if (type_of_socket == socket_type.user or type_of_socket == socket_type.installer) then
		timeOutTimer:KillTimer()
		setIsOnline()
		keepAliveTimer:StartTimer(pollingTimerPeriod)
	end

	tMessage_Received = j_parser.parse(strData)

	print_received_keywords(tMessage_Received, idbinding)


	kwLogTrace (5, "#socket #parser #network", tMessage_Received, type(tMessage_Received), tstring(tMessage_Received))
	if is_spontanea(tMessage_Received) then notify_changes(tMessage_Received)
	else parse_ksenia_protocol(tMessage_Received, idbinding) end
	tMessage_Received = nil

	if (LICENSE_MGR:isAbleToWork() ~= true) then 
		print("DRIVER NOT LICENSED!!! LICENSE STATE IS:", LICENSE_MGR:isLicenseActiveOrTrial())
		close_all_socket()
	end
end

function setIsOnline()
	if ISONLINE == false then
		SocketIsOpenOrInOpening = false
		create_queue_for_ReadFromPanel_commands(socket_type.installer)
	end
	ISONLINE = true
end

function parse_ksenia_protocol(message_received, idb)
	local type_of_socket = TypeOfSocket[idb]
	if (message_received.PAYLOAD ~= nil )then  --se ho il payload lavoro sulla risposta, se non lo ho seignifica che  la chiamata di quando si apre la socket
		parse_ksenia_message(message_received, idb)
		--qui iniziano i messagi da mandare alla ui 
		if (message_received.PAYLOAD.RESULT ~= nil) then 
			if (message_received.PAYLOAD.RESULT == FAIL) then 
				if (message_received.PAYLOAD.RESULT_DETAIL == LOGIN_KO) then 
					StartTmpTroubleCondition("LOGIN ERROR",5)
				elseif (message_received.PAYLOAD.RESULT_DETAIL == NOT_LOGGED) then 
					StartTmpTroubleCondition("Device Not Logged, reconnecting...",5)
					try_to_reconnect()
				else
					StartTmpTroubleCondition("COMMAND ERROR "..message_received.PAYLOAD.RESULT_DETAIL,5)
				end 
			end 	
		end 
		--------------------------------StartTroubleCondition(gScenarioActive)
		set_next_step(message_received, idb)
		
		if (actions[idb] ~= nil and actions[idb].nextStep ~= nil) then
			actions[idb].nextStep[1](unpack(actions[idb].nextStep[2]))
		end
	else
		do_next_step_login(idb)
	end
end

function do_next_step_login(idb)
	local type_of_socket = TypeOfSocket[idb]
	Update_tPAYLOAD_login(idb)
	Update_string_COMMANDS_login(idb)
	--actions[idb].nextStep(type_of_socket)
	if (type_of_socket == socket_type.installer and (actions[idb].nextStep == {} or actions[idb].nextStep == nil ))then 
		send_commands("LOGIN_INST", NumberOfSocket[socket_type.installer])
	else
		actions[idb].nextStep[1](unpack(actions[idb].nextStep[2]))
	end
end

function set_next_step(message_received, idb)
	local cmd_res = message_received.CMD or print("NOT CMD FOUND!!!") -- il comando a cui sto rispondendo
	local usr = ""
	local type_of_socket = TypeOfSocket[idb]

	if (cmd_res ~= nil and (type_of_socket == socket_type.installer or type_of_socket == socket_type.usr)) then
		if (cmd_res == "LOGIN_RES") then
			usr = message_received.PAYLOAD_TYPE
			create_queue_commands(usr)
			actions[idb].nextStep = queue_cmd[tRESPONSE[cmd_res]]
		elseif (cmd_res == tRESPONSE.READ_RES.CMD) then--se entro qui sto rispondendo ad una READ quindi devo capire cosa ho letto
			items_res = message_received.PAYLOAD_TYPE
			actions[idb].nextStep = {}
			actions[idb].nextStep = queue_cmd.READ_RES[tRESPONSE.READ_RES[items_res]]
		else 
			items_res = message_received.PAYLOAD_TYPE
			actions[idb].nextStep = {}
			actions[idb].nextStep = queue_cmd[tRESPONSE[cmd_res]]
		end
		--[[if (actions[idb].nextStep == {} or actions[idb].nextStep == nil )then 
			send_commands("LOGIN_INST", NumberOfSocket[socket_type.installer])
		end]]
	end
end 

function create_queue_commands(usr)
	if gNeedReadFromPanel == true then 
		create_queue_for_ReadFromPanel_commands(usr)
		--readFromPanelTimerExpired()
	else
		--readFromPanelTimerExpired()
		create_queue_for_ReadFromPanel_commands(usr)
		--create_queue_for_reconnection(usr)
	end
end

function parse_ksenia_message(message_received, idb)
	populate_KseniaSettings_by_idbinding(message_received, idb)
	local l = {}
	l = cleanUp_sender(message_received.PAYLOAD, idb)
	local t = {}
	t = create_number_key_table(l)
	update_table_B_in_A (KSENIAData['GlobalData']['ksenia'], t)	
	if message_received.PAYLOAD.STATUS_CONNECTION ~= nil then KSenia_item_handlers.STATUS_CONNECTION(message_received.PAYLOAD.STATUS_CONNECTION) end
	local type_of_socket = TypeOfSocket[idb]
	if is_user_or_installer(type_of_socket, message_received) then 
		Update_tPAYLOAD(idb)
		Update_string_COMMANDS(idb)
	else
		actions[idb].nextStep[1](unpack(actions[idb].nextStep[2]))
	end
end

function print_received_keywords(message_received, idbinding)
	local sMessage_Received = {}
	sMessage_Received = tstring(message_received, 2)
	kwLogTrace (6, "#socket #parser #network","print_received_keywords("..(message_received.CMD or "NO CMD").." - "..(message_received.PAYLOAD_TYPE or "NO PAYLOAD_TYPE").. ")")
end

function is_spontanea(message_received)
	local tmp = false
	if message_received.PAYLOAD_TYPE ~= nil and message_received.PAYLOAD_TYPE == "CHANGES" then
		tmp = true
	end
	return tmp
end

function is_user_or_installer(type, message_received )
	local tmp = false
	if message_received.PAYLOAD ~= nil then --mi serve per capire se sono nella risposta all'apertura della socket o  proprio un messaggio
		if (type == socket_type.installer or type == socket_type.user )then
			tmp = true
		end
	end
	return tmp
end

function populate_KseniaSettings_by_idbinding(message_received, idBind)
	if message_received.RECEIVER ~= nil then  --immagazzino il sender
		if (KseniaSettings[idBind] == nil) then KseniaSettings[idBind] = {} end
		KseniaSettings[idBind]["SENDER"] = message_received.RECEIVER
	end
	if message_received.PAYLOAD ~= nil then
		set_KseniaSettings(message_received.PAYLOAD, idBind) --mi prendo i dati della socket aperta  
	end
end
--popolo la tablla tSetting con i valori di t quando in tSetting gli indici di t esistono
function set_KseniaSettings(t, idbind)
	if (KseniaSettings[idbind] == nil) then KseniaSettings[idbind] = {} end
	for k, v in pairs(KS) do
		if t[k] ~= nil then  KseniaSettings[idbind][k] = t[k] end
	end
end

--lavoro sul payload di CHANGES che mi  arrivato
KSenia_item_handlers = {}
KSenia_item_handlers.STATUS_PARTITIONS = function(msg)
	kwLogTrace (6, "#socket #parser #network #partitions","KSenia_item_handlers.STATUS_PARTITIONS")
	for k, v in pairs(msg) do
		local id = tonumber(v["ID"]) or tonumber("n"..k)
		local tmp = {
			ID =  id,
			DES = v.DES or KSENIAData['ksenia']['partitions'][id].DES,
			AST = v.AST ,
			T = v.TIME,
			ARM = KSC4_PARTITION[v.ARM]	
		}
		KSENIAData['ksenia']['partitions'][id] = tmp
		setPartitionStatus(id)	
	end
end
KSenia_item_handlers.STATUS_SYSTEM = function(msg)
	kwLogTrace (6, "#socket #parser #network #system","KSenia_item_handlers.STATUS_SYSTEM")
	for k, v in pairs(msg) do
		local id = tonumber(v["ID"]) or tonumber("n"..k)
		if v.TEMP ~= nil then
			if KSENIAData['ksenia']['lares_status'] == nil then KSENIAData['ksenia']['lares_status'] = {} end
			if KSENIAData['ksenia']['lares_status']['TEMP'] == nil then KSENIAData['ksenia']['lares_status']['TEMP'] = {} end
			for i,j in pairs(v.TEMP) do
				KSENIAData['ksenia']['lares_status']['TEMP'][i] = j
			end
			put_in_queue(C4_SetVariable, {VARIABLE_NAME["TemperatureOut"], KSENIAData['ksenia']['lares_status']["TEMP"].OUT})
			put_in_queue(C4_SetVariable, {VARIABLE_NAME["TemperatureIn"], KSENIAData['ksenia']['lares_status']["TEMP"].IN})
			local tempOutNum = temperature_from_string(KSENIAData['ksenia']['lares_status']["TEMP"].OUT)
			local tempInNum = temperature_from_string(KSENIAData['ksenia']['lares_status']["TEMP"].IN)
			kwLogTrace (3, "#socket #parser #network #system","tempOutNum:"..tostring(tempOutNum))
			kwLogTrace (3, "#socket #parser #network #system","tempInNum:"..tostring(tempInNum))
			-- TO FIX! -- questo crea i casini segnalati da aliex 24-02-2022
			--put_in_queue(C4_SetVariable, {VARIABLE_NAME["TemperatureOutNumeric"], tempOutNum})
			--put_in_queue(C4_SetVariable, {VARIABLE_NAME["TemperatureInNumeric"],  tempInNum})
		end
		if v.ARM ~= nil and v.ARM.D ~= nil then
			gScenarioActive = v.ARM.D
			--local infoString = (v.ARM.D or "NO tmp.ARM.D").." as "..(v.ARM.S or "NO tmp.ARM.S")
			--print ("KSenia_item_handlers.STATUS_SYSTEM", infoString, tstring (v))
			StartTroubleCondition(gScenarioActive)
		end
		if KSENIAData['ksenia']['lares_status'] == nil or KSENIAData['ksenia']['lares_status']['TEMP'] == nil then
			if KSENIAData['ksenia']['lares_status'] == nil then KSENIAData['ksenia']['lares_status'] = {} end
			if KSENIAData['ksenia']['lares_status']['TEMP'] == nil then KSENIAData['ksenia']['lares_status']['TEMP'] = {} end
			KSENIAData['ksenia']['lares_status']["TEMP"].OUT = "No Temperature Device found"
			KSENIAData['ksenia']['lares_status']["TEMP"].IN = "No Temperature Device found"
		end
	end
end

KSenia_item_handlers.STATUS_CONNECTION = function(msg)
	kwLogTrace (6, "#socket #parser #network #connection","KSenia_item_handlers.STATUS_CONNECTION")
	for k, v in pairs(msg) do
		local id = tonumber(v["ID"]) or tonumber("n"..k)
		if v.MOBILE ~= nil then
			if KSENIAData['ksenia']['lares_status'] == nil then KSENIAData['ksenia']['lares_status'] = {} end
			if KSENIAData['ksenia']['lares_status']['MOBILE'] == nil then KSENIAData['ksenia']['lares_status']['MOBILE'] = {} end

			for i,j in pairs(v.MOBILE) do
				KSENIAData['ksenia']['lares_status']['MOBILE'][i] = j
			end
		else
			KSENIAData['ksenia']['lares_status']["MOBILE"].CARRIER = "No SIM found"
		end
	end
	C4:SetVariable(VARIABLE_NAME["SimSignal"], KSENIAData['ksenia']['lares_status']["MOBILE"].SIGNAL)
	C4:SetVariable(VARIABLE_NAME["GSM_OPERATOR"],KSENIAData['ksenia']['lares_status']["MOBILE"].CARRIER)
	local cre = tonumber(KSENIAData['ksenia']['lares_status']["MOBILE"].CRE) or 0
	C4:SetVariable(VARIABLE_NAME["Sim1_CREDIT"],cre)
end

KSenia_item_handlers.STATUS_ZONES = function(msg)
	kwLogTrace (6, "#socket #parser #network #zones","KSenia_item_handlers.STATUS_ZONES")
	for k, v in pairs(msg) do
		local id = tonumber(v["ID"]) or tonumber("n"..k)
		local tmp = {
			ID =  id,
			DES = v.DES or KSENIAData['ksenia']['zones'][id].DES,
			STA = KSC4_ZONE.STA[v.STA] ,
			T = v.T,
			BYP = KSC4_ZONE.BYP[v.BYP] or "",
			--PART =  KSENIAData['ksenia']['zones'][id].PART
		}
		if KSENIAData['ksenia']['zones'][id] == nil then KSENIAData['ksenia']['zones'][id] = {} end
		for k,v in pairs(tmp) do
			KSENIAData['ksenia']['zones'][id][k] = v
		end

		--KSENIAData['ksenia']['zones'][id] = tmp
		setZoneStatus(id)	
	end
end
KSenia_item_handlers.STATUS_OUTPUTS = function(msg)
	kwLogTrace (6, "#socket #parser #network #output","KSenia_item_handlers.STATUS_OUTPUTS")
	for k,v in pairs(msg) do 
		local id = tonumber(v.ID)
		--local des = v.DES
        --local cnv = v.CNV
		--local cat = v.CAT
		local sta = v.STA
		if (KSENIAData['ksenia']['outputs'][id] ~= nil) then
			if (KSENIAData['ksenia']['outputs'][id]['CAT'] == 'ROLL') then 
				--print ("\n\n\n")
				--print ("parsivico l'output di una tapparella, qui dovrei proprio mandare il messaggio verso il driver AUXI")
				--print ("POS:", v.POS)
				--print ("\n\n\n")
				KSENIAData['ksenia']['outputs'][id]['POS'] = v.POS

				local tAuxiht_message = {}
				local auxiht_table = {}
				local status = v.STA
				auxiht_table["status"] = tostring(v.STA)
				auxiht_table["position"] = tonumber(v.POS)
				auxiht_table["target_level"] = tonumber(v.POS)
				auxiht_table["timestamp"] = os.time()
				tAuxiht_message[id] = auxiht_table
				--Utility.tprint(tAuxiht_message)
				send_auxiht_states(tAuxiht_message)
				
			else
				local old_sta = KSENIAData['ksenia']['outputs'][id].STA
				for j, w in pairs(KSENIAData['ksenia']['outputs'][id])do
					KSENIAData['ksenia']['outputs'][id][j] = v[j] or KSENIAData['ksenia']['outputs'][id][j]
				end
				if old_sta ~= KSENIAData['ksenia']['outputs'][id].STA then 
					
					local varName = VARIABLE_NAME["Out"].. KSENIAData['ksenia']['outputs'][id].DES
					put_in_queue(C4_SetVariable, {tostring(varName),sta})

					--put_in_queue(ksAddVariable, {VARIABLE_NAME["Out"].. des,KSENIAData['ksenia']['outputs'][id].STA,"BOOL",0})
				end
				local contacts =  KSENIAData['ksenia']['outputs'][id].contacts

				if sta == "OFF" then -- chiuso, OKIO gestione ANALOG
					--outValue = "ON"
					--KSENIAData['ksenia']['outputs'][id].STA = sta 
					C4:SendToProxy(contacts, "OPENED",  "", "NOTIFY")
					LOGGER:debug("KSenia_item_handlers.STATUS_OUTPUTS() -> contacts:", contacts)
				elseif sta == "ON" then
					--outValue = "OFF"
					--KSENIAData['ksenia']['outputs'][id].STA = sta 
					C4:SendToProxy(contacts, "CLOSED",  "", "NOTIFY")
				end
			end
		else
			kwLogTrace (3, "#socket #parser #network #output","No Output Found, message parsed: ", tstring (msg,2))
		end
	end
end





--KSenia_item_handlers.STATUS_BUS_HA_SENSORS = function(msg)
	--kwLogTrace (6, "#socket #parser #network #output","KSenia_item_handlers.STATUS_BUS_HA_SENSORS")
	--[[
		1: number
		INFO: string
		ID: 2 
		SN: 001644 
		BUS: 1 
		STA: IL 
		DOMUS: string
		   TL: F 
		   PIR: NA 
		   TH: NA 
		   HUM: NA 
		   LHT: 3 
		   TEM: 24.5 
		FW: 0.0.30 
		TYP: DOMUS
	]]

	-- 	kwLogTrace (6, "#socket #changes #domus","auxi ht found!")
	-- KSENIAData['ksenia']['outputs'][id]['POS'] = v.POS
-- 
	-- local auxiht_table = {}
	-- local status = v.STA
-- 
	-- auxiht_table["status"] = tostring(v.STA)
	-- auxiht_table["position"] = tonumber(v.POS)
	-- auxiht_table["target_level"] = tonumber(v.POS)
	-- auxiht_table["timestamp"] = os.time()
	-- tAuxiht_message[sn] = auxiht_table
	-- Utility.tprint(tAuxiht_message)
	-- send_auxiht_states(tAuxiht_message)


--	local tAuxiht_message = {}
--	
--	for k,v in pairs(msg) do 
--		local auxiht_table = {}
--		local id = tonumber(v.ID)
--		local sn = tostring(v.SN)
--		--[[
--			"STA":"DEL| // Periferica non pi presente
--					A| // Periferica in attesa di indirizzamento
--					IN|, // Periferica in inizializzazione
--					U| // Periferica in aggiornamento firmware
--					L| // Periferica scomparsa (non pi attiva sul bus)
--					ILdomus_table["Periferica in normale funzionamento
--		]]
--		local status = v.STA
--		local fv_ver = v.FW
--		local sensor_type = v.TYP
--
--		if sensor_type == "DOMUS" and status == "IL" and v.DOMUS then
--			domus_table["temperature"] = temperature_from_string(v.DOMUS.TEM)
--			domus_table["temperature_scale"] = "celsius"
--			domus_table["humidity"] = tonumber(v.DOMUS.HUM)
--			domus_table["brightness"] = tonumber(v.DOMUS.LHT)  --espressa in lux
--			domus_table["motion"] = true_false_conversion_table[v.DOMUS.PIR]
--			domus_table["brightness_threshold"] = true_false_conversion_table[v.DOMUS.TL]
--			domus_table["humidity_threshold"] = true_false_conversion_table[v.DOMUS.TH]
--			domus_table["timestamp"] = os.time()
--			tDomus_message[sn] = domus_table
--		else
--			kwLogTrace (6, "#socket #changes #domus","message not valid. sensor_type="..tostring(sensor_type)..", status="..tostring(status)..", v.DOMUS="..tostring(v.DOMUS))
--		end
--	end
--	if tableLength(tDomus_message) > 0 then
--		send_domus_states(tDomus_message)
--	else
--		kwLogTrace (6, "#socket #changes #domus","not domus found"..msg)
--	end
--end


KSenia_item_handlers.STATUS_BUS_HA_SENSORS = function(msg)
	kwLogTrace (6, "#socket #parser #network #output","KSenia_item_handlers.STATUS_BUS_HA_SENSORS")
	--[[
		1: number
		INFO: string
		ID: 2 
		SN: 001644 
		BUS: 1 
		STA: IL 
		DOMUS: string
		   TL: F 
		   PIR: NA 
		   TH: NA 
		   HUM: NA 
		   LHT: 3 
		   TEM: 24.5 
		FW: 0.0.30 
		TYP: DOMUS
	]]
	local tDomus_message = {}
	true_false_conversion_table = {T= true, F= false}

	for k,v in pairs(msg) do 
		local domus_table = {}
		local id = tonumber(v.ID)
		local sn = tostring(v.SN)
		--[[
			"STA":"DEL| // Periferica non pi presente
					A| // Periferica in attesa di indirizzamento
					IN|, // Periferica in inizializzazione
					U| // Periferica in aggiornamento firmware
					L| // Periferica scomparsa (non pi attiva sul bus)
					ILdomus_table["Periferica in normale funzionamento
		]]
		local status = v.STA
		local fv_ver = v.FW
		local sensor_type = v.TYP

		if sensor_type == "DOMUS" and status == "IL" and v.DOMUS then
			domus_table["temperature"] = temperature_from_string(v.DOMUS.TEM)
			domus_table["temperature_scale"] = "celsius"
			domus_table["humidity"] = tonumber(v.DOMUS.HUM)
			domus_table["brightness"] = tonumber(v.DOMUS.LHT)  --espressa in lux
			domus_table["motion"] = true_false_conversion_table[v.DOMUS.PIR]
			domus_table["brightness_threshold"] = true_false_conversion_table[v.DOMUS.TL]
			domus_table["humidity_threshold"] = true_false_conversion_table[v.DOMUS.TH]
			domus_table["timestamp"] = os.time()
			tDomus_message[sn] = domus_table
		else
			kwLogTrace (6, "#socket #changes #domus","message not valid. sensor_type="..tostring(sensor_type)..", status="..tostring(status)..", v.DOMUS="..tostring(v.DOMUS))
		end
	end
	if tableLength(tDomus_message) > 0 then
		send_domus_states(tDomus_message)
	else
		kwLogTrace (6, "#socket #changes #domus","not domus found"..msg)
	end
end

KSenia_item_handlers.STATUS_BUS_IOS = function (msg)
	kwLogTrace (6, "message received from KSenia_item_handlers.STATUS_BUS_IOS")
	-- print ("---------------------")
	kwLogTrace (6, tstring(msg))
	-- print ("---------------------")
	for k,v in pairs(msg) do 
		local auxiht_table = {}
		local id = tonumber(v.ID)
		local sn = tostring(v.SN)
		local sensor_type = tostring(v.TYP)
		local status = v.STA
		local fv_ver = v.FW
		local bus_number = tonumber(v.BUS)
		local info = tostring(v.INFO)
		auxiht_table["id"] = id
		auxiht_table["sn"] = sn
		auxiht_table["sensor_type"] = sensor_type
		auxiht_table["status"] = status
		auxiht_table["fv_ver"] = fv_ver
		auxiht_table["bus_number"] = bus_number
		auxiht_table["info"] = info
		-- print (tstring(auxiht_table))
	end
end

KSenia_item_handlers.BUS_IOS = function(msg)
	kwLogTrace (6, "#socket #parser #network #output","KSenia_item_handlers.BUS_IOS")
	--{// identificativo modulo I/O
	--  "ID":"1..250", // intero da 1 a 250
	--  // descrizione
	--  "DES":"descrizione", // massimo 32 caratteri UTF8
	--  //tipo di periferica
	--  "TYP":"AUXI|AUXI10|AUXIRELE|AUXIHT"}
	-- print ("message received from KSenia_item_handlers.BUS_IOS")
	-- print ("---------------------")
	-- print (tstring(msg))
	-- print ("---------------------")
	for k,v in pairs(msg) do 
		local auxiht_table = {}
		local id = tonumber(v.ID)
		local des = tostring(v.DES)
		local sensor_type = tostring(v.TYP)
		auxiht_table["id"] = id
		auxiht_table["des"] = des
		auxiht_table["sensor_type"] = sensor_type
		kwLogTrace (6, tstring(auxiht_table))
	end
end



function send_auxiht_states(tAuxiht_message)
	local json_string = C4:JsonEncode(tAuxiht_message)
  C4:SendToProxy(KSENIA_AUXIHT_BINDINGID, "DATA_CHANGED", json_string, "NOTIFY")
end
function send_domus_states(tDomus_message)
	local json_string = C4:JsonEncode(tDomus_message)
  C4:SendToProxy(KSENIA_DOMUS_BINDINGID, "DATA_CHANGED", json_string, "NOTIFY")
end
function notify_changes(msg_received)
	local msg = {}
	msg = msg_received
	local receiver = msg.RECEIVER
	if msg.PAYLOAD[receiver] ~= nil then
		local pld = {}
		pld = msg.PAYLOAD[receiver]	
		local msg = ""
		for k, v in pairs(pld) do
			msg = msg ..", "..(k or "")
			if KSenia_item_handlers[k]~= nil then  KSenia_item_handlers[k](v) end
		end
		kwLogTrace (6, "#socket #changes #spontanea","notify_changes"..msg)
	end
end

--se il messaggio nel payload contiene il SENDER all'ora ritorno tutto quello a valle del SENDER
function cleanUp_sender(t, idbind)
	if t  ~= nil then
		for k, v in pairs(t) do
			if k == KseniaSettings[idbind]["SENDER"] then
				return v
			end
		end
	end
	return t
end

--ricreo una tabella dove l'indice e' l'ID
function create_number_key_table(t)
	local dst = {}
	if t  ~= nil then
		if type(t) == "table" then 
			for index, value in pairs(t) do
				if (value.ID ~= nil and tonumber(value.ID) ~= nil) then dst[tonumber(value.ID)] = value
				else dst[tostring(index)] = create_number_key_table(value) end
			end
		else 
			dst = t
		end
	end
	return dst
end

--aggiorna la tabella old con new
function update_table_B_in_A(old, new)--RECURSIVE_UPDATE_VALUES
	if (type(new) == "table") then
		for k,v in pairs(new) do
			k = tostring(k)
			if old[k] == nil then  
				old[k] = {}
			end
			if (type(v) == "table") then 
				update_table_B_in_A(old[k], v)
			else 
				old[k] = v
			end
		end
	end
end

--fa il merge di due tabelle scorrendole e andando a beccare il valore ID che coincide e se coincide unisce le sotto-tabelle
function merge_two_table_by_id(first, second)
	local third = {}
	if (first and second) then 
		for k,v in pairs (first) do 
			for j,i in pairs(second) do
				if i["ID"] == v["ID"] then 
					k = (tonumber(k) or k)
					third[k]={}
					for g,h in pairs(i) do--aggiungo i valori di second
						third[k][g] = h 
					end
					for g,h in pairs(v) do--aggiungo i valori di first
						third[k][g] = h 
					end
					break
				end
			end
		end
	else
		kwLogTrace (6, "#socket #parser #utility", "trying to merge 2 table by id, the first is %s, the second is %s", first, second)
	end
	return third
end

function removeSpecialChars(str)
	local cleanStr = str
	--tolgo tutti i caratteri speciali (comprese lettere accentate)
	cleanStr = string.gsub(cleanStr, "([^%w ])", "")
	-- tolgo anche tutti gli spazi
	cleanStr = string.gsub(cleanStr, " ", "")
	return cleanStr
end

function recreate_tPartitions(isUpdate)
	kwLogTrace(6,"#partition #create",'create_tPartitions')
	local f= {}
	f = KSENIAData['GlobalData']['ksenia']["STATUS_PARTITIONS"]
	local s= {}
	s = KSENIAData['GlobalData']['ksenia']["PARTITIONS"]
	if (f and s) then
		regeneratePartition(f, s, isUpdate)
	else
		kwLogTrace(6,"#partition #create", "PARTITIONS and STATUS_PARTITIONS == false")
	end
end

function recreate_tZones(isUpdate)
	kwLogTrace(6,"#zones #create",'create_tZones')

	local f= {}
	f = KSENIAData['GlobalData']['ksenia']["STATUS_ZONES"]
	local s= {}
	s = KSENIAData['GlobalData']['ksenia']["ZONES"]
	if (f and s) then
		regenerateZone(f, s, isUpdate)
	else
		kwLogTrace(6,"#zones #create","ZONES and STATUS_ZONES == false ")
	end
end
function recreate_tOutput(isUpdate)
	kwLogTrace(6,"#output #create",'create_tOutput')

	local f = {}
	f = KSENIAData['GlobalData']['ksenia']["STATUS_OUTPUTS"]
	local s = {}
	s = KSENIAData['GlobalData']['ksenia']["OUTPUTS"]
	if (f and s) then
		regenerateOutput(f, s, isUpdate)
	else
		kwLogTrace(6,"#output #create","OUTPUTS and STATUS_OUTPUTS == false ")
	end
end


function ZoneToPartition()
	kwLogTrace(6,"#zones #partitions #create",'ZoneToPartition')
	if (KSENIAData['GlobalData']['ksenia']["STATUS_PARTITIONS"] and KSENIAData['GlobalData']['ksenia']["PARTITIONS"] and KSENIAData['GlobalData']['ksenia']["STATUS_ZONES"] and KSENIAData['GlobalData']['ksenia']["ZONES"] and KSENIAData['GlobalData']['ksenia']['PRG_ZONES']) then
		
		local s = {}
		s = KSENIAData['GlobalData']['ksenia']['PRG_ZONES']--KSENIAData['GlobalData']['ksenia']["STATUS_PARTITIONS"]
		for k,v in pairs(s) do
			local z = tonumber(k)
			local part_mask = v.PRT
			local p = get_partition_from_mask(part_mask)
			kwLogTrace(6,"#zones #partitions #create","ZoneToPartition", z, p, KSENIAData['ksenia']['zones'][z] ~= nil)
			if KSENIAData['ksenia']['zones'][z] ~= nil and p ~= nil then 
				KSENIAData['ksenia']['zones'][z].PART = p 
			end
			AddZoneToPartition(p, z)
		end
	end 
end
function get_partition_from_mask(p_mask)
	return KseniaMaskPartition[tonumber(p_mask)] or 0
end 

function recreate_tScenarios()
	kwLogTrace(6,"#scenarios #create",'create_tScenarios')

	local f = {}
	f = KSENIAData['GlobalData']['ksenia']["SCENARIOS"]
	if (f) then
		regenerateScenarios(f)
	else
		kwLogTrace(6,"#scenarios #create","SCENARIOS  == nil ")
	end
end

function temperature_from_string(number_string, precision_digits)
	if (precision_digits==nil) then
		precision_digits = 1
	end
	local clean_str = string.gsub(number_string,"[.,]","") --remove all non digits
	local int_number = tonumber(clean_str) -- convert to number
	local ret_value = nil
	if (int_number) then
		ret_value = int_number / (math.pow(10,precision_digits)) -- scale to required precision
	end
	return ret_value
end


 end)
package.preload['wssocket_command'] = (function (...)

WebSock = require "wssocket"
require "variables_and_tables"


function open_socket(useCase)
	kwLogTrace (6, "#socket #open #network",'open_socket()'..(useCase or "NO useCase"))
	if DemoSocket == nil then 
		kwLogTrace (6, "#socket #open #network","DemoSocket == nil")
		DemoSocket = {} 
	end
    if (DemoSocket[useCase] ~= nil) then
		DemoSocket[useCase]:delete ()
		if (DemoSocket[useCase].ClosingTimer) then DemoSocket[useCase].ClosingTimer = DemoSocket[useCase].ClosingTimer:Cancel () print ("EXPIO self.ClosingTimer = self.ClosingTimer:Cancel ()") end
	end


	DemoSocket[useCase] = WebSock:new (KS.PROTOCOL, KS.IP_DEVICE, KS.HTTP_PORT, KS.RESOURCE)
	--for k,v in pairs(DemoSocket[useCase]) do print (k,v) end
	if useCase == socket_type.installer then DemoSocket[useCase]:Start(socket_number.installer) 
	elseif useCase == socket_type.user then DemoSocket[useCase]:Start(socket_number.user)
	else DemoSocket[useCase]:Start() end
	
	local idbind = DemoSocket[useCase].netBinding
	TypeOfSocket[idbind] = useCase --registro quel idbinding a che tipodi socket appartiene per sapere cosa farci con larisposta
	NumberOfSocket[useCase] = idbind

	Update_string_COMMANDS_login(idbind)

	local pm = function (self, idb, data) -- o metto ksenia_Parser al postro di function
		C4:UpdateProperty ('Message Received', data)
		Ksenia_Parser(idb, data)
	end

	DemoSocket[useCase]:SetProcessMessageFunction (pm) --o metto Ksenia_Parser al posto di pm

	local est = function (self, idb)
		kwLogTrace(3, "#socket #connection",'ws connection established')
		data =  GlobalString.ConnectionEstablished--'{"ws": "connection established"}'
		Ksenia_Parser(idb, data)
	end

	DemoSocket[useCase]:SetEstablishedFunction (est)

	local closed = function (self)
		kwLogTrace(3, "#socket #connection",'ws connection closed by remote host')
	end

	DemoSocket[useCase]:SetClosedByRemoteFunction (closed)

	local status = function (self,idb)
		kwLogTrace(3, "#socket #connection",'ws is Offline, trying to start() again: ', useCase)
		--fixme deleteme gl 2018
		if ((useCase == socket_type.installer) or (useCase == socket_type.user))then
			ISONLINE = false
			DemoSocket[useCase]:Start (NumberOfSocket[useCase])
		end 

		if ( DemoSocket[useCase].running == true)then 
			kwLogTrace(3, "#socket #connection",'ws is Offline, but running. Trying to start() again: ', useCase)
			ISONLINE = false
			DemoSocket[useCase]:Start (NumberOfSocket[useCase])
		else
			kwLogTrace(3, "#socket #connection",'ws is Offline, and Not Running: ', useCase)

		end
		if DemoSocket[useCase].header and DemoSocket[useCase].header['SEC-WEBSOCKET-ACCEPT'] == nil then
			StartTmpTroubleCondition("Ksenia socket is not avalaible!", messageValidityTime)
			SocketIsOpenOrInOpening = false  --16/11/18
		end
	end
	DemoSocket[useCase]:SetOfflineFunction(status)

	return idbind
end

function close_socket(useCase)
	kwLogTrace (6, "#socket #close #network", "Closing Socket..."..useCase)
	if (DemoSocket[useCase]) then
		--DemoSocket[useCase]:Close ()
		DemoSocket[useCase]:delete()
	end
end

function send_on_socket(value, useCase)
	--kwLogTrace (6, "#socket #send","send_on_socket(".. (useCase or "NO useCase")..")")
	if (DemoSocket[useCase] and value ~= '' and DemoSocket[useCase].running == true) then
		C4:UpdateProperty ('Message To Send', '')
		DemoSocket[useCase]:Send (value)
	elseif (not DemoSocket[useCase] or DemoSocket[useCase].running == false) then
		print ("Problem on Socket connection...Demosocket is", type(DemoSocket[useCase]) == "table", " user is", useCase )
		print ("Problem on Socket connection...Demosocket.running is", DemoSocket[useCase].running)
	elseif (DemoSocket[useCase] and value == '' and DemoSocket[useCase].running == true) then
		print ("send_on_soket nothing to send", value)
	end
end 

function check_online_status()
	local idBind = NumberOfSocket[socket_type.installer]
	if idBind ~= nil then
		send_commands("REALTIME", idBind)
		timeOutTimer:StartTimer()
	else
		print ("No open socket found, start read From Panel!!")
		readFromPanelTimer:StartTimer(3)
	end
end
 end)
package.preload['utility'] = (function (...)
--require "variables_and_tables"
--require "json" 


--//////////--//////////--//////////--//////////--//////////--//////////--//////////
--//////////--//////////--//////////--//////////--//////////--//////////--//////////
-- Lua table utils
--//////////--//////////--//////////--//////////--//////////--//////////--//////////
--//////////--//////////--//////////--//////////--//////////--//////////--//////////

function PrintTable(tValue, sIndent)
	sIndent = sIndent or '   '
	for k,v in pairs(tValue) do
		print(sIndent .. tostring(k) .. ':  ' .. tostring(v))
		if (type(v) == 'table') then
			PrintTable(v, sIndent .. '   ')
		end
	end
end

function tprint (tbl, indent)  --print table
	print (tstring(tbl, (indent or 2)))
end

function tstring (tbl, indent) -- transform table in string, nested
	--ritorna una stringa contenente i valori della table
    --if indent is -1 return a table in one line string
	local  mytable = ""
	if not indent then indent = 0 end
	if (type(tbl) == "table") then
		if (indent == -1) then 
			for k,v in pairs(tbl) do
				mytable = mytable.." "..v
			end
		else
			for k, v in pairs(tbl) do
				formatting = string.rep("   ", indent) .. k .. ": "
				if type(v) == "table" then
					formatting = formatting..type(k)
					mytable = mytable .. formatting
					mytable = mytable .."\n"..tstring(v, indent+1)
				else
					mytable = mytable .. formatting .. tostring(v) .." \n"
				end
			end
		end
	else

		mytable = tbl
	end
	return mytable
end



function AlphabeticalPairs(t, f)
	local a = {}

	for n in pairs(t) do
		table.insert(a, n)
	end

	table.sort(a, f)

	local index = 0      -- iterator variable
	local iter = function ()   -- iterator function
			index = index + 1
			if a[index] == nil then
				return nil
			else
				return a[index], t[a[index]]
			end
		end

	return iter
end

-- Be aware, this is really a hack. You could get the wrong key for a value,
-- especially if your data has duplicate values.
function AlphabeticalPairsByValue(t, f)
	local a = {}

	for k,v in pairs(t) do
		table.insert(a, v)
	end

	table.sort(a, f)

	local index = 0
	local iter = function()
			index = index + 1
			if a[index] == nil then
				return nil
			else
				for k,v in pairs(t) do
					if v == a[index] then
						return k, v
					end
				end
			end
		end

	return iter
end


function getC4version() -- example a = getC4version()  print(a["major"])
	local tVers = C4:GetVersionInfo()
	local strVers = tVers["version"]
	local major, minor, rev, build = string.match(strVers, "(%d+)\.(%d+)\.(%d+)\.(%d+)")
	local retVerTable = {}
	retVerTable["major"] = major
	retVerTable["minor"] = minor
	retVerTable["rev"] = rev
	retVerTable["build"] = build
	return retVerTable
end

function GetFormattedMacAddr()
	if cachedMACAddr == '' then
		local mac = C4:GetUniqueMAC()
		local macFormatted = ''
		for i=1,mac:len() do
			macFormatted = macFormatted .. mac:sub(i,i)
			if i % 2 == 0 and i ~= mac:len() then
				macFormatted = macFormatted .. ':'
			end
		end
		cachedMACAddr = macFormatted
	end
	return cachedMACAddr
end


function ReceivedAsync(ticketId, strData, responseCode, tHeaders, strError)
	local ticket = pullUrlTicket(ticketId)
	if (not ticket) then DbgSK("UNKNOWN TICKET | THROWING AWAY") return end
	if (strData) then DbgSK("[ReceivedAsync]: #" .. strData .. "#") end
	if (strError) then
		DbgSK("[ReceivedAsync]: ERROR | " .. strError)
		if (ticket.errorHandler and type(ticket.errorHandler) == 'function') then
			ticket.errorHandler(strError)
		end
		return
	end

	ticket.handler(strData, tHeaders)
end

function urlGet(url, headers, callback, errorHandler)
	local ticketId = C4:urlGet(url, headers)
	g_responseTickets[ticketId] = { handler = callback, errorHandler = errorHandler }
end

function urlPost(url, data, headers, callback, errorHandler)
	local ticketId = C4:urlPost(url, data, headers)
	g_responseTickets[ticketId] = { handler = callback, errorHandler = errorHandler }
end

function urlPut(url, data, headers, callback, errorHandler)
	local ticketId = C4:urlPut(url, data, headers)
	g_responseTickets[ticketId] = { handler = callback, errorHandler = errorHandler }
end

function urlEncode(str)
	return str:gsub(" ","+"):gsub("\n","\r\n"):gsub("([^%w])",function(ch)
			return string.format("%%%02X",string.byte(ch))
		end)
end

function pullUrlTicket(ticketId)
	local ticket = g_responseTickets[ticketId]
	g_responseTickets[ticketId] = nil
	return ticket
end

--------------------------------------------------------timer
g_timers={}
function startTimer(value, units, callback)
	local timerId = C4:AddTimer(tonumber(value), units)
	g_timers[timerId] = { handler = callback }
	return timerId
end

function pullTimer(timerId)
	local timer = g_timers[timerId]
	g_timers[timerId] = nil
	return timer
end

function killTimer(timerId)
	local timer = g_timers[timerId]
	g_timers[timerId] = nil
	if tonumber(timerId) > 0 then
		C4:KillTimer(timerId)
	end
	return timer
end


--calcolo CRC16--BEGIN
local bxor, band, rshift, lshift = bit.bxor, bit.band, bit.rshift, bit.lshift
function toBits(num)
    -- returns a table of bits, least significant first.
    local t={} -- will contain the bits
    while num>0 do
        rest=math.fmod(num,2)
        t[#t+1]=rest
        num=(num-rest)/2
	end
	s = table.concat(t,"")
    return string.reverse(s)
end
function pb(name, num)
 print (name, num, toBits(num))
end

local mask = 0xFFFF

function create_CRC(s)
	local seme = 0xFFFF
	local gen_poly = 0x1021
	local crc = seme
	if s then
		for i = 1, #s do
			local pData = s:byte(i)
			i_CRC = 0x80
			for j = 1, 8 do
				--pb("pData ",pData)
				--pb( "i_CRC ", i_CRC)
				flag_CRC = band(crc, 0x8000)
				--pb("flag_CRC",flag_CRC)
				crc = lshift(crc,1) 
				crc = band(crc, mask)
				--pb( "crc", crc)
				if ( band(pData, i_CRC)>0) then
					crc = crc + 1
					--pb( "crc ++ ", crc)
				end
				if(flag_CRC > 0)then
					crc = bxor(crc, gen_poly)
					--pb( "crcxo", crc)
				end
				i_CRC= rshift(i_CRC, 1)
			end
		end
	end
	return string.format("%04X",crc)
end
--calcolo CRC16--END

scrivi = true
function DbgSK(arg,arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8  )
    if scrivi then
		print (arg,arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8)
	end
end

function len(w)
	if type(w) =="string" then return string.len(w)
	elseif type(w) =="table" then
		k=0
		for j,i in pairs(w) do k = k+1 end 
		return k
	else
		return type(w)
	end
end


 end)
package.preload['timer_expired'] = (function (...)
function sendExtraInfoTimerExpired ()
    usercode = nil
	blindedCode = nil
	MemorizedPIN = nil 
	if timerTable[sendExtraInfoTimer._id] ~= nil then
		kwLogTrace(6, "#UI #TimerExpired #PIN","sendExtraInfoTimer Expired with _id: "..sendExtraInfoTimer._id.. " on partition " ..timerTable[sendExtraInfoTimer._id]["partitionID"])
		DisplayPartitionText(timerTable[sendExtraInfoTimer._id]["partitionID"], "")  
	end
	timerTable[sendExtraInfoTimer._id] = nil
end



function tPartitionUITimerExpired(expPartID)
	kwLogTrace(5, "#UI #TimerExpired #partitionID","tPartitionUITimerExpired "..expPartID)
	indexList = nil
	selectedScenario = nil
	DisplayPartitionText(expPartID, "")
end
    
function OnSendToUITimerExpired() 
	kwLogTrace(6, "#UI #TimerExpired #PIN",">>>>>>>>>>>>>>>>>>>>>>>>>OnSendToUITimerExpired>>>>>>>>>>>>>>>>>>>>>>>>>>>>>")
	usercode = nil
	blindedCode = nil
	MemorizedPIN = nil 
	selectedScenario = nil
	OLD_IntfcID = ""
	if timerTable[SendToUITimer._id] ~= nil then
		kwLogTrace(6, "#UI #TimerExpired #PIN","SendToUITimer Expired with _id: "..SendToUITimer._id.. " on partition " ..timerTable[SendToUITimer._id]["partitionID"])
		DisplayPartitionText(timerTable[SendToUITimer._id]["partitionID"], "")  
	end
	timerTable[SendToUITimer._id] = nil
	troubleClearTimerExpired()
end

function troubleClearTimerExpired()
	OLD_IntfcID = ""
	ClearTroubleCondition(1)
	
	StartTroubleCondition(gScenarioActive)
end
   

function keepAliveTimerExpired()
    local idBind = NumberOfSocket[socket_type.installer]
	--send_commands("REALTIME", idBind)
	check_online_status()
	keepAliveTimer:StartTimer(pollingTimerPeriod)
end
function pollingOffTimerExpired()
	local t = 5
	C4:UpdateProperty(KS_PROP["POLLING"], t)
	kwLogTrace(3, "#UI #TimerExpired #polling", "Polling Time setted to "..t.." minutes")
	check_online_status()
	keepAliveTimer:StartTimer(t)
end 

function timeOutTimerExpired()
	kwLogTrace(3, "#UI #TimerExpired #timeout","Connection Time Out!")
	ISONLINE = false
	try_to_reconnect()
end 

function try_to_reconnect()
	for k,v in pairs(TypeOfSocket) do
		send_commands("LOGOUT", k)
		close_socket(v)
	end
	readKseniaConf()
end


 end)
package.preload['timer_expired_init'] = (function (...)
lapse = 1


do	
	TimerExpired = {}
end


function readFromPanelTimerExpired(callback)
    if (LICENSE_MGR:isAbleToWork())then
        queue_timeLapse = 200
        create_queue_for_ReadFromPanel_commands(socket_type.installer)
        queue_cmd.first[1]((unpack(queue_cmd.first[2]) or nil))
    else
        print("DRIVER NOT LICENSED!!! LICENSE STATE IS:", LICENSE_MGR:isLicenseActiveOrTrial())
        print("CAN NOT PERFORM READ FROM PANEL")
    end
end
function open_socket_installer ()
    local idb = open_socket(socket_type.installer)
    if actions == nil then actions = {} end 
    if actions[idb] == nil then  actions[idb] = {} end
    actions[idb].nextStep = {send_commands,{"LOGIN_INST", NumberOfSocket[socket_type.installer]}}
end

function create_KseniaConfiguration(idBind)
    kwLogTrace(6, "#readconf #TimerExpired #ksenia","create_KseniaConfiguration: "..(idBind or "No idBind"))
    
    recreate_tPartitions(false)
    recreate_tZones(false)
    recreate_tScenarios(false)
    recreate_tOutput(false)
    ZoneToPartition()
    --local data = os.date("%d/%m/%Y %X")
    --local msg = "lares4 Ksenia Updated on "..data
    --C4:UpdateProperty(KS_PROP["LAST_UPDATE"], msg)
       
end

function update_KseniaConfiguration(idBind)
    kwLogTrace(6, "#readconf #update #ksenia","update_KseniaConfiguration: "..(idBind or "No idBind"))
    recreate_tPartitions(true)
    recreate_tZones(true)
    recreate_tScenarios(true)
    recreate_tOutput(true)
    --ZoneToPartition()
    --local data = os.date("%d/%m/%Y %X")
    --local msg = "READ FROM PANEL STARTED AT: "..data
    --C4:UpdateProperty(KS_PROP["LAST_UPDATE"], msg)
    send_commands("REALTIME", idBind)
    gNeedReadFromPanel = false 

end
function create_queue_for_ReadFromPanel_commands(usr)
    kwLogTrace(6, "#readconf #update #ksenia","create_queue_for_ReadFromPanel_commands: "..(usr or "No usr"))

    local tReadFromPanel = {}
    if usr ~= nil then
        if usr == socket_type.installer then 
            tReadFromPanel.login = {send_commands,{"PRG_ZONES", NumberOfSocket[socket_type.installer]}}
        elseif usr == socket_type.user then
            tReadFromPanel.login = {send_commands, {"READALL", NumberOfSocket[socket_type.installer]}}
        end
    end
    --tReadFromPanel.login = {send_commands,{"PRG_ZONES", NumberOfSocket[socket_type.installer]}}

    tReadFromPanel.first = {open_socket_installer,{}}
    tReadFromPanel.READ_RES = {}
    tReadFromPanel.READ_RES.read_zones = {send_commands,{"PRG_PARTITIONS",  NumberOfSocket[socket_type.installer]}}
    tReadFromPanel.READ_RES.read_partitions = {send_commands, {"PRG_OUTPUTS",  NumberOfSocket[socket_type.installer]}}
    tReadFromPanel.READ_RES.read_outputs = {send_commands, {"LOGOUT_INST", NumberOfSocket[socket_type.installer]}}
    tReadFromPanel.logout = {send_commands, {"LOGIN", NumberOfSocket[socket_type.installer]}}
  --  tReadFromPanel.READ_RES.read_outputs = {send_commands, {"READALL", NumberOfSocket[socket_type.installer]}}
    tReadFromPanel.READ_RES.read_all = {create_KseniaConfiguration,{NumberOfSocket[socket_type.installer]}}
    tReadFromPanel.READ_RES.realtime = {print ,{"realtime_readed END OF CONFIG", ""}}
    queue_cmd = tReadFromPanel
end

function create_queue_for_reconnection(usr)
    kwLogTrace(5, "#Queue #reconnection", "create_queue_for_reconnection(",usr,")")
    local idb =  NumberOfSocket[socket_type.installer]
    local tReconnection = {}
    tReconnection.login = {send_commands, {"READALL", NumberOfSocket[socket_type.installer]}}
    tReconnection.READ_RES = {}
    tReconnection.READ_RES.read_all = {update_KseniaConfiguration,{NumberOfSocket[socket_type.installer]}}
    queue_cmd = tReconnection
    if actions == nil then actions = {} end 
    if actions[idb] == nil then  actions[idb] = {} end
    actions[idb].nextStep = {send_commands,{"LOGIN", NumberOfSocket[socket_type.installer]}}
end

--[[
function wstart_installer()
    --Timer.open_socket_installer = Common.AddTimer (Timer.open_socket_installer, lapse,  "SECONDS", false)
    readFromPanelTimer:StartTimerWithCallbackParams("open_socket_installer")
end

function TimerExpired.open_socket_installer ()
    local idb = open_socket(socket_type.installer)
    if actions == nil then actions = {} end 
    if actions[idb] == nil then  actions[idb] = {} end
    actions[idb].nextStep = TimerExpired.login_installer
end

function TimerExpired.login_installer ()
    local idBind = NumberOfSocket[socket_type.installer]
    send_commands("LOGIN_INST",idBind)
    --Timer.read = Common.AddTimer (Timer.read, lapse,  "SECONDS", false)
    readFromPanelTimer:StartTimerWithCallbackParams("read")

end

function TimerExpired.read ()
    local idBind = NumberOfSocket[socket_type.installer]
    send_commands("PRG_ZONES", idBind)
    --Timer.inst_partitions = Common.AddTimer (Timer.zones_and_partitions, lapse,  "SECONDS", false)
    readFromPanelTimer:StartTimerWithCallbackParams("inst_partitions")

end

function TimerExpired.inst_partitions ()
    local idBind = NumberOfSocket[socket_type.installer]
    send_commands("PRG_PARTITIONS", idBind)
    --Timer.inst_outputs = Common.AddTimer (Timer.inst_outputs, lapse,  "SECONDS", false)
    readFromPanelTimer:StartTimerWithCallbackParams("inst_outputs")

end

function TimerExpired.inst_outputs ()
    local idBind = NumberOfSocket[socket_type.installer]
    send_commands("PRG_OUTPUTS", idBind)
    --Timer.inst_logout = Common.AddTimer (Timer.inst_logout, lapse,  "SECONDS", false)
    readFromPanelTimer:StartTimerWithCallbackParams("inst_logout")
end

function TimerExpired.inst_logout()
    local idBind = NumberOfSocket[socket_type.installer]
    send_commands("LOGOUT", idBind)
    close_socket(socket_type.installer)
    open_socket(socket_type.user)
    local idb = open_socket(socket_type.user)
    if actions == nil then actions = {} end
    if actions[idb] == nil then  actions[idb] = {} end
    actions[idb].nextStep = TimerExpired.user_login
end

function TimerExpired.user_login()
    local idBind = NumberOfSocket[socket_type.user]
    send_commands("LOGIN", idBind)
    readFromPanelTimer:StartTimerWithCallbackParams("readzones")
end

function TimerExpired.user_login_only()
    local idBind = NumberOfSocket[socket_type.user]
    send_commands("LOGIN", idBind)
    --Timer.realtime = Common.AddTimer (Timer.realtime, lapse,  "SECONDS", false)
    readFromPanelTimer:StartTimerWithCallbackParams("realtime")

end

function TimerExpired.readzones ()
    local idBind = NumberOfSocket[socket_type.user]
    send_commands("READALL", idBind)
    --Timer.zones_and_partitions = Common.AddTimer (Timer.zones_and_partitions, lapse*2,  "SECONDS", false)
    readFromPanelTimer:StartTimerWithCallbackParams("zones_and_partitions")
end

function TimerExpired.zones_and_partitions ()
    create_tPartitions()
    create_tZones()
    create_tScenarios()
    create_tOutput()
    --Timer.zone_to_partition = Common.AddTimer (Timer.zone_to_partition, lapse*2,  "SECONDS", false)
    readFromPanelTimer:StartTimerWithCallbackParams("zone_to_partition")

end

function TimerExpired.zone_to_partition()
    ZoneToPartition()
    --Timer.realtime = Common.AddTimer (Timer.realtime, lapse,  "SECONDS", false)
    readFromPanelTimer:StartTimerWithCallbackParams("realtime")

end

function TimerExpired.realtime ()
    local idBind = NumberOfSocket[socket_type.user]
    send_commands("REALTIME", idBind)
    keepAliveTimer:StartTimer()

    --Timer.last_init = Common.AddTimer (Timer.last_init, lapse*5,  "SECONDS", false)
   -- readFromPanelTimer:StartTimerWithCallbackParams("last_init")
    actions[idBind].nextStep = TimerExpired.latelogin
end

function TimerExpired.latelogin ()
    local idBind = NumberOfSocket[socket_type.user]
    send_commands("LOGIN", idBind)
    readFromPanelTimer:StartTimerWithCallbackParams("realtime")
end

function TimerExpired.last_init() --questo timer me lo porto dietro per il debug... mi dice quando ho finito di fare tutte le azioni automatiche
    DbgSK("timer_expired.last_init ()")
    DbgSK('           ----------------------------------------------------------------------------------------------------------- \
----------------------------------------------------------------------------------------------------------- \
/$$$$$$$$ /$$   /$$ /$$$$$$$        /$$$$$$ /$$   /$$ /$$$$$$ /$$$$$$$$\
| $$_____/| $$$ | $$| $$__  $$      |_  $$_/| $$$ | $$|_  $$_/|__  $$__/\
| $$      | $$$$| $$| $$  \\ $$        | $$  | $$$$| $$  | $$     | $$   \
| $$$$$   | $$ $$ $$| $$  | $$        | $$  | $$ $$ $$  | $$     | $$   \
| $$__/   | $$  $$$$| $$  | $$        | $$  | $$  $$$$  | $$     | $$   \
| $$      | $$\\  $$$| $$  | $$        | $$  | $$\\  $$$  | $$     | $$   \
| $$$$$$$$| $$ \\  $$| $$$$$$$/       /$$$$$$| $$ \\  $$ /$$$$$$   | $$   \
|________/|__/  \\__/|_______/       |______/|__/  \\__/|______/   |__/   \
-----------------------------------------------------------------------------------------------------------\
-----------------------------------------------------------------------------------------------------------\
-----------------------------------------------------------------------------------------------------------') 
end
]]
 end)
package.preload['fast_function_to_debug'] = (function (...)
fast = {}

-- function fast.Ione()
--     print ("IpartOne")
--     send_commands("A_PART_1")
-- end

-- function fast.Done()
--     print ("DpartOne")
--     send_commands("D_PART_1")
-- end


-- function fast.rinit()
--     print("restart_init")
--     send_commands("LOGOUT")
--     send_commands("LOGOUT_INST")
--     Timer.close_sock_init=Common.AddTimer (Timer.close_sock_init, 2, "SECONDS", false)
-- end
-- function TimerExpired.close_sock_init () 
--     print(" TimerExpired.close_sock_init")

--     close_socket() 
--     wstart_installer()
-- end
-- function fast.rtime()
--     print("realtime")
--     send_commands("REALTIME")
-- end

-- function fast.Aclose()
--     print("Aclose")
--     send_commands("LOGOUT")
--     Timer.close_lout=Common.AddTimer (Timer.close_lout, 1, "SECONDS", false)
-- end
-- function TimerExpired.close_lout () 
--     print(" TimerExpired.close_lout")
--     send_commands("LOGOUT_INST")
--     Timer.close_sock=Common.AddTimer (Timer.close_sock, 1, "SECONDS", false)
-- end
-- function TimerExpired.close_sock () 
--     print(" TimerExpired.close_lout")

--     close_socket() 
-- end


-- function fast.part()
--     print (tstring(KSENIAData['ksenia']['partitions'],2))
-- end

-- function fast.zon()
--     print (tstring(KSENIAData['ksenia']['zones'],2))
-- end
fast.global = {}
fast.global = KSENIAData['GlobalData']['ksenia']

interval = 5

function fast.openCmdSocket(pin, command, ksID)
    print ("fast.openCmdSocket(",pin, command, ksID,")")
    Timer.arm_socket = Common.AddTimer (Timer.arm_socket, interval, "SECONDS", false)
    pin_to_arm = {}
    pin_to_arm.PIN = pin
    partition_to_arm = {}
    partition_to_arm[1] = { ID = tostring(ksID) or "" }
    partition_to_arm[2] = { MOD = "I" }
    open_socket(command)

   
    --fast.setpart(ksID, pin, command)
    --local idBind = NumberOfSocket[socket_type.cmd]
    --COMMANDS[idBind]["LOGIN_PRT"] = create_cmd(tCmd.login, tPAYLOAD.LOGIN_PRT, tPayloadType.ergo.name, idBind)
end
function TimerExpired.arm_socket()
    kwLogTrace(6, "#timer  #arm","timer_expired.arm_socket ()")
    ---open_socket("Arm")    
    local idBind = NumberOfSocket[socket_type.cmd]

    --fast.setpart(ksID, UserCod, socket_type.cmd)

    COMMANDS[idBind]["LOGIN_PRT"] = create_cmd(tCmd.login, pin_to_arm, tPayloadType.user.name, idBind)
    --print (COMMANDS[idBind]["LOGIN_PRT"])
    Timer.arm_login = Common.AddTimer (Timer.arm_login, interval, "SECONDS", false)
end
function TimerExpired.arm_login()
    kwLogTrace(6, "#timer  #arm","timer_expired.arm_login ()")
    local idBind = NumberOfSocket[socket_type.cmd]
    send_commands("LOGIN_PRT", idBind)
    Timer.arm_cmd = Common.AddTimer (Timer.arm_cmd, interval, "SECONDS", false)
end
function TimerExpired.arm_cmd()
    kwLogTrace(6, "#timer  #arm","timer_expired.arm_cmd ()")
    
    local idBind = NumberOfSocket[socket_type.cmd]
    
    send_commands("A_PART", idBind)
    
    
    local cmd = "I"

    -- if fast[cmd] ~= nil then 
    --     fast[cmd]() 
    --     local status, err = pcall(fast[cmd])
    --     if (not status) then
    --         print("LUA_ERROR: " .. err)
    --     end
    -- end
    Timer.arm_logout = Common.AddTimer (Timer.arm_logout, interval*2, "SECONDS", false)
end
function TimerExpired.arm_logout()
    kwLogTrace(6, "#timer  #arm","timer_expired.arm_logout ()")
    local idBind = NumberOfSocket[socket_type.cmd]
    send_commands("LOGOUT", idBind)
    close_socket(socket_type.cmd)
end
--armo disarmo agisco sulla partizione
function fast.setpart(id, pin, command)
    if pin ~= nil then print ("fast.setpart -> pin: ",pin, command, id)
    else print ("fast.setpart -> using usercode pin", pin, command, id)end
    
    local idbinding = NumberOfSocket[command]
    print ("idbinding dentro fast.setpart>>>>>>>>>>>><<", idbinding)

    tPAYLOAD.A_PART = {}
    tPAYLOAD.A_PART[1] = { ID_LOGIN = KseniaSettings[idbinding]["ID_LOGIN"] }
    tPAYLOAD.A_PART[2] = { PIN = pin_to_arm.PIN }
    local partition = {}
    partition[1] = { ID = tostring(id) or "" }
    partition[2] = { MOD = "I" }
    print (partition_to_arm or "---NO PARTITION TO ARM---")
    tPAYLOAD.A_PART[3] = { PARTITION = partition_to_arm or partition }
    
    tPAYLOAD.D_PART = {}
    tPAYLOAD.D_PART[1] = { ID_LOGIN = KseniaSettings[idbinding]["ID_LOGIN"] }
    tPAYLOAD.D_PART[2] = { PIN = pin_to_arm.PIN }
    local partition = {}
    partition[1] = { ID = tostring(id) or "" }
    partition[2] = { MOD = "D" }
    tPAYLOAD.D_PART[3] = { PARTITION = partition }

    COMMANDS[idbinding]["A_PART"] = create_cmd(tCmd.cmduser, tPAYLOAD.A_PART , tPayloadType.arm_partition, idbinding)
    COMMANDS[idbinding]["D_PART"] = create_cmd(tCmd.cmduser, tPAYLOAD.D_PART , tPayloadType.arm_partition, idbinding)
    print ("COMMANDS.A_PART", COMMANDS.A_PART)
    print ("COMMANDS.D_PART", COMMANDS.D_PART)
end


function fast.Iset()
    print ("fast.Iset")
    send_commands("I_PART")
end
function fast.Dset()
    print ("fast.Dset")
    send_commands("D_PART")
end
function fast.I()
print ("fast.I")
send_commands("A_PART")
end
function fast.D()
print ("fast.D")
send_commands("D_PART")
end



function sayfast()
   for k,v in pairs(fast) do
    print (k,v)
   end
end  end)
package.preload['action_on_partitions'] = (function (...)
actions = {}

timer_interval = 5

function actions.openCmdSocket(pin, command, ksID, action)
    if SocketIsOpenOrInOpening == false then
        SocketIsOpenOrInOpening = true -- da valorizzare a false quando sono OFFLINE (FIXME forse qui: c4_device_connection_base.lua riga 498 >> SocketIsOpenOrInOpening == false e per non saper ne leggere ne scrivere anche qui variables_and_tables.lua riga 38 )
        kwLogTrace(6,"#open #socket #UI", "actions.openCmdSocket("..(pin or "No Pin").." - "..   (command or "No Command").." - ".. (ksID or "No KSID").." - ".. (action or "No Action")..")")
        check_online_status()
        if command == socket_type.part then actions.set_partition_settings(pin, ksID, action)
        elseif command == socket_type.scenario then actions.set_scenario_settings(pin, ksID)
        elseif command == socket_type.output then actions.set_output_settings(pin, ksID, action)
        elseif command == socket_type.auxi then actions.set_output_settings(pin, ksID, action)
        elseif command == socket_type.bypass then actions.set_bypass_settings(pin, ksID, action) end

        local idBind = open_socket(command)--NumberOfSocket[command]    
        if actions[idBind] == nil then  actions[idBind] = {} end
        actions[idBind].status = 1  --ho aperto la socket passo a fare il login
        actions[idBind].nextStep = {actions[command], {command}}--imposto in questa funzione cosa dovr fare la socket, armare partizioni o scenari etc...                                         --per non portarmi dietro troppe informazioni maracchuderle nelle funzioni stesse
        actions[idBind].name = command
  	else
        put_in_queue(actions.openCmdSocket, {pin, command, ksID, action})
        kwLogTrace(6,"#open #socket #UI", "Socket in queue, socket: "..(tostring(SocketIsOpenOrInOpening) or "not open"))
    end
end

pin_to_arm = {}

function  actions.set_partition_settings(pin, ksID, action)
    pin_to_arm.PIN = pin
    partition_to_arm = {}
    partition_to_arm[1] = { ID = tostring(ksID) or "" }
    partition_to_arm[2] = { MOD = action}
end

function actions.set_scenario_settings(pin, ksID)
    pin_to_arm.PIN = pin
    pin_to_fire = {}
    pin_to_fire.PIN = pin
    scenario_to_fire = {}
    scenario_to_fire[1] = { ID = tostring(ksID) or "" }
end

function actions.PART(command)
    local idbinding = NumberOfSocket[command]
    kwLogTrace(6,"#partition #command #UI", "actions.PART(".. (command or " NO COMMAND ").."-"..(actions[idbinding].status or " NO STATUS ")..")")
    kwLogTrace(6,"#partition #command #UI", "actions.PART(partition to arm: "..partition_to_arm[1].ID or " NO PARTITION "..")")
    
    if ( actions[idbinding].status == 1) then 
        actions.fire_login(idbinding)
        actions[idbinding].status = 2  --fatto il login passo ad inviare il comando

    elseif actions[idbinding].status == 2 then 
        if partition_to_arm[1].ID == Arm_all_partitions then --se sono in Arm All allora creo questo ciclo su tutte le part
           actions.fire_all_partitions(idbinding)
        else
            actions.fire_partition_command(idbinding) 
            actions[idbinding].status = 3
        end
    elseif actions[idbinding].status == 3 then
        actions[idbinding].nextStep = nil
        actions.fire_logout(idbinding)
    end
end 

function actions.fire_login(idb)
    COMMANDS[idb]["LOGIN_PRT"] = create_cmd(tCmd.login, pin_to_arm, tPayloadType.usr.name, idb)
    send_commands("LOGIN_PRT", idb)
end

function actions.fire_partition_command(idb)
    local pin_in_use = pin_to_arm.PIN
    local partition_in_use = partition_to_arm  -- ho definito in set_partition_settings i messaggi corrispondenti ad ogni partizione
    actions.set_partition_payload(idb, pin_in_use, partition_in_use)
    COMMANDS[idb]["CMD_PART"] = create_cmd(tCmd.cmduser, tPAYLOAD.CMD_PART , tPayloadType.arm_partition, idb) 
    send_commands("CMD_PART", idb )
end
function actions.fire_logout(idb)
    SocketIsOpenOrInOpening = false
    send_commands("LOGOUT", idb )
    close_socket(TypeOfSocket[idb])
    actions[idb].status = 0
    actions[idb].status = nil
    actions[idb] = nil
end
function  actions.fire_all_partitions(idb)
    if Index_to_arm_all_partitions == nil then Index_to_arm_all_partitions = 0 end  --lo definisco, prima di uscire dall'armall lo rimetto a nil
    if Index_to_arm_all_partitions == 0 then actions.set_all_partitions_command() end  --se  uguale a 0(primo giro) mi creo i messaggi da mandare per tutte le partizioni
    local pin_in_use = pin_to_arm.PIN
    local partition_in_use = partitions_to_arm[Index_to_arm_all_partitions]  -- ho definito in set_all_partitions_command i messaggi corrispondenti ad ogni partizione
    actions.set_partition_payload(idb, pin_in_use, partition_in_use)
    COMMANDS[idb]["CMD_PART"] = create_cmd(tCmd.cmduser, tPAYLOAD.CMD_PART , tPayloadType.arm_partition, idb)
    --armAllPArtitionTimer = c4_timer:new("armAllPArtitionTimer", 200, "MILLISECONDS",send_commands, false, {"CMD_PART", idb })
    --armAllPArtitionTimer:StartTimer()
    send_commands("CMD_PART", idb )
    if Index_to_arm_all_partitions == max_Index_to_arm_all_partitions then 
        actions[idb].status = 3
        partitions_to_arm = nil
        Index_to_arm_all_partitions = nil
    else
        Index_to_arm_all_partitions = Index_to_arm_all_partitions + 1
    end
end

function actions.set_all_partitions_command()
    for k,v in pairs(KSENIAData['ksenia']['partitions']) do
        if Index_to_arm_all_partitions == 0 then Index_to_arm_all_partitions = k end
        max_Index_to_arm_all_partitions = k
        local part = {}
        part[1] = { ID = tostring(k   ) or "" }
        part[2] = { MOD = partition_to_arm[2].MOD }
        partitions_to_arm[k] = part
    end 
end
function actions.set_partition_payload(idb, pin, partitions)
    tPAYLOAD.CMD_PART = {}
    tPAYLOAD.CMD_PART[1] = { ID_LOGIN = KseniaSettings[idb]["ID_LOGIN"] }
    tPAYLOAD.CMD_PART[2] = { PIN = pin }
    tPAYLOAD.CMD_PART[3] = { PARTITION = partitions or partition }
end

function actions.SCENARIO(command)
    local idbinding = NumberOfSocket[command]
    kwLogTrace(6,"#scenario #command #UI", "actions.SCENARIO("..(command or "No Command").." - ".. (actions[idbinding].status or "no actions[idbinding].status")..")")
    
    if (actions[idbinding].status == 1) then 
        actions.fire_login(idbinding)
        actions[idbinding].status = 2  --fatto il login passo ad inviare il comando
    
    elseif actions[idbinding].status == 2 then 
        actions.fire_scenario_command(idbinding)
        actions[idbinding].status = 3
    
    elseif actions[idbinding].status == 3 then
        actions[idbinding].nextStep = nil
        actions.fire_logout(idbinding)
    end
end

function actions.set_scenario_payload(idb, pin, scenarioID)
    tPAYLOAD.CMD_SCENARIO = {}
    pin_to_arm.PIN = pin
    tPAYLOAD.CMD_SCENARIO[1] = { ID_LOGIN = KseniaSettings[idb]["ID_LOGIN"] }
    tPAYLOAD.CMD_SCENARIO[2] = { PIN = pin }
    tPAYLOAD.CMD_SCENARIO[3] = { SCENARIO = scenarioID or scenario }
end

function actions.fire_scenario_command(idb)
    local pin_in_use = pin_to_arm.PIN
    local scenario_in_use = scenario_to_fire  
    actions.set_scenario_payload(idb, pin_in_use, scenario_in_use)
    COMMANDS[idb]["CMD_SCENARIO"] = create_cmd(tCmd.cmduser, tPAYLOAD.CMD_SCENARIO , tPayloadType.exe_scenario, idb)  
    send_commands("CMD_SCENARIO", idb )
end

function actions.OUTPUT(command)
    local idbinding = NumberOfSocket[command]
    kwLogTrace(6,"#scenario #command #UI", "actions.OUTPUT("..(command or "No Command").." - ".. (actions[idbinding].status or "no actions[idbinding].status")..")")
    
    if (actions[idbinding].status == 1) then 
        actions.fire_login(idbinding)
        actions[idbinding].status = 2  --fatto il login passo ad inviare il comando
    
    elseif actions[idbinding].status == 2 then 
        actions.fire_output_command(idbinding)
        actions[idbinding].status = 3
    
    elseif actions[idbinding].status == 3 then
        actions[idbinding].nextStep = nil
        actions.fire_logout(idbinding)
    end
end
function  actions.set_output_settings(pin, ksID, action)
    pin_to_arm.PIN = pin
    output_to_drive = {}
    output_to_drive[1] = { ID = tostring(ksID) or "" }
    output_to_drive[2] = { STA = tostring(action) or ""}
end
function actions.set_output_payload(idb, pin, output)
    tPAYLOAD.CMD_OUTPUT = {}
    tPAYLOAD.CMD_OUTPUT[1] = { ID_LOGIN = KseniaSettings[idb]["ID_LOGIN"] }
    tPAYLOAD.CMD_OUTPUT[2] = { PIN = pin }
    tPAYLOAD.CMD_OUTPUT[3] = { OUTPUT = output or out }
end
function actions.fire_output_command(idb)
    local pin_in_use = pin_to_arm.PIN
    local output_in_use = output_to_drive  -- ho definito in set_partition_settings i messaggi corrispondenti ad ogni partizione
    actions.set_output_payload(idb, pin_in_use, output_in_use)
    COMMANDS[idb]["CMD_OUTPUT"] = create_cmd(tCmd.cmduser, tPAYLOAD.CMD_OUTPUT , tPayloadType.set_output, idb) 
    send_commands("CMD_OUTPUT", idb )
end

function actions.BYPASS(command)
    local idbinding = NumberOfSocket[command]
    kwLogTrace(6,"#scenario #command #UI", "actions.BYPASS("..(command or "No Command").." - ".. (actions[idbinding].status or "no actions[idbinding].status")..")")
    
    if (actions[idbinding].status == 1) then 
        actions.fire_login(idbinding)
        actions[idbinding].status = 2  --fatto il login passo ad inviare il comando
    
    elseif actions[idbinding].status == 2 then 
        actions.fire_bypass_command(idbinding)
        actions[idbinding].status = 3
    
    elseif actions[idbinding].status == 3 then
        actions[idbinding].nextStep = nil
        actions.fire_logout(idbinding)
    end
end
function  actions.set_bypass_settings(pin, ksID, action)
    pin_to_arm.PIN = pin
    bypass_parser = {}
    bypass_parser[1] = "ON"
    bypass_parser[0] = "OFF"
    bypass_parser[-1] = "TGL"
    bypass_parser[2] = "ARM"

    bypass_to_drive = {}
    bypass_to_drive[1] = { ID = tostring(ksID) or "" }
    bypass_to_drive[2] = { BYP = bypass_parser[tonumber(action)] or ""}
end
function actions.set_bypass_payload(idb, pin, tbypass)
    tPAYLOAD.CMD_BYPASS = {}
    tPAYLOAD.CMD_BYPASS[1] = { ID_LOGIN = KseniaSettings[idb]["ID_LOGIN"] }
    tPAYLOAD.CMD_BYPASS[2] = { PIN = pin }
    tPAYLOAD.CMD_BYPASS[3] = { ZONE = tbypass or byp }
end
function actions.fire_bypass_command(idb)
    local pin_in_use = pin_to_arm.PIN
    local zone_in_use = bypass_to_drive  -- ho definito in set_partition_settings i messaggi corrispondenti ad ogni partizione
    actions.set_bypass_payload(idb, pin_in_use, zone_in_use)
    COMMANDS[idb]["CMD_BYPASS"] = create_cmd(tCmd.cmduser, tPAYLOAD.CMD_BYPASS , tPayloadType.byp_zone, idb) 
    send_commands("CMD_BYPASS", idb )
end

function actions.AUXI(command)
    local idbinding = NumberOfSocket[command]
    kwLogTrace(6,"#scenario #command #UI", "actions.AUXI("..(command or "No Command").." - ".. (actions[idbinding].status or "no actions[idbinding].status")..")")
    
    if (actions[idbinding].status == 1) then 
        actions.fire_login(idbinding)
        actions[idbinding].status = 2  --fatto il login passo ad inviare il comando
    
    elseif actions[idbinding].status == 2 then 
        actions.fire_auxi_command(idbinding)
        actions[idbinding].status = 3
    
    elseif actions[idbinding].status == 3 then
        actions[idbinding].nextStep = nil
        actions.fire_logout(idbinding)
    end
end
function  actions.set_auxi_settings(pin, ksID, action)
    pin_to_arm.PIN = pin
    output_to_drive = {}
    output_to_drive[1] = { ID = tostring(ksID) or "" }
    output_to_drive[2] = { STA = tostring(action) or ""}
end
function actions.set_auxi_payload(idb, pin, output)
    tPAYLOAD.CMD_AUXI = {}
    tPAYLOAD.CMD_AUXI[1] = { ID_LOGIN = KseniaSettings[idb]["ID_LOGIN"] }
    tPAYLOAD.CMD_AUXI[2] = { PIN = pin }
    tPAYLOAD.CMD_AUXI[3] = { OUTPUT = output or out }
end
function actions.fire_auxi_command(idb)
    local pin_in_use = pin_to_arm.PIN
    local output_in_use = output_to_drive  -- ho definito in set_partition_settings i messaggi corrispondenti ad ogni partizione
    actions.set_auxi_payload(idb, pin_in_use, output_in_use)
    COMMANDS[idb]["CMD_AUXI"] = create_cmd(tCmd.cmduser, tPAYLOAD.CMD_AUXI , tPayloadType.set_auxi, idb) 
    send_commands("CMD_AUXI", idb )
end


actions.setupCOMMANDS = {}
function actions.setupCOMMANDS.OUTPUT (idb, cmd, idItem)
    local tmp = {}
    --[[if TypeOfSocket[idb] == socket_type.user then 
        usr = "user"
    end]]
    local tOUTPUT = {}
    tOUTPUT[1] = { ID = tostring(idItem) or "" }
    tOUTPUT[2] = { STA = tostring(cmd) or ""}
    tPAYLOAD.CMD_OUTPUT = {}
    tPAYLOAD.CMD_OUTPUT[1] = { ID_LOGIN = KseniaSettings[idb]["ID_LOGIN"]}
    --tPAYLOAD.CMD_OUTPUT[2] = { PIN = TMP_USER_PIN }
    tPAYLOAD.CMD_OUTPUT[2] = { PIN =  tPayloadType.usr.code}--tPayloadType.ergo.code }
    tPAYLOAD.CMD_OUTPUT[3] = { OUTPUT = tOUTPUT }
    COMMANDS[idb]["CMD_OUTPUT"] = create_cmd(tCmd.cmduser, tPAYLOAD.CMD_OUTPUT , tPayloadType.set_output, idb)  
end
actions.fire = {}
function actions.fire.OUTPUT(idb)
    send_commands("CMD_OUTPUT", idb )
end
function actions.setupCOMMANDS.BYPASS (idb, cmd, idItem)
    local tmp = {}
    --[[if TypeOfSocket[idb] == socket_type.user then 
        usr = "user"
    end]]
    bypass_parser = {}
    bypass_parser[1] = "ON"
    bypass_parser[0] = "OFF"
    bypass_parser[-1] = "TGL"
    local tBYPASS = {}
    tBYPASS[1] = { ID = tostring(idItem) or "" }
    tBYPASS[2] = { BYP =  bypass_parser[tonumber(cmd)] }
    tPAYLOAD.CMD_BYPASS = {}
    tPAYLOAD.CMD_BYPASS[1] = { ID_LOGIN = KseniaSettings[idb]["ID_LOGIN"]}
    --tPAYLOAD.CMD_BYPASS[2] = { PIN = TMP_USER_PIN }
    tPAYLOAD.CMD_BYPASS[2] = { PIN =  tPayloadType.usr.code}--tPayloadType.ergo.code }
    tPAYLOAD.CMD_BYPASS[3] = { ZONE = tBYPASS }
    COMMANDS[idb]["CMD_BYPASS"] = create_cmd(tCmd.cmduser, tPAYLOAD.CMD_BYPASS , tPayloadType.byp_zone, idb)  
end
function actions.fire.BYPASS(idb)
    send_commands("CMD_BYPASS", idb )
end
function actions.setupCOMMANDS.SCENARIO (idb, cmd, idItem)
    tPAYLOAD.CMD_SCENARIO = {}
    tPAYLOAD.CMD_SCENARIO[1] = { ID_LOGIN = KseniaSettings[idb]["ID_LOGIN"] }
    tPAYLOAD.CMD_SCENARIO[2] = { PIN =  tPayloadType.usr.code}--tPayloadType.ergo.code }
    tPAYLOAD.CMD_SCENARIO[3] = { SCENARIO = { ID = tostring(idItem) or "" } }
    COMMANDS[idb]["CMD_SCENARIO"] = create_cmd(tCmd.cmduser, tPAYLOAD.CMD_SCENARIO , tPayloadType.exe_scenario, idb)
end
function actions.fire.SCENARIO(idb)
    send_commands("CMD_SCENARIO", idb )
end

function actions.setupCOMMANDS.AUXI (idb, cmd, idItem)
   
    local tAUXI = {}
    tAUXI[1] = { ID = tostring(idItem) or "" }
    tAUXI[2] = { STA = tostring(cmd) or ""}
    tPAYLOAD.CMD_AUXI = {}
    tPAYLOAD.CMD_AUXI[1] = { ID_LOGIN = KseniaSettings[idb]["ID_LOGIN"]}
    --tPAYLOAD.CMD_OUTPUT[2] = { PIN = TMP_USER_PIN }
    tPAYLOAD.CMD_AUXI[2] = { PIN =  tPayloadType.usr.code}--tPayloadType.ergo.code }
    tPAYLOAD.CMD_AUXI[3] = { OUTPUT = tAUXI }
    COMMANDS[idb]["CMD_AUXI"] = create_cmd(tCmd.cmduser, tPAYLOAD.CMD_AUXI , tPayloadType.set_auxi, idb) 

    --print("setupCOMMANDS.AUXI")
    Utility.tprint(tAUXI)
end

function actions.fire.AUXI(idb)
    send_commands("CMD_AUXI", idb )
end

function actions.exeM2Mcommand(usr, action,  cmd, idItem)
    if (usr == socket_type.user or usr == socket_type.installer ) then
        local idb = NumberOfSocket[usr]
        actions.setupCOMMANDS[action](idb, cmd, idItem)
        actions.fire[action](idb)
    end
end

 end)
package.preload['COMMANDS'] = (function (...)
require "variables_and_tables"
--require "Timer"
--require "timer_expired"
j_parse = require "json_b"


function json_lares4(tbl)
    local t = {}
    t=tbl
    local str = ""
    if type(t) == "table" then
        if t[1] ~= nil then
            for i,v in ipairs(t)do
                if type(v) == "table" then
                    str = str .. json_lares4(v)
                end
                str = str ..','
            end
            if str:sub(-1,-1) == ',' then str=str:sub(1, -2) end
        else
            for k,v in pairs(t)do
                str = str ..'"'..k..'":'
                if type(v) == "table" then
                    str = str .."{ "
                    str = str .. json_lares4(v)
                    if str:sub(-1,-1) == ',' then str=str:sub(1, -2) end
                    str = str .."} \n "
                else
                    if type(v) == "number" then v = tostring(v) end  
                    if v:sub(1,1) == '[' and  v:sub(-1,-1) == ']' then
                        str = str .. v..','
                    else
                        str = str ..'"'.. v..'",'
                    end
                end
            end
            if str:sub(-1,-1) == ',' then str=str:sub(1, -2) end
        end
    end
    return str
end

function create_cmd(cmd, payload, payload_type,idbind)
    if (payload_type == nil) then payload_type = tPayloadType.ergo end
    --        "SENDER": "'..KseniaSettings[idbind]["SENDER"]..'",\

	local msg = '{\
        "SENDER": "'..KS.SENDER..'",\
		"RECEIVER": "'..C4:GetUniqueMAC ()..'",\
		"CMD": "'..cmd..'",\
		"ID": "65535",\
		"PAYLOAD_TYPE": "'..payload_type..'",\
        "PAYLOAD": {'.. json_lares4(payload)..'},\
		"TIMESTAMP": "'..os.time(os.date("!*t"))..'",\
		"CRC_16"'
	local crc = create_CRC(msg)
	local message = msg..': "0x'..crc..'"\n}\r\n'
    return message
end




function Update_tPAYLOAD(idbind)

    tPAYLOAD.LOGOUT = {}
    tPAYLOAD.LOGOUT.ID_LOGIN = KseniaSettings[idbind]["ID_LOGIN"]
    tPAYLOAD.LOGOUT_INST = {}
    tPAYLOAD.LOGOUT_INST.ID_LOGIN = KseniaSettings[idbind]["ID_LOGIN"]

    tPAYLOAD.PRG_ZONES = {}
    tPAYLOAD.PRG_ZONES.ID_LOGIN = KseniaSettings[idbind]["ID_LOGIN"]
    tPAYLOAD.PRG_ZONES[tPayload.ID_ITEMS_RANGE] = tPayload.ALLALL
    
    tPAYLOAD.PRG_PARTITIONS = {}
    tPAYLOAD.PRG_PARTITIONS.ID_LOGIN = KseniaSettings[idbind]["ID_LOGIN"]
    tPAYLOAD.PRG_PARTITIONS[tPayload.ID_ITEMS_RANGE] = tPayload.ALLALL
    
    tPAYLOAD.PRG_OUTPUTS = {}
    tPAYLOAD.PRG_OUTPUTS.ID_LOGIN = KseniaSettings[idbind]["ID_LOGIN"]
    tPAYLOAD.PRG_OUTPUTS[tPayload.ID_ITEMS_RANGE] = tPayload.ALLALL
    
    tPAYLOAD.READALL = {}
    tPAYLOAD.READALL.ID_LOGIN = KseniaSettings[idbind]["ID_LOGIN"]
    tPAYLOAD.READALL[tPayload.ID_ITEMS_RANGE] = tPayload.ALLALL

    tPAYLOAD.READSCENARIOS = {}
    tPAYLOAD.READSCENARIOS.ID_LOGIN = KseniaSettings[idbind]["ID_LOGIN"]
    tPAYLOAD.READSCENARIOS[tPayload.ID_ITEMS_RANGE] = tPayload.ALLALL

    tPAYLOAD.REALTIME = {}
    tPAYLOAD.REALTIME.ID_LOGIN = KseniaSettings[idbind]["ID_LOGIN"]
    tPAYLOAD.REALTIME.TYPES = tPayload.STATUSALL

end 

--Command to send on websocket
function Update_string_COMMANDS(idbind)
    --Update_tPAYLOAD()
    if COMMANDS == nil then COMMANDS = {} end
    if COMMANDS[idbind] == nil then COMMANDS[idbind] = {} end

    COMMANDS[idbind].LOGIN = create_cmd(tCmd.login, tPAYLOAD.LOGIN, tPayloadType.ergo.name, idbind)
    COMMANDS[idbind].LOGIN_INST = create_cmd(tCmd.login, tPAYLOAD.LOGIN_INST, tPayloadType.installer.name, idbind)
    COMMANDS[idbind].LOGOUT = create_cmd(tCmd.logout, tPAYLOAD.LOGOUT, tPayloadType.ergo.name, idbind)
    COMMANDS[idbind].LOGOUT_INST = create_cmd(tCmd.logout, tPAYLOAD.LOGOUT, tPayloadType.installer.name, idbind)

    
    COMMANDS[idbind].PRG_ZONES = create_cmd(tCmd.read, tPAYLOAD.PRG_ZONES , tPayloadType.prg_zones, idbind)
    COMMANDS[idbind].PRG_PARTITIONS = create_cmd(tCmd.read, tPAYLOAD.PRG_PARTITIONS , tPayloadType.prg_partitions, idbind)
    COMMANDS[idbind].PRG_OUTPUTS = create_cmd(tCmd.read, tPAYLOAD.PRG_OUTPUTS , tPayloadType.prg_outputs, idbind)
    --COMMANDS[idbind].prg_scenarios = create_cmd(tCmd.read, tPAYLOAD.prg_scenarios , tPayloadType.prg_scenarios, idbind)
    COMMANDS[idbind].READALL = create_cmd(tCmd.read, tPAYLOAD.READALL , tPayloadType.all, idbind)
    COMMANDS[idbind].READSCENARIOS = create_cmd(tCmd.read, tPAYLOAD.READSCENARIOS , tPayloadType.all, idbind)
    COMMANDS[idbind].REALTIME = create_cmd(tCmd.realtime, tPAYLOAD.REALTIME , tPayloadType.register, idbind)
end

function Update_tPAYLOAD_login(idbind)
    tPAYLOAD = {}
    tPAYLOAD.LOGIN = {}
    tPAYLOAD.LOGIN.PIN = tPayloadType.ergo.code   
    tPAYLOAD.LOGIN_INST = {}
    tPAYLOAD.LOGIN_INST.PIN = tPayloadType.installer.code
end
function Update_string_COMMANDS_login(idbind)
    if COMMANDS == nil then COMMANDS = {} end
    if COMMANDS[idbind] == nil then COMMANDS[idbind] = {} end

    local type_of_socket = TypeOfSocket[idbind]
    if type_of_socket == socket_type.installer then
        COMMANDS[idbind].LOGIN = create_cmd(tCmd.login, tPAYLOAD.LOGIN, tPayloadType.ergo.name, idbind)
        COMMANDS[idbind].LOGIN_INST = create_cmd(tCmd.login, tPAYLOAD.LOGIN_INST, tPayloadType.installer.name, idbind)
    else
        COMMANDS[idbind].LOGIN = create_cmd(tCmd.login, tPAYLOAD.LOGIN, tPayloadType.usr.name, idbind)
    end
end
                                     
 end)
package.preload['common.c4_command'] = (function (...)
--[[=============================================================================
    Functions for handling and executing commands and actions

    Copyright 2016 Control4 Corporation. All Rights Reserved.
===============================================================================]]
require "common.c4_driver_declarations"

-- Set template version for this file
if (TEMPLATE_VERSION ~= nil) then
	TEMPLATE_VERSION.c4_command = "2016.01.08"
end

--[[=============================================================================
    ExecuteCommand(sCommand, tParams)

    Description
    Function called by Director when a command is received for this DriverWorks
    driver. This includes commands created in Composer programming.

    Parameters
    sCommand(string) - Command to be sent
    tParams(table)   - Lua table of parameters for the sent command

    Returns
    Nothing
===============================================================================]]
function ExecuteCommand(sCommand, tParams)
	LogTrace("ExecuteCommand(" .. sCommand .. ")")
	LogInfo(tParams)

	-- Remove any spaces (trim the command)
	local trimmedCommand = string.gsub(sCommand, " ", "")
	local status, ret

	-- if function exists then execute (non-stripped)
	if (EX_CMD[sCommand] ~= nil and type(EX_CMD[sCommand]) == "function") then
		status, ret = pcall(EX_CMD[sCommand], tParams)
	-- elseif trimmed function exists then execute
	elseif (EX_CMD[trimmedCommand] ~= nil and type(EX_CMD[trimmedCommand]) == "function") then
		status, ret = pcall(EX_CMD[trimmedCommand], tParams)
	elseif (EX_CMD[sCommand] ~= nil) then
		QueueCommand(EX_CMD[sCommand])
		status = true
	else
		LogInfo("ExecuteCommand: Unhandled command = " .. sCommand)
		status = true
	end
	
	if (not status) then
		LogError("LUA_ERROR: " .. ret)
	end
	
	return ret -- Return whatever the function returns because it might be xml, a return code, and so on
end

--[[=============================================================================
    EX_CMD.LUA_ACTION(tParams)

    Description
    Function called for any actions executed by the user from the Actions Tab
    in Composer.

    Parameters
    tParams(table) - Lua table of parameters for the command option

    Returns
    Nothing
===============================================================================]]
function EX_CMD.LUA_ACTION(tParams)
	if (tParams ~= nil) then
		for cmd, cmdv in pairs(tParams) do
			if (cmd == "ACTION" and cmdv ~= nil) then
				local status, err = pcall(LUA_ACTION[cmdv], tParams)
				if (not status) then
					LogError("LUA_ERROR: " .. err)
				end
				break
			end
		end
	end
end

--[[=============================================================================
    ReceivedFromProxy(idBinding, sCommand, tParams)

    Description
    Function called for any actions executed by the user from the Actions Tab
    in Composer.

    Parameters
    idBinding(int)   - Binding ID of the proxy that sent a BindMessage to the
                       DriverWorks driver.
    sCommand(string) - Command that was sent
    tParams(table)   - Lua table of received command parameters

    Returns
    Nothing
===============================================================================]]
function ReceivedFromProxy(idBinding, sCommand, tParams)
	
	LogTrace("ReceivedFromProxy() "..(idBinding or " NO idBinding -").." - "..(sCommand or " NO sCommand-").." - "..(tstring(tParams,2) or " NO tParams"))
	LICENSE_MGR:ReceivedFromProxy(idBinding, sCommand, tParams)

	if (sCommand ~= nil) then

		-- initial table variable if nil
		if (tParams == nil) then
			tParams = {}
		end
		if ((PRX_CMD[sCommand]) ~= nil) then
			local status, err = pcall(PRX_CMD[sCommand], idBinding, tParams)
			if (not status) then
				LogError("LUA_ERROR: " .. err)
			end
		elseif((PRX_CMD[sCommand]) == READ_PANEL_INFO) then
			kwLogTrace(5,"#Proxy #Command","c4_command >> READ_PANEL_INFO, tParams ", tParams)--GL check
		else
			kwLogTrace(5,"#Proxy #Command","ReceivedFromProxy: Unhandled command = " .. sCommand)--GL check
		end
		--GL20191119
		LICENSE_MGR:ReceivedFromProxy (idBinding, sCommand, tParams)
	end
end

--[[
	This function is called when a UI (Navigator) requests data, and
	calls the function requested.
--]]
function UIRequest(sRequest, tParams)
	local ret = ""

	if (sRequest ~= nil) then
		tParams = tParams or {}   -- initial table variable if nil
		LogTrace("UIRequest(): " .. sRequest .. "; Call Function UI_REQ." .. sRequest .. "()")
		LogInfo(tParams)

		if (UI_REQ[sRequest]) ~= nil then
			ret = UI_REQ[sRequest](tParams)
		else
			LogWarn("UIRequest: Unhandled request = " .. sRequest)
		end
	end
    return ret
end
 end)
package.preload['device_commands'] = (function (...)

function PRX_CMD.DATA_CHANGED(idBinding, tParams)
  print("PRX_CMD.DATA_CHANGED.id:"..tostring(idBinding))
  if (idBinding == KSENIA_AUXIHT_BINDINGID) then
    local json_table = C4:JsonDecode(tParams["data"])
    for id,json_table_my_auxiht in pairs(json_table) do
      local command = string.upper(json_table_my_auxiht["status"])
      if (id) then
        actions.exeM2Mcommand(socket_type.installer, "AUXI",  command, tonumber(id))
      end
    end
  end
end
 end)
--[[=============================================================================
    Template for Security Panel/Security Partition Driver

    Copyright 2015 Control4 Corporation. All Rights Reserved. 
===============================================================================]]

require "common.c4_driver_declarations"
require "common.c4_common"
require "common.c4_init"
require "common.c4_property"
require "common.c4_command"
require "common.c4_diagnostics"
require "common.c4_notify"
require "common.c4_utils" 
require "panel_proxy.securitypanel"
require "partition_proxy.securitypartition"
require "wssocket_parser"
require "timer_expired"
require "timer_expired_init"
require "softkiwi_utils"
require "utility"  
require "variables_and_tables"
require "ksenia_communicator"
require "actions"
require "device_specific_commands"
require "driver_functions"
require "properties"
require "ksenia_persist"
require "ksenia_debugger"
require "ksenia_general_manager"
require "action_on_partitions"
require "device_commands"

--- Build License Manager object
require 'SKC4.LicenseManager'
--- Config License Manager
LICENSE_MGR:setParamValue("ProductId", 196, "DRIVERCENTRAL") -- Product ID
LICENSE_MGR:setParamValue("FreeDriver", false, "DRIVERCENTRAL") -- (Driver is not a free driver)
LICENSE_MGR:setParamValue("FileName", "Ksenia_lares4.c4z", "DRIVERCENTRAL") -- Filename
--end license

if (TEMPLATE_VERSION ~= nil) then
	TEMPLATE_VERSION.driver = "2018.03.28"
end

MemorizedPIN = nil
-- TODO:
-- Make sure you set your DRIVER_NAME here
DRIVER_NAME = "Ksenialares4"

-- TODO:
-- This macro is utilized to identify the version string of the driver being deployed.
TEMPLATE_VERSION.security_system_template_version = "2018.03.28"

-- NOTE:
-- The following properties should not have to be changed, but can be if the author feels it
-- is necessary. Great care should be taken when modifying these values though, since the
-- values correspond to other values contained from within other files in the project.
PANEL_PROXY_BINDINGID = DEFAULT_PROXY_BINDINGID
BASE_PARTITION_PROXY_BINDINGID = DEFAULT_PROXY_BINDINGID + 1
SERIAL_PORT_BINDINGID = 1

-- TODO:
-- Set the number of partitions and zones supported by this driver.
PARTITION_ID_MAX = 20 -- TODOKW ... capire quante sono
KSENIA_DOMUS_BINDINGID = 376
KSENIA_AUXIHT_BINDINGID = 377


--[[==========================================================================================
	Initialization Code
============================================================================================]]
function ON_DRIVER_EARLY_INIT.MainDriver()
end

function ON_DRIVER_INIT.MainDriver()
	-- TODO:
	-- Set your unique driver name here, so driver messages can be distinguished in the log files
	SetLogName("KseniaLares4")
	kwLogTrace(3, "#init #onDriverInit","----->>>>>>>>>>>>>>>>> ON_DRIVER_INIT.MainDriver <<<<<<<<<<<<<-----") --OKIO
	--TODO:
	-- Change the default zone text if desired
	-- SetDefaultZoneName("Your Custome Zone Name")
	Initialize_SecuritySystem()
	gNeedReadFromPanel = true
end

function ON_DRIVER_LATEINIT.MainDriver()
	kwLogTrace(3, "#init #onDriverLateInit","----->>>>>>>>>>>>>>>>> ON_DRIVER_LATEINIT.MainDriver <<<<<<<<<<<<<-----") --OKIO
	--KsCom:LATEINIT()
	C4:UpdateProperty(KS_PROP["DRIVER_VERSION"], C4:GetDriverConfigInfo ("version"))
	C4:SetPropertyAttribs("Automatic Updates", 1)
	
	-- C4:AddDynamicBinding(KSENIA_DOMUS_BINDINGID, "CONTROL", true, "KSenia Domus Data", "KSENIA_DOMUS_DATA", false, true)
	ON_DRIVER_LATEINIT.ksenia()
end


function Initialize_SecuritySystem()
	kwLogTrace(3, "#init #system","----->>>>>>>>>>>>>>>>> Initialize_SecuritySystem <<<<<<<<<<<<<-----") --OKIO
	TheSecurityPanel = SecurityPanel:new(PANEL_PROXY_BINDINGID)    

	for PartitionIndex = 1, PARTITION_ID_MAX do
		SecurityPartition:new(PartitionIndex, BASE_PARTITION_PROXY_BINDINGID + (PartitionIndex - 1))
	end

	TheSecurityPanel:Initialize()
end

function ON_DRIVER_DESTROYED.MainDriver()
	print ('ON_DRIVER_DESTROYED.MainDriver called')
	C4:DestroyServer(HTTP_PORT) 
	close_all_socket()
end
function close_all_socket()
	for k,v in pairs(TypeOfSocket) do
		send_commands("LOGOUT", k)
		close_socket(v)
	end
end
